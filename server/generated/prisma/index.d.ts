
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Customer
 * 
 */
export type Customer = $Result.DefaultSelection<Prisma.$CustomerPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model Kitchen
 * 
 */
export type Kitchen = $Result.DefaultSelection<Prisma.$KitchenPayload>
/**
 * Model KitchenLog
 * 
 */
export type KitchenLog = $Result.DefaultSelection<Prisma.$KitchenLogPayload>
/**
 * Model DishOrder
 * 
 */
export type DishOrder = $Result.DefaultSelection<Prisma.$DishOrderPayload>
/**
 * Model Order
 * 
 */
export type Order = $Result.DefaultSelection<Prisma.$OrderPayload>
/**
 * Model DiscountProduct
 * 
 */
export type DiscountProduct = $Result.DefaultSelection<Prisma.$DiscountProductPayload>
/**
 * Model Discount
 * 
 */
export type Discount = $Result.DefaultSelection<Prisma.$DiscountPayload>
/**
 * Model TaxDetail
 * 
 */
export type TaxDetail = $Result.DefaultSelection<Prisma.$TaxDetailPayload>
/**
 * Model PaymentDetail
 * 
 */
export type PaymentDetail = $Result.DefaultSelection<Prisma.$PaymentDetailPayload>
/**
 * Model OrderSession
 * 
 */
export type OrderSession = $Result.DefaultSelection<Prisma.$OrderSessionPayload>
/**
 * Model Shop
 * 
 */
export type Shop = $Result.DefaultSelection<Prisma.$ShopPayload>
/**
 * Model Image
 * 
 */
export type Image = $Result.DefaultSelection<Prisma.$ImagePayload>
/**
 * Model DishCategory
 * 
 */
export type DishCategory = $Result.DefaultSelection<Prisma.$DishCategoryPayload>
/**
 * Model Dish
 * 
 */
export type Dish = $Result.DefaultSelection<Prisma.$DishPayload>
/**
 * Model Unit
 * 
 */
export type Unit = $Result.DefaultSelection<Prisma.$UnitPayload>
/**
 * Model TablePosition
 * 
 */
export type TablePosition = $Result.DefaultSelection<Prisma.$TablePositionPayload>
/**
 * Model Table
 * 
 */
export type Table = $Result.DefaultSelection<Prisma.$TablePayload>
/**
 * Model EmployeeDepartment
 * 
 */
export type EmployeeDepartment = $Result.DefaultSelection<Prisma.$EmployeeDepartmentPayload>
/**
 * Model EmployeePosition
 * 
 */
export type EmployeePosition = $Result.DefaultSelection<Prisma.$EmployeePositionPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TokenType: {
  REFRESH: 'REFRESH',
  RESET_PASSWORD: 'RESET_PASSWORD',
  VERIFY_EMAIL: 'VERIFY_EMAIL'
};

export type TokenType = (typeof TokenType)[keyof typeof TokenType]


export const KitchenActionEnum: {
  update_served: 'update_served',
  update_cooked: 'update_cooked',
  undo_cooked: 'undo_cooked',
  undo_served: 'undo_served'
};

export type KitchenActionEnum = (typeof KitchenActionEnum)[keyof typeof KitchenActionEnum]


export const DishOrderStatus: {
  confirmed: 'confirmed',
  cooked: 'cooked',
  served: 'served'
};

export type DishOrderStatus = (typeof DishOrderStatus)[keyof typeof DishOrderStatus]


export const OrderSessionStatus: {
  unpaid: 'unpaid',
  paid: 'paid',
  cancelled: 'cancelled'
};

export type OrderSessionStatus = (typeof OrderSessionStatus)[keyof typeof OrderSessionStatus]


export const DiscountValueType: {
  percentage: 'percentage',
  absolute: 'absolute'
};

export type DiscountValueType = (typeof DiscountValueType)[keyof typeof DiscountValueType]


export const DiscountType: {
  invoice: 'invoice',
  product: 'product'
};

export type DiscountType = (typeof DiscountType)[keyof typeof DiscountType]


export const PaymentMethodEnum: {
  cash: 'cash',
  bank_transfer: 'bank_transfer',
  vnpay: 'vnpay'
};

export type PaymentMethodEnum = (typeof PaymentMethodEnum)[keyof typeof PaymentMethodEnum]


export const Status: {
  enabled: 'enabled',
  disabled: 'disabled'
};

export type Status = (typeof Status)[keyof typeof Status]


export const Switchabletatus: {
  activated: 'activated',
  deactivated: 'deactivated',
  disabled: 'disabled'
};

export type Switchabletatus = (typeof Switchabletatus)[keyof typeof Switchabletatus]


export const RoundingPaymentType: {
  ROUND: 'ROUND',
  FLOOR: 'FLOOR',
  CEIL: 'CEIL'
};

export type RoundingPaymentType = (typeof RoundingPaymentType)[keyof typeof RoundingPaymentType]


export const Role: {
  user: 'user',
  admin: 'admin'
};

export type Role = (typeof Role)[keyof typeof Role]

}

export type TokenType = $Enums.TokenType

export const TokenType: typeof $Enums.TokenType

export type KitchenActionEnum = $Enums.KitchenActionEnum

export const KitchenActionEnum: typeof $Enums.KitchenActionEnum

export type DishOrderStatus = $Enums.DishOrderStatus

export const DishOrderStatus: typeof $Enums.DishOrderStatus

export type OrderSessionStatus = $Enums.OrderSessionStatus

export const OrderSessionStatus: typeof $Enums.OrderSessionStatus

export type DiscountValueType = $Enums.DiscountValueType

export const DiscountValueType: typeof $Enums.DiscountValueType

export type DiscountType = $Enums.DiscountType

export const DiscountType: typeof $Enums.DiscountType

export type PaymentMethodEnum = $Enums.PaymentMethodEnum

export const PaymentMethodEnum: typeof $Enums.PaymentMethodEnum

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type Switchabletatus = $Enums.Switchabletatus

export const Switchabletatus: typeof $Enums.Switchabletatus

export type RoundingPaymentType = $Enums.RoundingPaymentType

export const RoundingPaymentType: typeof $Enums.RoundingPaymentType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **Customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.CustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kitchen`: Exposes CRUD operations for the **Kitchen** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Kitchens
    * const kitchens = await prisma.kitchen.findMany()
    * ```
    */
  get kitchen(): Prisma.KitchenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.kitchenLog`: Exposes CRUD operations for the **KitchenLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KitchenLogs
    * const kitchenLogs = await prisma.kitchenLog.findMany()
    * ```
    */
  get kitchenLog(): Prisma.KitchenLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dishOrder`: Exposes CRUD operations for the **DishOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DishOrders
    * const dishOrders = await prisma.dishOrder.findMany()
    * ```
    */
  get dishOrder(): Prisma.DishOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.order`: Exposes CRUD operations for the **Order** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.order.findMany()
    * ```
    */
  get order(): Prisma.OrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discountProduct`: Exposes CRUD operations for the **DiscountProduct** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscountProducts
    * const discountProducts = await prisma.discountProduct.findMany()
    * ```
    */
  get discountProduct(): Prisma.DiscountProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discount`: Exposes CRUD operations for the **Discount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Discounts
    * const discounts = await prisma.discount.findMany()
    * ```
    */
  get discount(): Prisma.DiscountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.taxDetail`: Exposes CRUD operations for the **TaxDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaxDetails
    * const taxDetails = await prisma.taxDetail.findMany()
    * ```
    */
  get taxDetail(): Prisma.TaxDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.paymentDetail`: Exposes CRUD operations for the **PaymentDetail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentDetails
    * const paymentDetails = await prisma.paymentDetail.findMany()
    * ```
    */
  get paymentDetail(): Prisma.PaymentDetailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.orderSession`: Exposes CRUD operations for the **OrderSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderSessions
    * const orderSessions = await prisma.orderSession.findMany()
    * ```
    */
  get orderSession(): Prisma.OrderSessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shop`: Exposes CRUD operations for the **Shop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shops
    * const shops = await prisma.shop.findMany()
    * ```
    */
  get shop(): Prisma.ShopDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.image`: Exposes CRUD operations for the **Image** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Images
    * const images = await prisma.image.findMany()
    * ```
    */
  get image(): Prisma.ImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dishCategory`: Exposes CRUD operations for the **DishCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DishCategories
    * const dishCategories = await prisma.dishCategory.findMany()
    * ```
    */
  get dishCategory(): Prisma.DishCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.dish`: Exposes CRUD operations for the **Dish** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dishes
    * const dishes = await prisma.dish.findMany()
    * ```
    */
  get dish(): Prisma.DishDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tablePosition`: Exposes CRUD operations for the **TablePosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TablePositions
    * const tablePositions = await prisma.tablePosition.findMany()
    * ```
    */
  get tablePosition(): Prisma.TablePositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.table`: Exposes CRUD operations for the **Table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tables
    * const tables = await prisma.table.findMany()
    * ```
    */
  get table(): Prisma.TableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeDepartment`: Exposes CRUD operations for the **EmployeeDepartment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeDepartments
    * const employeeDepartments = await prisma.employeeDepartment.findMany()
    * ```
    */
  get employeeDepartment(): Prisma.EmployeeDepartmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeePosition`: Exposes CRUD operations for the **EmployeePosition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeePositions
    * const employeePositions = await prisma.employeePosition.findMany()
    * ```
    */
  get employeePosition(): Prisma.EmployeePositionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Customer: 'Customer',
    Token: 'Token',
    Kitchen: 'Kitchen',
    KitchenLog: 'KitchenLog',
    DishOrder: 'DishOrder',
    Order: 'Order',
    DiscountProduct: 'DiscountProduct',
    Discount: 'Discount',
    TaxDetail: 'TaxDetail',
    PaymentDetail: 'PaymentDetail',
    OrderSession: 'OrderSession',
    Shop: 'Shop',
    Image: 'Image',
    DishCategory: 'DishCategory',
    Dish: 'Dish',
    Unit: 'Unit',
    TablePosition: 'TablePosition',
    Table: 'Table',
    EmployeeDepartment: 'EmployeeDepartment',
    EmployeePosition: 'EmployeePosition',
    Employee: 'Employee'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "customer" | "token" | "kitchen" | "kitchenLog" | "dishOrder" | "order" | "discountProduct" | "discount" | "taxDetail" | "paymentDetail" | "orderSession" | "shop" | "image" | "dishCategory" | "dish" | "unit" | "tablePosition" | "table" | "employeeDepartment" | "employeePosition" | "employee"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Customer: {
        payload: Prisma.$CustomerPayload<ExtArgs>
        fields: Prisma.CustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findFirst: {
            args: Prisma.CustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          findMany: {
            args: Prisma.CustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          create: {
            args: Prisma.CustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          createMany: {
            args: Prisma.CustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          delete: {
            args: Prisma.CustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          update: {
            args: Prisma.CustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          deleteMany: {
            args: Prisma.CustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>[]
          }
          upsert: {
            args: Prisma.CustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CustomerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.CustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.CustomerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      Kitchen: {
        payload: Prisma.$KitchenPayload<ExtArgs>
        fields: Prisma.KitchenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitchenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitchenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          findFirst: {
            args: Prisma.KitchenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitchenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          findMany: {
            args: Prisma.KitchenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          create: {
            args: Prisma.KitchenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          createMany: {
            args: Prisma.KitchenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitchenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          delete: {
            args: Prisma.KitchenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          update: {
            args: Prisma.KitchenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          deleteMany: {
            args: Prisma.KitchenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitchenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KitchenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>[]
          }
          upsert: {
            args: Prisma.KitchenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenPayload>
          }
          aggregate: {
            args: Prisma.KitchenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKitchen>
          }
          groupBy: {
            args: Prisma.KitchenGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitchenGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitchenCountArgs<ExtArgs>
            result: $Utils.Optional<KitchenCountAggregateOutputType> | number
          }
        }
      }
      KitchenLog: {
        payload: Prisma.$KitchenLogPayload<ExtArgs>
        fields: Prisma.KitchenLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KitchenLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KitchenLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>
          }
          findFirst: {
            args: Prisma.KitchenLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KitchenLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>
          }
          findMany: {
            args: Prisma.KitchenLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>[]
          }
          create: {
            args: Prisma.KitchenLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>
          }
          createMany: {
            args: Prisma.KitchenLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KitchenLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>[]
          }
          delete: {
            args: Prisma.KitchenLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>
          }
          update: {
            args: Prisma.KitchenLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>
          }
          deleteMany: {
            args: Prisma.KitchenLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KitchenLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KitchenLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>[]
          }
          upsert: {
            args: Prisma.KitchenLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KitchenLogPayload>
          }
          aggregate: {
            args: Prisma.KitchenLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKitchenLog>
          }
          groupBy: {
            args: Prisma.KitchenLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<KitchenLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.KitchenLogCountArgs<ExtArgs>
            result: $Utils.Optional<KitchenLogCountAggregateOutputType> | number
          }
        }
      }
      DishOrder: {
        payload: Prisma.$DishOrderPayload<ExtArgs>
        fields: Prisma.DishOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DishOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DishOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>
          }
          findFirst: {
            args: Prisma.DishOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DishOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>
          }
          findMany: {
            args: Prisma.DishOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>[]
          }
          create: {
            args: Prisma.DishOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>
          }
          createMany: {
            args: Prisma.DishOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DishOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>[]
          }
          delete: {
            args: Prisma.DishOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>
          }
          update: {
            args: Prisma.DishOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>
          }
          deleteMany: {
            args: Prisma.DishOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DishOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DishOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>[]
          }
          upsert: {
            args: Prisma.DishOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishOrderPayload>
          }
          aggregate: {
            args: Prisma.DishOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDishOrder>
          }
          groupBy: {
            args: Prisma.DishOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<DishOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.DishOrderCountArgs<ExtArgs>
            result: $Utils.Optional<DishOrderCountAggregateOutputType> | number
          }
        }
      }
      Order: {
        payload: Prisma.$OrderPayload<ExtArgs>
        fields: Prisma.OrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findFirst: {
            args: Prisma.OrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          findMany: {
            args: Prisma.OrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          create: {
            args: Prisma.OrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          createMany: {
            args: Prisma.OrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          delete: {
            args: Prisma.OrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          update: {
            args: Prisma.OrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          deleteMany: {
            args: Prisma.OrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>[]
          }
          upsert: {
            args: Prisma.OrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderPayload>
          }
          aggregate: {
            args: Prisma.OrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrder>
          }
          groupBy: {
            args: Prisma.OrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderCountArgs<ExtArgs>
            result: $Utils.Optional<OrderCountAggregateOutputType> | number
          }
        }
      }
      DiscountProduct: {
        payload: Prisma.$DiscountProductPayload<ExtArgs>
        fields: Prisma.DiscountProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>
          }
          findFirst: {
            args: Prisma.DiscountProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>
          }
          findMany: {
            args: Prisma.DiscountProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>[]
          }
          create: {
            args: Prisma.DiscountProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>
          }
          createMany: {
            args: Prisma.DiscountProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>[]
          }
          delete: {
            args: Prisma.DiscountProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>
          }
          update: {
            args: Prisma.DiscountProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>
          }
          deleteMany: {
            args: Prisma.DiscountProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>[]
          }
          upsert: {
            args: Prisma.DiscountProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountProductPayload>
          }
          aggregate: {
            args: Prisma.DiscountProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscountProduct>
          }
          groupBy: {
            args: Prisma.DiscountProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountProductCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountProductCountAggregateOutputType> | number
          }
        }
      }
      Discount: {
        payload: Prisma.$DiscountPayload<ExtArgs>
        fields: Prisma.DiscountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findFirst: {
            args: Prisma.DiscountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          findMany: {
            args: Prisma.DiscountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          create: {
            args: Prisma.DiscountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          createMany: {
            args: Prisma.DiscountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          delete: {
            args: Prisma.DiscountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          update: {
            args: Prisma.DiscountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          deleteMany: {
            args: Prisma.DiscountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>[]
          }
          upsert: {
            args: Prisma.DiscountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscountPayload>
          }
          aggregate: {
            args: Prisma.DiscountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscount>
          }
          groupBy: {
            args: Prisma.DiscountGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscountGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscountCountArgs<ExtArgs>
            result: $Utils.Optional<DiscountCountAggregateOutputType> | number
          }
        }
      }
      TaxDetail: {
        payload: Prisma.$TaxDetailPayload<ExtArgs>
        fields: Prisma.TaxDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaxDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaxDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>
          }
          findFirst: {
            args: Prisma.TaxDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaxDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>
          }
          findMany: {
            args: Prisma.TaxDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>[]
          }
          create: {
            args: Prisma.TaxDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>
          }
          createMany: {
            args: Prisma.TaxDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaxDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>[]
          }
          delete: {
            args: Prisma.TaxDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>
          }
          update: {
            args: Prisma.TaxDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>
          }
          deleteMany: {
            args: Prisma.TaxDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaxDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaxDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>[]
          }
          upsert: {
            args: Prisma.TaxDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaxDetailPayload>
          }
          aggregate: {
            args: Prisma.TaxDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTaxDetail>
          }
          groupBy: {
            args: Prisma.TaxDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaxDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaxDetailCountArgs<ExtArgs>
            result: $Utils.Optional<TaxDetailCountAggregateOutputType> | number
          }
        }
      }
      PaymentDetail: {
        payload: Prisma.$PaymentDetailPayload<ExtArgs>
        fields: Prisma.PaymentDetailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentDetailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentDetailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>
          }
          findFirst: {
            args: Prisma.PaymentDetailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentDetailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>
          }
          findMany: {
            args: Prisma.PaymentDetailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>[]
          }
          create: {
            args: Prisma.PaymentDetailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>
          }
          createMany: {
            args: Prisma.PaymentDetailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentDetailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>[]
          }
          delete: {
            args: Prisma.PaymentDetailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>
          }
          update: {
            args: Prisma.PaymentDetailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDetailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentDetailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentDetailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>[]
          }
          upsert: {
            args: Prisma.PaymentDetailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentDetailPayload>
          }
          aggregate: {
            args: Prisma.PaymentDetailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentDetail>
          }
          groupBy: {
            args: Prisma.PaymentDetailGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentDetailGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentDetailCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentDetailCountAggregateOutputType> | number
          }
        }
      }
      OrderSession: {
        payload: Prisma.$OrderSessionPayload<ExtArgs>
        fields: Prisma.OrderSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>
          }
          findFirst: {
            args: Prisma.OrderSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>
          }
          findMany: {
            args: Prisma.OrderSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>[]
          }
          create: {
            args: Prisma.OrderSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>
          }
          createMany: {
            args: Prisma.OrderSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OrderSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>[]
          }
          delete: {
            args: Prisma.OrderSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>
          }
          update: {
            args: Prisma.OrderSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>
          }
          deleteMany: {
            args: Prisma.OrderSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OrderSessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>[]
          }
          upsert: {
            args: Prisma.OrderSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderSessionPayload>
          }
          aggregate: {
            args: Prisma.OrderSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderSession>
          }
          groupBy: {
            args: Prisma.OrderSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderSessionCountArgs<ExtArgs>
            result: $Utils.Optional<OrderSessionCountAggregateOutputType> | number
          }
        }
      }
      Shop: {
        payload: Prisma.$ShopPayload<ExtArgs>
        fields: Prisma.ShopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findFirst: {
            args: Prisma.ShopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          findMany: {
            args: Prisma.ShopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          create: {
            args: Prisma.ShopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          createMany: {
            args: Prisma.ShopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          delete: {
            args: Prisma.ShopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          update: {
            args: Prisma.ShopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          deleteMany: {
            args: Prisma.ShopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShopUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>[]
          }
          upsert: {
            args: Prisma.ShopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShopPayload>
          }
          aggregate: {
            args: Prisma.ShopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShop>
          }
          groupBy: {
            args: Prisma.ShopGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShopGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShopCountArgs<ExtArgs>
            result: $Utils.Optional<ShopCountAggregateOutputType> | number
          }
        }
      }
      Image: {
        payload: Prisma.$ImagePayload<ExtArgs>
        fields: Prisma.ImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findFirst: {
            args: Prisma.ImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          findMany: {
            args: Prisma.ImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          create: {
            args: Prisma.ImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          createMany: {
            args: Prisma.ImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          delete: {
            args: Prisma.ImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          update: {
            args: Prisma.ImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          deleteMany: {
            args: Prisma.ImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>[]
          }
          upsert: {
            args: Prisma.ImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ImagePayload>
          }
          aggregate: {
            args: Prisma.ImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateImage>
          }
          groupBy: {
            args: Prisma.ImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ImageCountArgs<ExtArgs>
            result: $Utils.Optional<ImageCountAggregateOutputType> | number
          }
        }
      }
      DishCategory: {
        payload: Prisma.$DishCategoryPayload<ExtArgs>
        fields: Prisma.DishCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DishCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DishCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>
          }
          findFirst: {
            args: Prisma.DishCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DishCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>
          }
          findMany: {
            args: Prisma.DishCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>[]
          }
          create: {
            args: Prisma.DishCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>
          }
          createMany: {
            args: Prisma.DishCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DishCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>[]
          }
          delete: {
            args: Prisma.DishCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>
          }
          update: {
            args: Prisma.DishCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>
          }
          deleteMany: {
            args: Prisma.DishCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DishCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DishCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>[]
          }
          upsert: {
            args: Prisma.DishCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishCategoryPayload>
          }
          aggregate: {
            args: Prisma.DishCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDishCategory>
          }
          groupBy: {
            args: Prisma.DishCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<DishCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.DishCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<DishCategoryCountAggregateOutputType> | number
          }
        }
      }
      Dish: {
        payload: Prisma.$DishPayload<ExtArgs>
        fields: Prisma.DishFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DishFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DishFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          findFirst: {
            args: Prisma.DishFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DishFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          findMany: {
            args: Prisma.DishFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          create: {
            args: Prisma.DishCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          createMany: {
            args: Prisma.DishCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DishCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          delete: {
            args: Prisma.DishDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          update: {
            args: Prisma.DishUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          deleteMany: {
            args: Prisma.DishDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DishUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DishUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>[]
          }
          upsert: {
            args: Prisma.DishUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DishPayload>
          }
          aggregate: {
            args: Prisma.DishAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDish>
          }
          groupBy: {
            args: Prisma.DishGroupByArgs<ExtArgs>
            result: $Utils.Optional<DishGroupByOutputType>[]
          }
          count: {
            args: Prisma.DishCountArgs<ExtArgs>
            result: $Utils.Optional<DishCountAggregateOutputType> | number
          }
        }
      }
      Unit: {
        payload: Prisma.$UnitPayload<ExtArgs>
        fields: Prisma.UnitFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UnitFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UnitFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findFirst: {
            args: Prisma.UnitFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UnitFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          findMany: {
            args: Prisma.UnitFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          create: {
            args: Prisma.UnitCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          createMany: {
            args: Prisma.UnitCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UnitCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          delete: {
            args: Prisma.UnitDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          update: {
            args: Prisma.UnitUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          deleteMany: {
            args: Prisma.UnitDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UnitUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UnitUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>[]
          }
          upsert: {
            args: Prisma.UnitUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UnitPayload>
          }
          aggregate: {
            args: Prisma.UnitAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUnit>
          }
          groupBy: {
            args: Prisma.UnitGroupByArgs<ExtArgs>
            result: $Utils.Optional<UnitGroupByOutputType>[]
          }
          count: {
            args: Prisma.UnitCountArgs<ExtArgs>
            result: $Utils.Optional<UnitCountAggregateOutputType> | number
          }
        }
      }
      TablePosition: {
        payload: Prisma.$TablePositionPayload<ExtArgs>
        fields: Prisma.TablePositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TablePositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TablePositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>
          }
          findFirst: {
            args: Prisma.TablePositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TablePositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>
          }
          findMany: {
            args: Prisma.TablePositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>[]
          }
          create: {
            args: Prisma.TablePositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>
          }
          createMany: {
            args: Prisma.TablePositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TablePositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>[]
          }
          delete: {
            args: Prisma.TablePositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>
          }
          update: {
            args: Prisma.TablePositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>
          }
          deleteMany: {
            args: Prisma.TablePositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TablePositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TablePositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>[]
          }
          upsert: {
            args: Prisma.TablePositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePositionPayload>
          }
          aggregate: {
            args: Prisma.TablePositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTablePosition>
          }
          groupBy: {
            args: Prisma.TablePositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TablePositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TablePositionCountArgs<ExtArgs>
            result: $Utils.Optional<TablePositionCountAggregateOutputType> | number
          }
        }
      }
      Table: {
        payload: Prisma.$TablePayload<ExtArgs>
        fields: Prisma.TableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findFirst: {
            args: Prisma.TableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          findMany: {
            args: Prisma.TableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          create: {
            args: Prisma.TableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          createMany: {
            args: Prisma.TableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TableCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          delete: {
            args: Prisma.TableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          update: {
            args: Prisma.TableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          deleteMany: {
            args: Prisma.TableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TableUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>[]
          }
          upsert: {
            args: Prisma.TableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TablePayload>
          }
          aggregate: {
            args: Prisma.TableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTable>
          }
          groupBy: {
            args: Prisma.TableGroupByArgs<ExtArgs>
            result: $Utils.Optional<TableGroupByOutputType>[]
          }
          count: {
            args: Prisma.TableCountArgs<ExtArgs>
            result: $Utils.Optional<TableCountAggregateOutputType> | number
          }
        }
      }
      EmployeeDepartment: {
        payload: Prisma.$EmployeeDepartmentPayload<ExtArgs>
        fields: Prisma.EmployeeDepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeDepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeDepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>
          }
          findFirst: {
            args: Prisma.EmployeeDepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeDepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>
          }
          findMany: {
            args: Prisma.EmployeeDepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>[]
          }
          create: {
            args: Prisma.EmployeeDepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>
          }
          createMany: {
            args: Prisma.EmployeeDepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeDepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>[]
          }
          delete: {
            args: Prisma.EmployeeDepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>
          }
          update: {
            args: Prisma.EmployeeDepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeDepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeDepartmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>[]
          }
          upsert: {
            args: Prisma.EmployeeDepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeDepartmentPayload>
          }
          aggregate: {
            args: Prisma.EmployeeDepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeDepartment>
          }
          groupBy: {
            args: Prisma.EmployeeDepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeDepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeDepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeDepartmentCountAggregateOutputType> | number
          }
        }
      }
      EmployeePosition: {
        payload: Prisma.$EmployeePositionPayload<ExtArgs>
        fields: Prisma.EmployeePositionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeePositionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeePositionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>
          }
          findFirst: {
            args: Prisma.EmployeePositionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeePositionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>
          }
          findMany: {
            args: Prisma.EmployeePositionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>[]
          }
          create: {
            args: Prisma.EmployeePositionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>
          }
          createMany: {
            args: Prisma.EmployeePositionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeePositionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>[]
          }
          delete: {
            args: Prisma.EmployeePositionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>
          }
          update: {
            args: Prisma.EmployeePositionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>
          }
          deleteMany: {
            args: Prisma.EmployeePositionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeePositionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeePositionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>[]
          }
          upsert: {
            args: Prisma.EmployeePositionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePositionPayload>
          }
          aggregate: {
            args: Prisma.EmployeePositionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeePosition>
          }
          groupBy: {
            args: Prisma.EmployeePositionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeePositionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeePositionCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeePositionCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    customer?: CustomerOmit
    token?: TokenOmit
    kitchen?: KitchenOmit
    kitchenLog?: KitchenLogOmit
    dishOrder?: DishOrderOmit
    order?: OrderOmit
    discountProduct?: DiscountProductOmit
    discount?: DiscountOmit
    taxDetail?: TaxDetailOmit
    paymentDetail?: PaymentDetailOmit
    orderSession?: OrderSessionOmit
    shop?: ShopOmit
    image?: ImageOmit
    dishCategory?: DishCategoryOmit
    dish?: DishOmit
    unit?: UnitOmit
    tablePosition?: TablePositionOmit
    table?: TableOmit
    employeeDepartment?: EmployeeDepartmentOmit
    employeePosition?: EmployeePositionOmit
    employee?: EmployeeOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    employee: number
    shop: number
    token: number
    kitchenLog: number
    approveOrder: number
    cancelledOrder: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserCountOutputTypeCountEmployeeArgs
    shop?: boolean | UserCountOutputTypeCountShopArgs
    token?: boolean | UserCountOutputTypeCountTokenArgs
    kitchenLog?: boolean | UserCountOutputTypeCountKitchenLogArgs
    approveOrder?: boolean | UserCountOutputTypeCountApproveOrderArgs
    cancelledOrder?: boolean | UserCountOutputTypeCountCancelledOrderArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountKitchenLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApproveOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCancelledOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    tokens: number
    Order: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | CustomerCountOutputTypeCountTokensArgs
    Order?: boolean | CustomerCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type KitchenCountOutputType
   */

  export type KitchenCountOutputType = {
    dishCategories: number
    tables: number
  }

  export type KitchenCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishCategories?: boolean | KitchenCountOutputTypeCountDishCategoriesArgs
    tables?: boolean | KitchenCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenCountOutputType
     */
    select?: KitchenCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountDishCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishCategoryWhereInput
  }

  /**
   * KitchenCountOutputType without action
   */
  export type KitchenCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }


  /**
   * Count Type OrderCountOutputType
   */

  export type OrderCountOutputType = {
    dishOrders: number
    returnedDishOrders: number
    KitchenLog: number
  }

  export type OrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishOrders?: boolean | OrderCountOutputTypeCountDishOrdersArgs
    returnedDishOrders?: boolean | OrderCountOutputTypeCountReturnedDishOrdersArgs
    KitchenLog?: boolean | OrderCountOutputTypeCountKitchenLogArgs
  }

  // Custom InputTypes
  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderCountOutputType
     */
    select?: OrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountDishOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishOrderWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountReturnedDishOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishOrderWhereInput
  }

  /**
   * OrderCountOutputType without action
   */
  export type OrderCountOutputTypeCountKitchenLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenLogWhereInput
  }


  /**
   * Count Type DiscountCountOutputType
   */

  export type DiscountCountOutputType = {
    discountProducts: number
  }

  export type DiscountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountProducts?: boolean | DiscountCountOutputTypeCountDiscountProductsArgs
  }

  // Custom InputTypes
  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountCountOutputType
     */
    select?: DiscountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DiscountCountOutputType without action
   */
  export type DiscountCountOutputTypeCountDiscountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountProductWhereInput
  }


  /**
   * Count Type OrderSessionCountOutputType
   */

  export type OrderSessionCountOutputType = {
    orders: number
    discounts: number
    taxDetails: number
    paymentDetails: number
  }

  export type OrderSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderSessionCountOutputTypeCountOrdersArgs
    discounts?: boolean | OrderSessionCountOutputTypeCountDiscountsArgs
    taxDetails?: boolean | OrderSessionCountOutputTypeCountTaxDetailsArgs
    paymentDetails?: boolean | OrderSessionCountOutputTypeCountPaymentDetailsArgs
  }

  // Custom InputTypes
  /**
   * OrderSessionCountOutputType without action
   */
  export type OrderSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSessionCountOutputType
     */
    select?: OrderSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OrderSessionCountOutputType without action
   */
  export type OrderSessionCountOutputTypeCountOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * OrderSessionCountOutputType without action
   */
  export type OrderSessionCountOutputTypeCountDiscountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
  }

  /**
   * OrderSessionCountOutputType without action
   */
  export type OrderSessionCountOutputTypeCountTaxDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxDetailWhereInput
  }

  /**
   * OrderSessionCountOutputType without action
   */
  export type OrderSessionCountOutputTypeCountPaymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailWhereInput
  }


  /**
   * Count Type ShopCountOutputType
   */

  export type ShopCountOutputType = {
    dish: number
    dishCategory: number
    employees: number
    employeeDepartments: number
    employeePositions: number
    imageUrls: number
    table: number
    tablePosition: number
    unit: number
    Kitchen: number
    KitchenLog: number
    Order: number
    OrderSession: number
  }

  export type ShopCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | ShopCountOutputTypeCountDishArgs
    dishCategory?: boolean | ShopCountOutputTypeCountDishCategoryArgs
    employees?: boolean | ShopCountOutputTypeCountEmployeesArgs
    employeeDepartments?: boolean | ShopCountOutputTypeCountEmployeeDepartmentsArgs
    employeePositions?: boolean | ShopCountOutputTypeCountEmployeePositionsArgs
    imageUrls?: boolean | ShopCountOutputTypeCountImageUrlsArgs
    table?: boolean | ShopCountOutputTypeCountTableArgs
    tablePosition?: boolean | ShopCountOutputTypeCountTablePositionArgs
    unit?: boolean | ShopCountOutputTypeCountUnitArgs
    Kitchen?: boolean | ShopCountOutputTypeCountKitchenArgs
    KitchenLog?: boolean | ShopCountOutputTypeCountKitchenLogArgs
    Order?: boolean | ShopCountOutputTypeCountOrderArgs
    OrderSession?: boolean | ShopCountOutputTypeCountOrderSessionArgs
  }

  // Custom InputTypes
  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShopCountOutputType
     */
    select?: ShopCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountDishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountDishCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishCategoryWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountEmployeeDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeDepartmentWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountEmployeePositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePositionWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountImageUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountTableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountTablePositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TablePositionWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountUnitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountKitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountKitchenLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenLogWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }

  /**
   * ShopCountOutputType without action
   */
  export type ShopCountOutputTypeCountOrderSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderSessionWhereInput
  }


  /**
   * Count Type DishCategoryCountOutputType
   */

  export type DishCategoryCountOutputType = {
    dish: number
    tablePosition: number
    kitchen: number
  }

  export type DishCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | DishCategoryCountOutputTypeCountDishArgs
    tablePosition?: boolean | DishCategoryCountOutputTypeCountTablePositionArgs
    kitchen?: boolean | DishCategoryCountOutputTypeCountKitchenArgs
  }

  // Custom InputTypes
  /**
   * DishCategoryCountOutputType without action
   */
  export type DishCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategoryCountOutputType
     */
    select?: DishCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DishCategoryCountOutputType without action
   */
  export type DishCategoryCountOutputTypeCountDishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }

  /**
   * DishCategoryCountOutputType without action
   */
  export type DishCategoryCountOutputTypeCountTablePositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TablePositionWhereInput
  }

  /**
   * DishCategoryCountOutputType without action
   */
  export type DishCategoryCountOutputTypeCountKitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenWhereInput
  }


  /**
   * Count Type DishCountOutputType
   */

  export type DishCountOutputType = {
    imageUrls: number
  }

  export type DishCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    imageUrls?: boolean | DishCountOutputTypeCountImageUrlsArgs
  }

  // Custom InputTypes
  /**
   * DishCountOutputType without action
   */
  export type DishCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCountOutputType
     */
    select?: DishCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DishCountOutputType without action
   */
  export type DishCountOutputTypeCountImageUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
  }


  /**
   * Count Type UnitCountOutputType
   */

  export type UnitCountOutputType = {
    dish: number
  }

  export type UnitCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | UnitCountOutputTypeCountDishArgs
  }

  // Custom InputTypes
  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     */
    select?: UnitCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeCountDishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
  }


  /**
   * Count Type TablePositionCountOutputType
   */

  export type TablePositionCountOutputType = {
    dishCategories: number
    tables: number
  }

  export type TablePositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishCategories?: boolean | TablePositionCountOutputTypeCountDishCategoriesArgs
    tables?: boolean | TablePositionCountOutputTypeCountTablesArgs
  }

  // Custom InputTypes
  /**
   * TablePositionCountOutputType without action
   */
  export type TablePositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePositionCountOutputType
     */
    select?: TablePositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TablePositionCountOutputType without action
   */
  export type TablePositionCountOutputTypeCountDishCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishCategoryWhereInput
  }

  /**
   * TablePositionCountOutputType without action
   */
  export type TablePositionCountOutputTypeCountTablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
  }


  /**
   * Count Type TableCountOutputType
   */

  export type TableCountOutputType = {
    position: number
    Order: number
  }

  export type TableCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    position?: boolean | TableCountOutputTypeCountPositionArgs
    Order?: boolean | TableCountOutputTypeCountOrderArgs
  }

  // Custom InputTypes
  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TableCountOutputType
     */
    select?: TableCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountPositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TablePositionWhereInput
  }

  /**
   * TableCountOutputType without action
   */
  export type TableCountOutputTypeCountOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
  }


  /**
   * Count Type EmployeeDepartmentCountOutputType
   */

  export type EmployeeDepartmentCountOutputType = {
    employees: number
  }

  export type EmployeeDepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDepartmentCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * EmployeeDepartmentCountOutputType without action
   */
  export type EmployeeDepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartmentCountOutputType
     */
    select?: EmployeeDepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeDepartmentCountOutputType without action
   */
  export type EmployeeDepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type EmployeePositionCountOutputType
   */

  export type EmployeePositionCountOutputType = {
    employees: number
  }

  export type EmployeePositionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeePositionCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * EmployeePositionCountOutputType without action
   */
  export type EmployeePositionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePositionCountOutputType
     */
    select?: EmployeePositionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeePositionCountOutputType without action
   */
  export type EmployeePositionCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: $Enums.Role | null
    isEmailVerified: boolean | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UserMaxAggregateOutputType = {
    name: string | null
    email: string | null
    phone: string | null
    password: string | null
    role: $Enums.Role | null
    isEmailVerified: boolean | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UserCountAggregateOutputType = {
    name: number
    email: number
    phone: number
    password: number
    role: number
    isEmailVerified: number
    status: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    isEmailVerified?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UserMaxAggregateInputType = {
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    isEmailVerified?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UserCountAggregateInputType = {
    name?: true
    email?: true
    phone?: true
    password?: true
    role?: true
    isEmailVerified?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    name: string
    email: string
    phone: string | null
    password: string
    role: $Enums.Role
    isEmailVerified: boolean
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    id: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    employee?: boolean | User$employeeArgs<ExtArgs>
    shop?: boolean | User$shopArgs<ExtArgs>
    token?: boolean | User$tokenArgs<ExtArgs>
    kitchenLog?: boolean | User$kitchenLogArgs<ExtArgs>
    approveOrder?: boolean | User$approveOrderArgs<ExtArgs>
    cancelledOrder?: boolean | User$cancelledOrderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    name?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    isEmailVerified?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"name" | "email" | "phone" | "password" | "role" | "isEmailVerified" | "status" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | User$employeeArgs<ExtArgs>
    shop?: boolean | User$shopArgs<ExtArgs>
    token?: boolean | User$tokenArgs<ExtArgs>
    kitchenLog?: boolean | User$kitchenLogArgs<ExtArgs>
    approveOrder?: boolean | User$approveOrderArgs<ExtArgs>
    cancelledOrder?: boolean | User$cancelledOrderArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>[]
      token: Prisma.$TokenPayload<ExtArgs>[]
      kitchenLog: Prisma.$KitchenLogPayload<ExtArgs>[]
      approveOrder: Prisma.$OrderPayload<ExtArgs>[]
      cancelledOrder: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      name: string
      email: string
      phone: string | null
      password: string
      role: $Enums.Role
      isEmailVerified: boolean
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const userWithNameOnly = await prisma.user.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `name`
     * const userWithNameOnly = await prisma.user.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `name`
     * const userWithNameOnly = await prisma.user.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends User$employeeArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends User$shopArgs<ExtArgs> = {}>(args?: Subset<T, User$shopArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    token<T extends User$tokenArgs<ExtArgs> = {}>(args?: Subset<T, User$tokenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kitchenLog<T extends User$kitchenLogArgs<ExtArgs> = {}>(args?: Subset<T, User$kitchenLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    approveOrder<T extends User$approveOrderArgs<ExtArgs> = {}>(args?: Subset<T, User$approveOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cancelledOrder<T extends User$cancelledOrderArgs<ExtArgs> = {}>(args?: Subset<T, User$cancelledOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly status: FieldRef<"User", 'Status'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly id: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.employee
   */
  export type User$employeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * User.shop
   */
  export type User$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    cursor?: ShopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * User.token
   */
  export type User$tokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * User.kitchenLog
   */
  export type User$kitchenLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    where?: KitchenLogWhereInput
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    cursor?: KitchenLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenLogScalarFieldEnum | KitchenLogScalarFieldEnum[]
  }

  /**
   * User.approveOrder
   */
  export type User$approveOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User.cancelledOrder
   */
  export type User$cancelledOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    totalOrderTimes: number | null
    totalOrderValue: number | null
  }

  export type CustomerSumAggregateOutputType = {
    totalOrderTimes: number | null
    totalOrderValue: number | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    password: string | null
    address: string | null
    anonymous: boolean | null
    totalOrderTimes: number | null
    totalOrderValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phone: string | null
    email: string | null
    password: string | null
    address: string | null
    anonymous: boolean | null
    totalOrderTimes: number | null
    totalOrderValue: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    password: number
    address: number
    anonymous: number
    totalOrderTimes: number
    totalOrderValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    totalOrderTimes?: true
    totalOrderValue?: true
  }

  export type CustomerSumAggregateInputType = {
    totalOrderTimes?: true
    totalOrderValue?: true
  }

  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    password?: true
    address?: true
    anonymous?: true
    totalOrderTimes?: true
    totalOrderValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    password?: true
    address?: true
    anonymous?: true
    totalOrderTimes?: true
    totalOrderValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    password?: true
    address?: true
    anonymous?: true
    totalOrderTimes?: true
    totalOrderValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customer to aggregate.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type CustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CustomerWhereInput
    orderBy?: CustomerOrderByWithAggregationInput | CustomerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: CustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string | null
    phone: string | null
    email: string | null
    password: string | null
    address: string | null
    anonymous: boolean | null
    totalOrderTimes: number | null
    totalOrderValue: number | null
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends CustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type CustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    anonymous?: boolean
    totalOrderTimes?: boolean
    totalOrderValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tokens?: boolean | Customer$tokensArgs<ExtArgs>
    Order?: boolean | Customer$OrderArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    anonymous?: boolean
    totalOrderTimes?: boolean
    totalOrderValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    anonymous?: boolean
    totalOrderTimes?: boolean
    totalOrderValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["customer"]>

  export type CustomerSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    password?: boolean
    address?: boolean
    anonymous?: boolean
    totalOrderTimes?: boolean
    totalOrderValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "password" | "address" | "anonymous" | "totalOrderTimes" | "totalOrderValue" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type CustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tokens?: boolean | Customer$tokensArgs<ExtArgs>
    Order?: boolean | Customer$OrderArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Customer"
    objects: {
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      Order: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      phone: string | null
      email: string | null
      password: string | null
      address: string | null
      anonymous: boolean | null
      totalOrderTimes: number | null
      totalOrderValue: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type CustomerGetPayload<S extends boolean | null | undefined | CustomerDefaultArgs> = $Result.GetResult<Prisma.$CustomerPayload, S>

  type CustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface CustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Customer'], meta: { name: 'Customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {CustomerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CustomerFindUniqueArgs>(args: SelectSubset<T, CustomerFindUniqueArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CustomerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, CustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CustomerFindFirstArgs>(args?: SelectSubset<T, CustomerFindFirstArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, CustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CustomerFindManyArgs>(args?: SelectSubset<T, CustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {CustomerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends CustomerCreateArgs>(args: SelectSubset<T, CustomerCreateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {CustomerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CustomerCreateManyArgs>(args?: SelectSubset<T, CustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Customers and returns the data saved in the database.
     * @param {CustomerCreateManyAndReturnArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, CustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Customer.
     * @param {CustomerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends CustomerDeleteArgs>(args: SelectSubset<T, CustomerDeleteArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {CustomerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CustomerUpdateArgs>(args: SelectSubset<T, CustomerUpdateArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {CustomerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CustomerDeleteManyArgs>(args?: SelectSubset<T, CustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CustomerUpdateManyArgs>(args: SelectSubset<T, CustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers and returns the data updated in the database.
     * @param {CustomerUpdateManyAndReturnArgs} args - Arguments to update many Customers.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Customers and only return the `id`
     * const customerWithIdOnly = await prisma.customer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, CustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Customer.
     * @param {CustomerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends CustomerUpsertArgs>(args: SelectSubset<T, CustomerUpsertArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends CustomerCountArgs>(
      args?: Subset<T, CustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CustomerGroupByArgs['orderBy'] }
        : { orderBy?: CustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Customer model
   */
  readonly fields: CustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tokens<T extends Customer$tokensArgs<ExtArgs> = {}>(args?: Subset<T, Customer$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Order<T extends Customer$OrderArgs<ExtArgs> = {}>(args?: Subset<T, Customer$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Customer model
   */
  interface CustomerFieldRefs {
    readonly id: FieldRef<"Customer", 'String'>
    readonly name: FieldRef<"Customer", 'String'>
    readonly phone: FieldRef<"Customer", 'String'>
    readonly email: FieldRef<"Customer", 'String'>
    readonly password: FieldRef<"Customer", 'String'>
    readonly address: FieldRef<"Customer", 'String'>
    readonly anonymous: FieldRef<"Customer", 'Boolean'>
    readonly totalOrderTimes: FieldRef<"Customer", 'Int'>
    readonly totalOrderValue: FieldRef<"Customer", 'Float'>
    readonly createdAt: FieldRef<"Customer", 'DateTime'>
    readonly updatedAt: FieldRef<"Customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Customer findUnique
   */
  export type CustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findUniqueOrThrow
   */
  export type CustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer findFirst
   */
  export type CustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findFirstOrThrow
   */
  export type CustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customer to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer findMany
   */
  export type CustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter, which Customers to fetch.
     */
    where?: CustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Customers to fetch.
     */
    orderBy?: CustomerOrderByWithRelationInput | CustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Customers.
     */
    cursor?: CustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * Customer create
   */
  export type CustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a Customer.
     */
    data: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
  }

  /**
   * Customer createMany
   */
  export type CustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer createManyAndReturn
   */
  export type CustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to create many Customers.
     */
    data: CustomerCreateManyInput | CustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Customer update
   */
  export type CustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a Customer.
     */
    data: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
    /**
     * Choose, which Customer to update.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer updateMany
   */
  export type CustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer updateManyAndReturn
   */
  export type CustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * The data used to update Customers.
     */
    data: XOR<CustomerUpdateManyMutationInput, CustomerUncheckedUpdateManyInput>
    /**
     * Filter which Customers to update
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to update.
     */
    limit?: number
  }

  /**
   * Customer upsert
   */
  export type CustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the Customer to update in case it exists.
     */
    where: CustomerWhereUniqueInput
    /**
     * In case the Customer found by the `where` argument doesn't exist, create a new Customer with this data.
     */
    create: XOR<CustomerCreateInput, CustomerUncheckedCreateInput>
    /**
     * In case the Customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CustomerUpdateInput, CustomerUncheckedUpdateInput>
  }

  /**
   * Customer delete
   */
  export type CustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    /**
     * Filter which Customer to delete.
     */
    where: CustomerWhereUniqueInput
  }

  /**
   * Customer deleteMany
   */
  export type CustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Customers to delete
     */
    where?: CustomerWhereInput
    /**
     * Limit how many Customers to delete.
     */
    limit?: number
  }

  /**
   * Customer.tokens
   */
  export type Customer$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Customer.Order
   */
  export type Customer$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Customer without action
   */
  export type CustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    expires: Date | null
    blacklisted: boolean | null
    isCustomer: boolean | null
    userId: string | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    type: $Enums.TokenType | null
    expires: Date | null
    blacklisted: boolean | null
    isCustomer: boolean | null
    userId: string | null
    customerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    token: number
    type: number
    expires: number
    blacklisted: number
    isCustomer: number
    userId: number
    customerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TokenMinAggregateInputType = {
    id?: true
    token?: true
    type?: true
    expires?: true
    blacklisted?: true
    isCustomer?: true
    userId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    token?: true
    type?: true
    expires?: true
    blacklisted?: true
    isCustomer?: true
    userId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    token?: true
    type?: true
    expires?: true
    blacklisted?: true
    isCustomer?: true
    userId?: true
    customerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: string
    token: string
    type: $Enums.TokenType
    expires: Date
    blacklisted: boolean
    isCustomer: boolean
    userId: string | null
    customerId: string | null
    createdAt: Date
    updatedAt: Date
    _count: TokenCountAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Token$userArgs<ExtArgs>
    customer?: boolean | Token$customerArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Token$userArgs<ExtArgs>
    customer?: boolean | Token$customerArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | Token$userArgs<ExtArgs>
    customer?: boolean | Token$customerArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>

  export type TokenSelectScalar = {
    id?: boolean
    token?: boolean
    type?: boolean
    expires?: boolean
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: boolean
    customerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "type" | "expires" | "blacklisted" | "isCustomer" | "userId" | "customerId" | "createdAt" | "updatedAt", ExtArgs["result"]["token"]>
  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Token$userArgs<ExtArgs>
    customer?: boolean | Token$customerArgs<ExtArgs>
  }
  export type TokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Token$userArgs<ExtArgs>
    customer?: boolean | Token$customerArgs<ExtArgs>
  }
  export type TokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | Token$userArgs<ExtArgs>
    customer?: boolean | Token$customerArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      customer: Prisma.$CustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      type: $Enums.TokenType
      expires: Date
      blacklisted: boolean
      isCustomer: boolean
      userId: string | null
      customerId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tokens and returns the data saved in the database.
     * @param {TokenCreateManyAndReturnArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens and returns the data updated in the database.
     * @param {TokenUpdateManyAndReturnArgs} args - Arguments to update many Tokens.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tokens and only return the `id`
     * const tokenWithIdOnly = await prisma.token.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TokenUpdateManyAndReturnArgs>(args: SelectSubset<T, TokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends Token$userArgs<ExtArgs> = {}>(args?: Subset<T, Token$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends Token$customerArgs<ExtArgs> = {}>(args?: Subset<T, Token$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'String'>
    readonly token: FieldRef<"Token", 'String'>
    readonly type: FieldRef<"Token", 'TokenType'>
    readonly expires: FieldRef<"Token", 'DateTime'>
    readonly blacklisted: FieldRef<"Token", 'Boolean'>
    readonly isCustomer: FieldRef<"Token", 'Boolean'>
    readonly userId: FieldRef<"Token", 'String'>
    readonly customerId: FieldRef<"Token", 'String'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly updatedAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token createManyAndReturn
   */
  export type TokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
  }

  /**
   * Token updateManyAndReturn
   */
  export type TokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
    /**
     * Limit how many Tokens to delete.
     */
    limit?: number
  }

  /**
   * Token.user
   */
  export type Token$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Token.customer
   */
  export type Token$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Token
     */
    omit?: TokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model Kitchen
   */

  export type AggregateKitchen = {
    _count: KitchenCountAggregateOutputType | null
    _min: KitchenMinAggregateOutputType | null
    _max: KitchenMaxAggregateOutputType | null
  }

  export type KitchenMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    name: string | null
    status: $Enums.Switchabletatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KitchenMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    name: string | null
    status: $Enums.Switchabletatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KitchenCountAggregateOutputType = {
    id: number
    shopId: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KitchenMinAggregateInputType = {
    id?: true
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KitchenMaxAggregateInputType = {
    id?: true
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KitchenCountAggregateInputType = {
    id?: true
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KitchenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kitchen to aggregate.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Kitchens
    **/
    _count?: true | KitchenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitchenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitchenMaxAggregateInputType
  }

  export type GetKitchenAggregateType<T extends KitchenAggregateArgs> = {
        [P in keyof T & keyof AggregateKitchen]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitchen[P]>
      : GetScalarType<T[P], AggregateKitchen[P]>
  }




  export type KitchenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenWhereInput
    orderBy?: KitchenOrderByWithAggregationInput | KitchenOrderByWithAggregationInput[]
    by: KitchenScalarFieldEnum[] | KitchenScalarFieldEnum
    having?: KitchenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitchenCountAggregateInputType | true
    _min?: KitchenMinAggregateInputType
    _max?: KitchenMaxAggregateInputType
  }

  export type KitchenGroupByOutputType = {
    id: string
    shopId: string
    name: string
    status: $Enums.Switchabletatus
    createdAt: Date
    updatedAt: Date
    _count: KitchenCountAggregateOutputType | null
    _min: KitchenMinAggregateOutputType | null
    _max: KitchenMaxAggregateOutputType | null
  }

  type GetKitchenGroupByPayload<T extends KitchenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitchenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitchenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitchenGroupByOutputType[P]>
            : GetScalarType<T[P], KitchenGroupByOutputType[P]>
        }
      >
    >


  export type KitchenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dishCategories?: boolean | Kitchen$dishCategoriesArgs<ExtArgs>
    tables?: boolean | Kitchen$tablesArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | KitchenCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchen"]>

  export type KitchenSelectScalar = {
    id?: boolean
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KitchenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopId" | "name" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["kitchen"]>
  export type KitchenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishCategories?: boolean | Kitchen$dishCategoriesArgs<ExtArgs>
    tables?: boolean | Kitchen$tablesArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | KitchenCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type KitchenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type KitchenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $KitchenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Kitchen"
    objects: {
      dishCategories: Prisma.$DishCategoryPayload<ExtArgs>[]
      tables: Prisma.$TablePayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      name: string
      status: $Enums.Switchabletatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kitchen"]>
    composites: {}
  }

  type KitchenGetPayload<S extends boolean | null | undefined | KitchenDefaultArgs> = $Result.GetResult<Prisma.$KitchenPayload, S>

  type KitchenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KitchenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KitchenCountAggregateInputType | true
    }

  export interface KitchenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Kitchen'], meta: { name: 'Kitchen' } }
    /**
     * Find zero or one Kitchen that matches the filter.
     * @param {KitchenFindUniqueArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitchenFindUniqueArgs>(args: SelectSubset<T, KitchenFindUniqueArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Kitchen that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KitchenFindUniqueOrThrowArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitchenFindUniqueOrThrowArgs>(args: SelectSubset<T, KitchenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kitchen that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitchenFindFirstArgs>(args?: SelectSubset<T, KitchenFindFirstArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Kitchen that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindFirstOrThrowArgs} args - Arguments to find a Kitchen
     * @example
     * // Get one Kitchen
     * const kitchen = await prisma.kitchen.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitchenFindFirstOrThrowArgs>(args?: SelectSubset<T, KitchenFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Kitchens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Kitchens
     * const kitchens = await prisma.kitchen.findMany()
     * 
     * // Get first 10 Kitchens
     * const kitchens = await prisma.kitchen.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KitchenFindManyArgs>(args?: SelectSubset<T, KitchenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Kitchen.
     * @param {KitchenCreateArgs} args - Arguments to create a Kitchen.
     * @example
     * // Create one Kitchen
     * const Kitchen = await prisma.kitchen.create({
     *   data: {
     *     // ... data to create a Kitchen
     *   }
     * })
     * 
     */
    create<T extends KitchenCreateArgs>(args: SelectSubset<T, KitchenCreateArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Kitchens.
     * @param {KitchenCreateManyArgs} args - Arguments to create many Kitchens.
     * @example
     * // Create many Kitchens
     * const kitchen = await prisma.kitchen.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitchenCreateManyArgs>(args?: SelectSubset<T, KitchenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Kitchens and returns the data saved in the database.
     * @param {KitchenCreateManyAndReturnArgs} args - Arguments to create many Kitchens.
     * @example
     * // Create many Kitchens
     * const kitchen = await prisma.kitchen.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Kitchens and only return the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitchenCreateManyAndReturnArgs>(args?: SelectSubset<T, KitchenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Kitchen.
     * @param {KitchenDeleteArgs} args - Arguments to delete one Kitchen.
     * @example
     * // Delete one Kitchen
     * const Kitchen = await prisma.kitchen.delete({
     *   where: {
     *     // ... filter to delete one Kitchen
     *   }
     * })
     * 
     */
    delete<T extends KitchenDeleteArgs>(args: SelectSubset<T, KitchenDeleteArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Kitchen.
     * @param {KitchenUpdateArgs} args - Arguments to update one Kitchen.
     * @example
     * // Update one Kitchen
     * const kitchen = await prisma.kitchen.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitchenUpdateArgs>(args: SelectSubset<T, KitchenUpdateArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Kitchens.
     * @param {KitchenDeleteManyArgs} args - Arguments to filter Kitchens to delete.
     * @example
     * // Delete a few Kitchens
     * const { count } = await prisma.kitchen.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitchenDeleteManyArgs>(args?: SelectSubset<T, KitchenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Kitchens
     * const kitchen = await prisma.kitchen.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitchenUpdateManyArgs>(args: SelectSubset<T, KitchenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Kitchens and returns the data updated in the database.
     * @param {KitchenUpdateManyAndReturnArgs} args - Arguments to update many Kitchens.
     * @example
     * // Update many Kitchens
     * const kitchen = await prisma.kitchen.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Kitchens and only return the `id`
     * const kitchenWithIdOnly = await prisma.kitchen.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KitchenUpdateManyAndReturnArgs>(args: SelectSubset<T, KitchenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Kitchen.
     * @param {KitchenUpsertArgs} args - Arguments to update or create a Kitchen.
     * @example
     * // Update or create a Kitchen
     * const kitchen = await prisma.kitchen.upsert({
     *   create: {
     *     // ... data to create a Kitchen
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Kitchen we want to update
     *   }
     * })
     */
    upsert<T extends KitchenUpsertArgs>(args: SelectSubset<T, KitchenUpsertArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Kitchens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenCountArgs} args - Arguments to filter Kitchens to count.
     * @example
     * // Count the number of Kitchens
     * const count = await prisma.kitchen.count({
     *   where: {
     *     // ... the filter for the Kitchens we want to count
     *   }
     * })
    **/
    count<T extends KitchenCountArgs>(
      args?: Subset<T, KitchenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitchenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitchenAggregateArgs>(args: Subset<T, KitchenAggregateArgs>): Prisma.PrismaPromise<GetKitchenAggregateType<T>>

    /**
     * Group by Kitchen.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitchenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitchenGroupByArgs['orderBy'] }
        : { orderBy?: KitchenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitchenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitchenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Kitchen model
   */
  readonly fields: KitchenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Kitchen.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitchenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dishCategories<T extends Kitchen$dishCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$dishCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tables<T extends Kitchen$tablesArgs<ExtArgs> = {}>(args?: Subset<T, Kitchen$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Kitchen model
   */
  interface KitchenFieldRefs {
    readonly id: FieldRef<"Kitchen", 'String'>
    readonly shopId: FieldRef<"Kitchen", 'String'>
    readonly name: FieldRef<"Kitchen", 'String'>
    readonly status: FieldRef<"Kitchen", 'Switchabletatus'>
    readonly createdAt: FieldRef<"Kitchen", 'DateTime'>
    readonly updatedAt: FieldRef<"Kitchen", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Kitchen findUnique
   */
  export type KitchenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen findUniqueOrThrow
   */
  export type KitchenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen findFirst
   */
  export type KitchenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
     */
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen findFirstOrThrow
   */
  export type KitchenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchen to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Kitchens.
     */
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen findMany
   */
  export type KitchenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter, which Kitchens to fetch.
     */
    where?: KitchenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Kitchens to fetch.
     */
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Kitchens.
     */
    cursor?: KitchenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Kitchens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Kitchens.
     */
    skip?: number
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Kitchen create
   */
  export type KitchenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * The data needed to create a Kitchen.
     */
    data: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
  }

  /**
   * Kitchen createMany
   */
  export type KitchenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Kitchens.
     */
    data: KitchenCreateManyInput | KitchenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Kitchen createManyAndReturn
   */
  export type KitchenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * The data used to create many Kitchens.
     */
    data: KitchenCreateManyInput | KitchenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kitchen update
   */
  export type KitchenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * The data needed to update a Kitchen.
     */
    data: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
    /**
     * Choose, which Kitchen to update.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen updateMany
   */
  export type KitchenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Kitchens.
     */
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyInput>
    /**
     * Filter which Kitchens to update
     */
    where?: KitchenWhereInput
    /**
     * Limit how many Kitchens to update.
     */
    limit?: number
  }

  /**
   * Kitchen updateManyAndReturn
   */
  export type KitchenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * The data used to update Kitchens.
     */
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyInput>
    /**
     * Filter which Kitchens to update
     */
    where?: KitchenWhereInput
    /**
     * Limit how many Kitchens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Kitchen upsert
   */
  export type KitchenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * The filter to search for the Kitchen to update in case it exists.
     */
    where: KitchenWhereUniqueInput
    /**
     * In case the Kitchen found by the `where` argument doesn't exist, create a new Kitchen with this data.
     */
    create: XOR<KitchenCreateInput, KitchenUncheckedCreateInput>
    /**
     * In case the Kitchen was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitchenUpdateInput, KitchenUncheckedUpdateInput>
  }

  /**
   * Kitchen delete
   */
  export type KitchenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    /**
     * Filter which Kitchen to delete.
     */
    where: KitchenWhereUniqueInput
  }

  /**
   * Kitchen deleteMany
   */
  export type KitchenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Kitchens to delete
     */
    where?: KitchenWhereInput
    /**
     * Limit how many Kitchens to delete.
     */
    limit?: number
  }

  /**
   * Kitchen.dishCategories
   */
  export type Kitchen$dishCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    where?: DishCategoryWhereInput
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    cursor?: DishCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishCategoryScalarFieldEnum | DishCategoryScalarFieldEnum[]
  }

  /**
   * Kitchen.tables
   */
  export type Kitchen$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Kitchen without action
   */
  export type KitchenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
  }


  /**
   * Model KitchenLog
   */

  export type AggregateKitchenLog = {
    _count: KitchenLogCountAggregateOutputType | null
    _avg: KitchenLogAvgAggregateOutputType | null
    _sum: KitchenLogSumAggregateOutputType | null
    _min: KitchenLogMinAggregateOutputType | null
    _max: KitchenLogMaxAggregateOutputType | null
  }

  export type KitchenLogAvgAggregateOutputType = {
    dishQuantity: number | null
  }

  export type KitchenLogSumAggregateOutputType = {
    dishQuantity: number | null
  }

  export type KitchenLogMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    userId: string | null
    orderId: string | null
    dishOrderId: string | null
    dishName: string | null
    dishQuantity: number | null
    status: $Enums.Status | null
    action: $Enums.KitchenActionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KitchenLogMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    userId: string | null
    orderId: string | null
    dishOrderId: string | null
    dishName: string | null
    dishQuantity: number | null
    status: $Enums.Status | null
    action: $Enums.KitchenActionEnum | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KitchenLogCountAggregateOutputType = {
    id: number
    shopId: number
    userId: number
    orderId: number
    dishOrderId: number
    dishName: number
    dishQuantity: number
    status: number
    action: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KitchenLogAvgAggregateInputType = {
    dishQuantity?: true
  }

  export type KitchenLogSumAggregateInputType = {
    dishQuantity?: true
  }

  export type KitchenLogMinAggregateInputType = {
    id?: true
    shopId?: true
    userId?: true
    orderId?: true
    dishOrderId?: true
    dishName?: true
    dishQuantity?: true
    status?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KitchenLogMaxAggregateInputType = {
    id?: true
    shopId?: true
    userId?: true
    orderId?: true
    dishOrderId?: true
    dishName?: true
    dishQuantity?: true
    status?: true
    action?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KitchenLogCountAggregateInputType = {
    id?: true
    shopId?: true
    userId?: true
    orderId?: true
    dishOrderId?: true
    dishName?: true
    dishQuantity?: true
    status?: true
    action?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KitchenLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KitchenLog to aggregate.
     */
    where?: KitchenLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenLogs to fetch.
     */
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KitchenLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KitchenLogs
    **/
    _count?: true | KitchenLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KitchenLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KitchenLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KitchenLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KitchenLogMaxAggregateInputType
  }

  export type GetKitchenLogAggregateType<T extends KitchenLogAggregateArgs> = {
        [P in keyof T & keyof AggregateKitchenLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKitchenLog[P]>
      : GetScalarType<T[P], AggregateKitchenLog[P]>
  }




  export type KitchenLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KitchenLogWhereInput
    orderBy?: KitchenLogOrderByWithAggregationInput | KitchenLogOrderByWithAggregationInput[]
    by: KitchenLogScalarFieldEnum[] | KitchenLogScalarFieldEnum
    having?: KitchenLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KitchenLogCountAggregateInputType | true
    _avg?: KitchenLogAvgAggregateInputType
    _sum?: KitchenLogSumAggregateInputType
    _min?: KitchenLogMinAggregateInputType
    _max?: KitchenLogMaxAggregateInputType
  }

  export type KitchenLogGroupByOutputType = {
    id: string
    shopId: string
    userId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt: Date
    updatedAt: Date
    _count: KitchenLogCountAggregateOutputType | null
    _avg: KitchenLogAvgAggregateOutputType | null
    _sum: KitchenLogSumAggregateOutputType | null
    _min: KitchenLogMinAggregateOutputType | null
    _max: KitchenLogMaxAggregateOutputType | null
  }

  type GetKitchenLogGroupByPayload<T extends KitchenLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KitchenLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KitchenLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KitchenLogGroupByOutputType[P]>
            : GetScalarType<T[P], KitchenLogGroupByOutputType[P]>
        }
      >
    >


  export type KitchenLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    dishOrderId?: boolean
    dishName?: boolean
    dishQuantity?: boolean
    status?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchenLog"]>

  export type KitchenLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    dishOrderId?: boolean
    dishName?: boolean
    dishQuantity?: boolean
    status?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchenLog"]>

  export type KitchenLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    dishOrderId?: boolean
    dishName?: boolean
    dishQuantity?: boolean
    status?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["kitchenLog"]>

  export type KitchenLogSelectScalar = {
    id?: boolean
    shopId?: boolean
    userId?: boolean
    orderId?: boolean
    dishOrderId?: boolean
    dishName?: boolean
    dishQuantity?: boolean
    status?: boolean
    action?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KitchenLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopId" | "userId" | "orderId" | "dishOrderId" | "dishName" | "dishQuantity" | "status" | "action" | "createdAt" | "updatedAt", ExtArgs["result"]["kitchenLog"]>
  export type KitchenLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type KitchenLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }
  export type KitchenLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    order?: boolean | OrderDefaultArgs<ExtArgs>
  }

  export type $KitchenLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KitchenLog"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      order: Prisma.$OrderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      userId: string
      orderId: string
      dishOrderId: string
      dishName: string
      dishQuantity: number
      status: $Enums.Status
      action: $Enums.KitchenActionEnum
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["kitchenLog"]>
    composites: {}
  }

  type KitchenLogGetPayload<S extends boolean | null | undefined | KitchenLogDefaultArgs> = $Result.GetResult<Prisma.$KitchenLogPayload, S>

  type KitchenLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KitchenLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KitchenLogCountAggregateInputType | true
    }

  export interface KitchenLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KitchenLog'], meta: { name: 'KitchenLog' } }
    /**
     * Find zero or one KitchenLog that matches the filter.
     * @param {KitchenLogFindUniqueArgs} args - Arguments to find a KitchenLog
     * @example
     * // Get one KitchenLog
     * const kitchenLog = await prisma.kitchenLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KitchenLogFindUniqueArgs>(args: SelectSubset<T, KitchenLogFindUniqueArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KitchenLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KitchenLogFindUniqueOrThrowArgs} args - Arguments to find a KitchenLog
     * @example
     * // Get one KitchenLog
     * const kitchenLog = await prisma.kitchenLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KitchenLogFindUniqueOrThrowArgs>(args: SelectSubset<T, KitchenLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KitchenLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogFindFirstArgs} args - Arguments to find a KitchenLog
     * @example
     * // Get one KitchenLog
     * const kitchenLog = await prisma.kitchenLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KitchenLogFindFirstArgs>(args?: SelectSubset<T, KitchenLogFindFirstArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KitchenLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogFindFirstOrThrowArgs} args - Arguments to find a KitchenLog
     * @example
     * // Get one KitchenLog
     * const kitchenLog = await prisma.kitchenLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KitchenLogFindFirstOrThrowArgs>(args?: SelectSubset<T, KitchenLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KitchenLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KitchenLogs
     * const kitchenLogs = await prisma.kitchenLog.findMany()
     * 
     * // Get first 10 KitchenLogs
     * const kitchenLogs = await prisma.kitchenLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const kitchenLogWithIdOnly = await prisma.kitchenLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KitchenLogFindManyArgs>(args?: SelectSubset<T, KitchenLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KitchenLog.
     * @param {KitchenLogCreateArgs} args - Arguments to create a KitchenLog.
     * @example
     * // Create one KitchenLog
     * const KitchenLog = await prisma.kitchenLog.create({
     *   data: {
     *     // ... data to create a KitchenLog
     *   }
     * })
     * 
     */
    create<T extends KitchenLogCreateArgs>(args: SelectSubset<T, KitchenLogCreateArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KitchenLogs.
     * @param {KitchenLogCreateManyArgs} args - Arguments to create many KitchenLogs.
     * @example
     * // Create many KitchenLogs
     * const kitchenLog = await prisma.kitchenLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KitchenLogCreateManyArgs>(args?: SelectSubset<T, KitchenLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KitchenLogs and returns the data saved in the database.
     * @param {KitchenLogCreateManyAndReturnArgs} args - Arguments to create many KitchenLogs.
     * @example
     * // Create many KitchenLogs
     * const kitchenLog = await prisma.kitchenLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KitchenLogs and only return the `id`
     * const kitchenLogWithIdOnly = await prisma.kitchenLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KitchenLogCreateManyAndReturnArgs>(args?: SelectSubset<T, KitchenLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KitchenLog.
     * @param {KitchenLogDeleteArgs} args - Arguments to delete one KitchenLog.
     * @example
     * // Delete one KitchenLog
     * const KitchenLog = await prisma.kitchenLog.delete({
     *   where: {
     *     // ... filter to delete one KitchenLog
     *   }
     * })
     * 
     */
    delete<T extends KitchenLogDeleteArgs>(args: SelectSubset<T, KitchenLogDeleteArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KitchenLog.
     * @param {KitchenLogUpdateArgs} args - Arguments to update one KitchenLog.
     * @example
     * // Update one KitchenLog
     * const kitchenLog = await prisma.kitchenLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KitchenLogUpdateArgs>(args: SelectSubset<T, KitchenLogUpdateArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KitchenLogs.
     * @param {KitchenLogDeleteManyArgs} args - Arguments to filter KitchenLogs to delete.
     * @example
     * // Delete a few KitchenLogs
     * const { count } = await prisma.kitchenLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KitchenLogDeleteManyArgs>(args?: SelectSubset<T, KitchenLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KitchenLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KitchenLogs
     * const kitchenLog = await prisma.kitchenLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KitchenLogUpdateManyArgs>(args: SelectSubset<T, KitchenLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KitchenLogs and returns the data updated in the database.
     * @param {KitchenLogUpdateManyAndReturnArgs} args - Arguments to update many KitchenLogs.
     * @example
     * // Update many KitchenLogs
     * const kitchenLog = await prisma.kitchenLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KitchenLogs and only return the `id`
     * const kitchenLogWithIdOnly = await prisma.kitchenLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KitchenLogUpdateManyAndReturnArgs>(args: SelectSubset<T, KitchenLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KitchenLog.
     * @param {KitchenLogUpsertArgs} args - Arguments to update or create a KitchenLog.
     * @example
     * // Update or create a KitchenLog
     * const kitchenLog = await prisma.kitchenLog.upsert({
     *   create: {
     *     // ... data to create a KitchenLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KitchenLog we want to update
     *   }
     * })
     */
    upsert<T extends KitchenLogUpsertArgs>(args: SelectSubset<T, KitchenLogUpsertArgs<ExtArgs>>): Prisma__KitchenLogClient<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KitchenLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogCountArgs} args - Arguments to filter KitchenLogs to count.
     * @example
     * // Count the number of KitchenLogs
     * const count = await prisma.kitchenLog.count({
     *   where: {
     *     // ... the filter for the KitchenLogs we want to count
     *   }
     * })
    **/
    count<T extends KitchenLogCountArgs>(
      args?: Subset<T, KitchenLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KitchenLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KitchenLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KitchenLogAggregateArgs>(args: Subset<T, KitchenLogAggregateArgs>): Prisma.PrismaPromise<GetKitchenLogAggregateType<T>>

    /**
     * Group by KitchenLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KitchenLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KitchenLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KitchenLogGroupByArgs['orderBy'] }
        : { orderBy?: KitchenLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KitchenLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKitchenLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KitchenLog model
   */
  readonly fields: KitchenLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KitchenLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KitchenLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    order<T extends OrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderDefaultArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KitchenLog model
   */
  interface KitchenLogFieldRefs {
    readonly id: FieldRef<"KitchenLog", 'String'>
    readonly shopId: FieldRef<"KitchenLog", 'String'>
    readonly userId: FieldRef<"KitchenLog", 'String'>
    readonly orderId: FieldRef<"KitchenLog", 'String'>
    readonly dishOrderId: FieldRef<"KitchenLog", 'String'>
    readonly dishName: FieldRef<"KitchenLog", 'String'>
    readonly dishQuantity: FieldRef<"KitchenLog", 'Int'>
    readonly status: FieldRef<"KitchenLog", 'Status'>
    readonly action: FieldRef<"KitchenLog", 'KitchenActionEnum'>
    readonly createdAt: FieldRef<"KitchenLog", 'DateTime'>
    readonly updatedAt: FieldRef<"KitchenLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KitchenLog findUnique
   */
  export type KitchenLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * Filter, which KitchenLog to fetch.
     */
    where: KitchenLogWhereUniqueInput
  }

  /**
   * KitchenLog findUniqueOrThrow
   */
  export type KitchenLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * Filter, which KitchenLog to fetch.
     */
    where: KitchenLogWhereUniqueInput
  }

  /**
   * KitchenLog findFirst
   */
  export type KitchenLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * Filter, which KitchenLog to fetch.
     */
    where?: KitchenLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenLogs to fetch.
     */
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KitchenLogs.
     */
    cursor?: KitchenLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KitchenLogs.
     */
    distinct?: KitchenLogScalarFieldEnum | KitchenLogScalarFieldEnum[]
  }

  /**
   * KitchenLog findFirstOrThrow
   */
  export type KitchenLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * Filter, which KitchenLog to fetch.
     */
    where?: KitchenLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenLogs to fetch.
     */
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KitchenLogs.
     */
    cursor?: KitchenLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KitchenLogs.
     */
    distinct?: KitchenLogScalarFieldEnum | KitchenLogScalarFieldEnum[]
  }

  /**
   * KitchenLog findMany
   */
  export type KitchenLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * Filter, which KitchenLogs to fetch.
     */
    where?: KitchenLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KitchenLogs to fetch.
     */
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KitchenLogs.
     */
    cursor?: KitchenLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KitchenLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KitchenLogs.
     */
    skip?: number
    distinct?: KitchenLogScalarFieldEnum | KitchenLogScalarFieldEnum[]
  }

  /**
   * KitchenLog create
   */
  export type KitchenLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * The data needed to create a KitchenLog.
     */
    data: XOR<KitchenLogCreateInput, KitchenLogUncheckedCreateInput>
  }

  /**
   * KitchenLog createMany
   */
  export type KitchenLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KitchenLogs.
     */
    data: KitchenLogCreateManyInput | KitchenLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * KitchenLog createManyAndReturn
   */
  export type KitchenLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * The data used to create many KitchenLogs.
     */
    data: KitchenLogCreateManyInput | KitchenLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * KitchenLog update
   */
  export type KitchenLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * The data needed to update a KitchenLog.
     */
    data: XOR<KitchenLogUpdateInput, KitchenLogUncheckedUpdateInput>
    /**
     * Choose, which KitchenLog to update.
     */
    where: KitchenLogWhereUniqueInput
  }

  /**
   * KitchenLog updateMany
   */
  export type KitchenLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KitchenLogs.
     */
    data: XOR<KitchenLogUpdateManyMutationInput, KitchenLogUncheckedUpdateManyInput>
    /**
     * Filter which KitchenLogs to update
     */
    where?: KitchenLogWhereInput
    /**
     * Limit how many KitchenLogs to update.
     */
    limit?: number
  }

  /**
   * KitchenLog updateManyAndReturn
   */
  export type KitchenLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * The data used to update KitchenLogs.
     */
    data: XOR<KitchenLogUpdateManyMutationInput, KitchenLogUncheckedUpdateManyInput>
    /**
     * Filter which KitchenLogs to update
     */
    where?: KitchenLogWhereInput
    /**
     * Limit how many KitchenLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * KitchenLog upsert
   */
  export type KitchenLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * The filter to search for the KitchenLog to update in case it exists.
     */
    where: KitchenLogWhereUniqueInput
    /**
     * In case the KitchenLog found by the `where` argument doesn't exist, create a new KitchenLog with this data.
     */
    create: XOR<KitchenLogCreateInput, KitchenLogUncheckedCreateInput>
    /**
     * In case the KitchenLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KitchenLogUpdateInput, KitchenLogUncheckedUpdateInput>
  }

  /**
   * KitchenLog delete
   */
  export type KitchenLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    /**
     * Filter which KitchenLog to delete.
     */
    where: KitchenLogWhereUniqueInput
  }

  /**
   * KitchenLog deleteMany
   */
  export type KitchenLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KitchenLogs to delete
     */
    where?: KitchenLogWhereInput
    /**
     * Limit how many KitchenLogs to delete.
     */
    limit?: number
  }

  /**
   * KitchenLog without action
   */
  export type KitchenLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
  }


  /**
   * Model DishOrder
   */

  export type AggregateDishOrder = {
    _count: DishOrderCountAggregateOutputType | null
    _avg: DishOrderAvgAggregateOutputType | null
    _sum: DishOrderSumAggregateOutputType | null
    _min: DishOrderMinAggregateOutputType | null
    _max: DishOrderMaxAggregateOutputType | null
  }

  export type DishOrderAvgAggregateOutputType = {
    dishOrderNo: number | null
    price: number | null
    taxIncludedPrice: number | null
    quantity: number | null
    beforeTaxTotalPrice: number | null
    afterTaxTotalPrice: number | null
    taxRate: number | null
    taxAmount: number | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
    paymentAmount: number | null
  }

  export type DishOrderSumAggregateOutputType = {
    dishOrderNo: number | null
    price: number | null
    taxIncludedPrice: number | null
    quantity: number | null
    beforeTaxTotalPrice: number | null
    afterTaxTotalPrice: number | null
    taxRate: number | null
    taxAmount: number | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
    paymentAmount: number | null
  }

  export type DishOrderMinAggregateOutputType = {
    id: string | null
    dishOrderNo: number | null
    dishId: string | null
    name: string | null
    unit: string | null
    price: number | null
    isTaxIncludedPrice: boolean | null
    taxIncludedPrice: number | null
    quantity: number | null
    beforeTaxTotalPrice: number | null
    afterTaxTotalPrice: number | null
    taxRate: number | null
    taxAmount: number | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
    paymentAmount: number | null
    status: $Enums.DishOrderStatus | null
    returnedAt: Date | null
    note: string | null
    orderId: string | null
    returnedOrderId: string | null
  }

  export type DishOrderMaxAggregateOutputType = {
    id: string | null
    dishOrderNo: number | null
    dishId: string | null
    name: string | null
    unit: string | null
    price: number | null
    isTaxIncludedPrice: boolean | null
    taxIncludedPrice: number | null
    quantity: number | null
    beforeTaxTotalPrice: number | null
    afterTaxTotalPrice: number | null
    taxRate: number | null
    taxAmount: number | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
    paymentAmount: number | null
    status: $Enums.DishOrderStatus | null
    returnedAt: Date | null
    note: string | null
    orderId: string | null
    returnedOrderId: string | null
  }

  export type DishOrderCountAggregateOutputType = {
    id: number
    dishOrderNo: number
    dishId: number
    name: number
    unit: number
    price: number
    isTaxIncludedPrice: number
    taxIncludedPrice: number
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status: number
    returnedAt: number
    note: number
    orderId: number
    returnedOrderId: number
    _all: number
  }


  export type DishOrderAvgAggregateInputType = {
    dishOrderNo?: true
    price?: true
    taxIncludedPrice?: true
    quantity?: true
    beforeTaxTotalPrice?: true
    afterTaxTotalPrice?: true
    taxRate?: true
    taxAmount?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    paymentAmount?: true
  }

  export type DishOrderSumAggregateInputType = {
    dishOrderNo?: true
    price?: true
    taxIncludedPrice?: true
    quantity?: true
    beforeTaxTotalPrice?: true
    afterTaxTotalPrice?: true
    taxRate?: true
    taxAmount?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    paymentAmount?: true
  }

  export type DishOrderMinAggregateInputType = {
    id?: true
    dishOrderNo?: true
    dishId?: true
    name?: true
    unit?: true
    price?: true
    isTaxIncludedPrice?: true
    taxIncludedPrice?: true
    quantity?: true
    beforeTaxTotalPrice?: true
    afterTaxTotalPrice?: true
    taxRate?: true
    taxAmount?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    paymentAmount?: true
    status?: true
    returnedAt?: true
    note?: true
    orderId?: true
    returnedOrderId?: true
  }

  export type DishOrderMaxAggregateInputType = {
    id?: true
    dishOrderNo?: true
    dishId?: true
    name?: true
    unit?: true
    price?: true
    isTaxIncludedPrice?: true
    taxIncludedPrice?: true
    quantity?: true
    beforeTaxTotalPrice?: true
    afterTaxTotalPrice?: true
    taxRate?: true
    taxAmount?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    paymentAmount?: true
    status?: true
    returnedAt?: true
    note?: true
    orderId?: true
    returnedOrderId?: true
  }

  export type DishOrderCountAggregateInputType = {
    id?: true
    dishOrderNo?: true
    dishId?: true
    name?: true
    unit?: true
    price?: true
    isTaxIncludedPrice?: true
    taxIncludedPrice?: true
    quantity?: true
    beforeTaxTotalPrice?: true
    afterTaxTotalPrice?: true
    taxRate?: true
    taxAmount?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    paymentAmount?: true
    status?: true
    returnedAt?: true
    note?: true
    orderId?: true
    returnedOrderId?: true
    _all?: true
  }

  export type DishOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DishOrder to aggregate.
     */
    where?: DishOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishOrders to fetch.
     */
    orderBy?: DishOrderOrderByWithRelationInput | DishOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DishOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DishOrders
    **/
    _count?: true | DishOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DishOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DishOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DishOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DishOrderMaxAggregateInputType
  }

  export type GetDishOrderAggregateType<T extends DishOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateDishOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDishOrder[P]>
      : GetScalarType<T[P], AggregateDishOrder[P]>
  }




  export type DishOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishOrderWhereInput
    orderBy?: DishOrderOrderByWithAggregationInput | DishOrderOrderByWithAggregationInput[]
    by: DishOrderScalarFieldEnum[] | DishOrderScalarFieldEnum
    having?: DishOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DishOrderCountAggregateInputType | true
    _avg?: DishOrderAvgAggregateInputType
    _sum?: DishOrderSumAggregateInputType
    _min?: DishOrderMinAggregateInputType
    _max?: DishOrderMaxAggregateInputType
  }

  export type DishOrderGroupByOutputType = {
    id: string
    dishOrderNo: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status: $Enums.DishOrderStatus
    returnedAt: Date | null
    note: string | null
    orderId: string | null
    returnedOrderId: string | null
    _count: DishOrderCountAggregateOutputType | null
    _avg: DishOrderAvgAggregateOutputType | null
    _sum: DishOrderSumAggregateOutputType | null
    _min: DishOrderMinAggregateOutputType | null
    _max: DishOrderMaxAggregateOutputType | null
  }

  type GetDishOrderGroupByPayload<T extends DishOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DishOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DishOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DishOrderGroupByOutputType[P]>
            : GetScalarType<T[P], DishOrderGroupByOutputType[P]>
        }
      >
    >


  export type DishOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dishOrderNo?: boolean
    dishId?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    isTaxIncludedPrice?: boolean
    taxIncludedPrice?: boolean
    quantity?: boolean
    beforeTaxTotalPrice?: boolean
    afterTaxTotalPrice?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    paymentAmount?: boolean
    status?: boolean
    returnedAt?: boolean
    note?: boolean
    orderId?: boolean
    returnedOrderId?: boolean
    order?: boolean | DishOrder$orderArgs<ExtArgs>
    returnedOrder?: boolean | DishOrder$returnedOrderArgs<ExtArgs>
  }, ExtArgs["result"]["dishOrder"]>

  export type DishOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dishOrderNo?: boolean
    dishId?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    isTaxIncludedPrice?: boolean
    taxIncludedPrice?: boolean
    quantity?: boolean
    beforeTaxTotalPrice?: boolean
    afterTaxTotalPrice?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    paymentAmount?: boolean
    status?: boolean
    returnedAt?: boolean
    note?: boolean
    orderId?: boolean
    returnedOrderId?: boolean
    order?: boolean | DishOrder$orderArgs<ExtArgs>
    returnedOrder?: boolean | DishOrder$returnedOrderArgs<ExtArgs>
  }, ExtArgs["result"]["dishOrder"]>

  export type DishOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dishOrderNo?: boolean
    dishId?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    isTaxIncludedPrice?: boolean
    taxIncludedPrice?: boolean
    quantity?: boolean
    beforeTaxTotalPrice?: boolean
    afterTaxTotalPrice?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    paymentAmount?: boolean
    status?: boolean
    returnedAt?: boolean
    note?: boolean
    orderId?: boolean
    returnedOrderId?: boolean
    order?: boolean | DishOrder$orderArgs<ExtArgs>
    returnedOrder?: boolean | DishOrder$returnedOrderArgs<ExtArgs>
  }, ExtArgs["result"]["dishOrder"]>

  export type DishOrderSelectScalar = {
    id?: boolean
    dishOrderNo?: boolean
    dishId?: boolean
    name?: boolean
    unit?: boolean
    price?: boolean
    isTaxIncludedPrice?: boolean
    taxIncludedPrice?: boolean
    quantity?: boolean
    beforeTaxTotalPrice?: boolean
    afterTaxTotalPrice?: boolean
    taxRate?: boolean
    taxAmount?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    paymentAmount?: boolean
    status?: boolean
    returnedAt?: boolean
    note?: boolean
    orderId?: boolean
    returnedOrderId?: boolean
  }

  export type DishOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dishOrderNo" | "dishId" | "name" | "unit" | "price" | "isTaxIncludedPrice" | "taxIncludedPrice" | "quantity" | "beforeTaxTotalPrice" | "afterTaxTotalPrice" | "taxRate" | "taxAmount" | "beforeTaxTotalDiscountAmount" | "afterTaxTotalDiscountAmount" | "taxTotalDiscountAmount" | "paymentAmount" | "status" | "returnedAt" | "note" | "orderId" | "returnedOrderId", ExtArgs["result"]["dishOrder"]>
  export type DishOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | DishOrder$orderArgs<ExtArgs>
    returnedOrder?: boolean | DishOrder$returnedOrderArgs<ExtArgs>
  }
  export type DishOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | DishOrder$orderArgs<ExtArgs>
    returnedOrder?: boolean | DishOrder$returnedOrderArgs<ExtArgs>
  }
  export type DishOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | DishOrder$orderArgs<ExtArgs>
    returnedOrder?: boolean | DishOrder$returnedOrderArgs<ExtArgs>
  }

  export type $DishOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DishOrder"
    objects: {
      order: Prisma.$OrderPayload<ExtArgs> | null
      returnedOrder: Prisma.$OrderPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dishOrderNo: number | null
      dishId: string
      name: string
      unit: string
      price: number
      isTaxIncludedPrice: boolean
      taxIncludedPrice: number | null
      quantity: number
      beforeTaxTotalPrice: number
      afterTaxTotalPrice: number
      taxRate: number
      taxAmount: number
      beforeTaxTotalDiscountAmount: number
      afterTaxTotalDiscountAmount: number
      taxTotalDiscountAmount: number
      paymentAmount: number
      status: $Enums.DishOrderStatus
      returnedAt: Date | null
      note: string | null
      orderId: string | null
      returnedOrderId: string | null
    }, ExtArgs["result"]["dishOrder"]>
    composites: {}
  }

  type DishOrderGetPayload<S extends boolean | null | undefined | DishOrderDefaultArgs> = $Result.GetResult<Prisma.$DishOrderPayload, S>

  type DishOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DishOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DishOrderCountAggregateInputType | true
    }

  export interface DishOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DishOrder'], meta: { name: 'DishOrder' } }
    /**
     * Find zero or one DishOrder that matches the filter.
     * @param {DishOrderFindUniqueArgs} args - Arguments to find a DishOrder
     * @example
     * // Get one DishOrder
     * const dishOrder = await prisma.dishOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DishOrderFindUniqueArgs>(args: SelectSubset<T, DishOrderFindUniqueArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DishOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DishOrderFindUniqueOrThrowArgs} args - Arguments to find a DishOrder
     * @example
     * // Get one DishOrder
     * const dishOrder = await prisma.dishOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DishOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, DishOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DishOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderFindFirstArgs} args - Arguments to find a DishOrder
     * @example
     * // Get one DishOrder
     * const dishOrder = await prisma.dishOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DishOrderFindFirstArgs>(args?: SelectSubset<T, DishOrderFindFirstArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DishOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderFindFirstOrThrowArgs} args - Arguments to find a DishOrder
     * @example
     * // Get one DishOrder
     * const dishOrder = await prisma.dishOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DishOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, DishOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DishOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DishOrders
     * const dishOrders = await prisma.dishOrder.findMany()
     * 
     * // Get first 10 DishOrders
     * const dishOrders = await prisma.dishOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dishOrderWithIdOnly = await prisma.dishOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DishOrderFindManyArgs>(args?: SelectSubset<T, DishOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DishOrder.
     * @param {DishOrderCreateArgs} args - Arguments to create a DishOrder.
     * @example
     * // Create one DishOrder
     * const DishOrder = await prisma.dishOrder.create({
     *   data: {
     *     // ... data to create a DishOrder
     *   }
     * })
     * 
     */
    create<T extends DishOrderCreateArgs>(args: SelectSubset<T, DishOrderCreateArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DishOrders.
     * @param {DishOrderCreateManyArgs} args - Arguments to create many DishOrders.
     * @example
     * // Create many DishOrders
     * const dishOrder = await prisma.dishOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DishOrderCreateManyArgs>(args?: SelectSubset<T, DishOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DishOrders and returns the data saved in the database.
     * @param {DishOrderCreateManyAndReturnArgs} args - Arguments to create many DishOrders.
     * @example
     * // Create many DishOrders
     * const dishOrder = await prisma.dishOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DishOrders and only return the `id`
     * const dishOrderWithIdOnly = await prisma.dishOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DishOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, DishOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DishOrder.
     * @param {DishOrderDeleteArgs} args - Arguments to delete one DishOrder.
     * @example
     * // Delete one DishOrder
     * const DishOrder = await prisma.dishOrder.delete({
     *   where: {
     *     // ... filter to delete one DishOrder
     *   }
     * })
     * 
     */
    delete<T extends DishOrderDeleteArgs>(args: SelectSubset<T, DishOrderDeleteArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DishOrder.
     * @param {DishOrderUpdateArgs} args - Arguments to update one DishOrder.
     * @example
     * // Update one DishOrder
     * const dishOrder = await prisma.dishOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DishOrderUpdateArgs>(args: SelectSubset<T, DishOrderUpdateArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DishOrders.
     * @param {DishOrderDeleteManyArgs} args - Arguments to filter DishOrders to delete.
     * @example
     * // Delete a few DishOrders
     * const { count } = await prisma.dishOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DishOrderDeleteManyArgs>(args?: SelectSubset<T, DishOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DishOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DishOrders
     * const dishOrder = await prisma.dishOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DishOrderUpdateManyArgs>(args: SelectSubset<T, DishOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DishOrders and returns the data updated in the database.
     * @param {DishOrderUpdateManyAndReturnArgs} args - Arguments to update many DishOrders.
     * @example
     * // Update many DishOrders
     * const dishOrder = await prisma.dishOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DishOrders and only return the `id`
     * const dishOrderWithIdOnly = await prisma.dishOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DishOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, DishOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DishOrder.
     * @param {DishOrderUpsertArgs} args - Arguments to update or create a DishOrder.
     * @example
     * // Update or create a DishOrder
     * const dishOrder = await prisma.dishOrder.upsert({
     *   create: {
     *     // ... data to create a DishOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DishOrder we want to update
     *   }
     * })
     */
    upsert<T extends DishOrderUpsertArgs>(args: SelectSubset<T, DishOrderUpsertArgs<ExtArgs>>): Prisma__DishOrderClient<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DishOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderCountArgs} args - Arguments to filter DishOrders to count.
     * @example
     * // Count the number of DishOrders
     * const count = await prisma.dishOrder.count({
     *   where: {
     *     // ... the filter for the DishOrders we want to count
     *   }
     * })
    **/
    count<T extends DishOrderCountArgs>(
      args?: Subset<T, DishOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DishOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DishOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DishOrderAggregateArgs>(args: Subset<T, DishOrderAggregateArgs>): Prisma.PrismaPromise<GetDishOrderAggregateType<T>>

    /**
     * Group by DishOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DishOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DishOrderGroupByArgs['orderBy'] }
        : { orderBy?: DishOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DishOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDishOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DishOrder model
   */
  readonly fields: DishOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DishOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DishOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends DishOrder$orderArgs<ExtArgs> = {}>(args?: Subset<T, DishOrder$orderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    returnedOrder<T extends DishOrder$returnedOrderArgs<ExtArgs> = {}>(args?: Subset<T, DishOrder$returnedOrderArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DishOrder model
   */
  interface DishOrderFieldRefs {
    readonly id: FieldRef<"DishOrder", 'String'>
    readonly dishOrderNo: FieldRef<"DishOrder", 'Int'>
    readonly dishId: FieldRef<"DishOrder", 'String'>
    readonly name: FieldRef<"DishOrder", 'String'>
    readonly unit: FieldRef<"DishOrder", 'String'>
    readonly price: FieldRef<"DishOrder", 'Float'>
    readonly isTaxIncludedPrice: FieldRef<"DishOrder", 'Boolean'>
    readonly taxIncludedPrice: FieldRef<"DishOrder", 'Float'>
    readonly quantity: FieldRef<"DishOrder", 'Int'>
    readonly beforeTaxTotalPrice: FieldRef<"DishOrder", 'Float'>
    readonly afterTaxTotalPrice: FieldRef<"DishOrder", 'Float'>
    readonly taxRate: FieldRef<"DishOrder", 'Float'>
    readonly taxAmount: FieldRef<"DishOrder", 'Float'>
    readonly beforeTaxTotalDiscountAmount: FieldRef<"DishOrder", 'Float'>
    readonly afterTaxTotalDiscountAmount: FieldRef<"DishOrder", 'Float'>
    readonly taxTotalDiscountAmount: FieldRef<"DishOrder", 'Float'>
    readonly paymentAmount: FieldRef<"DishOrder", 'Float'>
    readonly status: FieldRef<"DishOrder", 'DishOrderStatus'>
    readonly returnedAt: FieldRef<"DishOrder", 'DateTime'>
    readonly note: FieldRef<"DishOrder", 'String'>
    readonly orderId: FieldRef<"DishOrder", 'String'>
    readonly returnedOrderId: FieldRef<"DishOrder", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DishOrder findUnique
   */
  export type DishOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * Filter, which DishOrder to fetch.
     */
    where: DishOrderWhereUniqueInput
  }

  /**
   * DishOrder findUniqueOrThrow
   */
  export type DishOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * Filter, which DishOrder to fetch.
     */
    where: DishOrderWhereUniqueInput
  }

  /**
   * DishOrder findFirst
   */
  export type DishOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * Filter, which DishOrder to fetch.
     */
    where?: DishOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishOrders to fetch.
     */
    orderBy?: DishOrderOrderByWithRelationInput | DishOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DishOrders.
     */
    cursor?: DishOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DishOrders.
     */
    distinct?: DishOrderScalarFieldEnum | DishOrderScalarFieldEnum[]
  }

  /**
   * DishOrder findFirstOrThrow
   */
  export type DishOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * Filter, which DishOrder to fetch.
     */
    where?: DishOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishOrders to fetch.
     */
    orderBy?: DishOrderOrderByWithRelationInput | DishOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DishOrders.
     */
    cursor?: DishOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DishOrders.
     */
    distinct?: DishOrderScalarFieldEnum | DishOrderScalarFieldEnum[]
  }

  /**
   * DishOrder findMany
   */
  export type DishOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * Filter, which DishOrders to fetch.
     */
    where?: DishOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishOrders to fetch.
     */
    orderBy?: DishOrderOrderByWithRelationInput | DishOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DishOrders.
     */
    cursor?: DishOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishOrders.
     */
    skip?: number
    distinct?: DishOrderScalarFieldEnum | DishOrderScalarFieldEnum[]
  }

  /**
   * DishOrder create
   */
  export type DishOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a DishOrder.
     */
    data: XOR<DishOrderCreateInput, DishOrderUncheckedCreateInput>
  }

  /**
   * DishOrder createMany
   */
  export type DishOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DishOrders.
     */
    data: DishOrderCreateManyInput | DishOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DishOrder createManyAndReturn
   */
  export type DishOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * The data used to create many DishOrders.
     */
    data: DishOrderCreateManyInput | DishOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DishOrder update
   */
  export type DishOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a DishOrder.
     */
    data: XOR<DishOrderUpdateInput, DishOrderUncheckedUpdateInput>
    /**
     * Choose, which DishOrder to update.
     */
    where: DishOrderWhereUniqueInput
  }

  /**
   * DishOrder updateMany
   */
  export type DishOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DishOrders.
     */
    data: XOR<DishOrderUpdateManyMutationInput, DishOrderUncheckedUpdateManyInput>
    /**
     * Filter which DishOrders to update
     */
    where?: DishOrderWhereInput
    /**
     * Limit how many DishOrders to update.
     */
    limit?: number
  }

  /**
   * DishOrder updateManyAndReturn
   */
  export type DishOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * The data used to update DishOrders.
     */
    data: XOR<DishOrderUpdateManyMutationInput, DishOrderUncheckedUpdateManyInput>
    /**
     * Filter which DishOrders to update
     */
    where?: DishOrderWhereInput
    /**
     * Limit how many DishOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DishOrder upsert
   */
  export type DishOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the DishOrder to update in case it exists.
     */
    where: DishOrderWhereUniqueInput
    /**
     * In case the DishOrder found by the `where` argument doesn't exist, create a new DishOrder with this data.
     */
    create: XOR<DishOrderCreateInput, DishOrderUncheckedCreateInput>
    /**
     * In case the DishOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DishOrderUpdateInput, DishOrderUncheckedUpdateInput>
  }

  /**
   * DishOrder delete
   */
  export type DishOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    /**
     * Filter which DishOrder to delete.
     */
    where: DishOrderWhereUniqueInput
  }

  /**
   * DishOrder deleteMany
   */
  export type DishOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DishOrders to delete
     */
    where?: DishOrderWhereInput
    /**
     * Limit how many DishOrders to delete.
     */
    limit?: number
  }

  /**
   * DishOrder.order
   */
  export type DishOrder$orderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * DishOrder.returnedOrder
   */
  export type DishOrder$returnedOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
  }

  /**
   * DishOrder without action
   */
  export type DishOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
  }


  /**
   * Model Order
   */

  export type AggregateOrder = {
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  export type OrderAvgAggregateOutputType = {
    orderNo: number | null
    totalQuantity: number | null
    totalBeforeTaxAmount: number | null
    totalAfterTaxAmount: number | null
    numberOfCustomer: number | null
  }

  export type OrderSumAggregateOutputType = {
    orderNo: number | null
    totalQuantity: number | null
    totalBeforeTaxAmount: number | null
    totalAfterTaxAmount: number | null
    numberOfCustomer: number | null
  }

  export type OrderMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    tableId: string | null
    orderSessionId: string | null
    orderNo: number | null
    customerId: string | null
    totalQuantity: number | null
    totalBeforeTaxAmount: number | null
    totalAfterTaxAmount: number | null
    approvedById: string | null
    cancelledById: string | null
    status: $Enums.Status | null
    orderSessionStatus: $Enums.OrderSessionStatus | null
    numberOfCustomer: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    tableId: string | null
    orderSessionId: string | null
    orderNo: number | null
    customerId: string | null
    totalQuantity: number | null
    totalBeforeTaxAmount: number | null
    totalAfterTaxAmount: number | null
    approvedById: string | null
    cancelledById: string | null
    status: $Enums.Status | null
    orderSessionStatus: $Enums.OrderSessionStatus | null
    numberOfCustomer: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderCountAggregateOutputType = {
    id: number
    shopId: number
    tableId: number
    orderSessionId: number
    orderNo: number
    customerId: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById: number
    cancelledById: number
    status: number
    orderSessionStatus: number
    numberOfCustomer: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderAvgAggregateInputType = {
    orderNo?: true
    totalQuantity?: true
    totalBeforeTaxAmount?: true
    totalAfterTaxAmount?: true
    numberOfCustomer?: true
  }

  export type OrderSumAggregateInputType = {
    orderNo?: true
    totalQuantity?: true
    totalBeforeTaxAmount?: true
    totalAfterTaxAmount?: true
    numberOfCustomer?: true
  }

  export type OrderMinAggregateInputType = {
    id?: true
    shopId?: true
    tableId?: true
    orderSessionId?: true
    orderNo?: true
    customerId?: true
    totalQuantity?: true
    totalBeforeTaxAmount?: true
    totalAfterTaxAmount?: true
    approvedById?: true
    cancelledById?: true
    status?: true
    orderSessionStatus?: true
    numberOfCustomer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderMaxAggregateInputType = {
    id?: true
    shopId?: true
    tableId?: true
    orderSessionId?: true
    orderNo?: true
    customerId?: true
    totalQuantity?: true
    totalBeforeTaxAmount?: true
    totalAfterTaxAmount?: true
    approvedById?: true
    cancelledById?: true
    status?: true
    orderSessionStatus?: true
    numberOfCustomer?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderCountAggregateInputType = {
    id?: true
    shopId?: true
    tableId?: true
    orderSessionId?: true
    orderNo?: true
    customerId?: true
    totalQuantity?: true
    totalBeforeTaxAmount?: true
    totalAfterTaxAmount?: true
    approvedById?: true
    cancelledById?: true
    status?: true
    orderSessionStatus?: true
    numberOfCustomer?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Order to aggregate.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Orders
    **/
    _count?: true | OrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderMaxAggregateInputType
  }

  export type GetOrderAggregateType<T extends OrderAggregateArgs> = {
        [P in keyof T & keyof AggregateOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrder[P]>
      : GetScalarType<T[P], AggregateOrder[P]>
  }




  export type OrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithAggregationInput | OrderOrderByWithAggregationInput[]
    by: OrderScalarFieldEnum[] | OrderScalarFieldEnum
    having?: OrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderCountAggregateInputType | true
    _avg?: OrderAvgAggregateInputType
    _sum?: OrderSumAggregateInputType
    _min?: OrderMinAggregateInputType
    _max?: OrderMaxAggregateInputType
  }

  export type OrderGroupByOutputType = {
    id: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById: string | null
    cancelledById: string | null
    status: $Enums.Status
    orderSessionStatus: $Enums.OrderSessionStatus
    numberOfCustomer: number | null
    createdAt: Date
    updatedAt: Date
    _count: OrderCountAggregateOutputType | null
    _avg: OrderAvgAggregateOutputType | null
    _sum: OrderSumAggregateOutputType | null
    _min: OrderMinAggregateOutputType | null
    _max: OrderMaxAggregateOutputType | null
  }

  type GetOrderGroupByPayload<T extends OrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderGroupByOutputType[P]>
            : GetScalarType<T[P], OrderGroupByOutputType[P]>
        }
      >
    >


  export type OrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    tableId?: boolean
    orderSessionId?: boolean
    orderNo?: boolean
    customerId?: boolean
    totalQuantity?: boolean
    totalBeforeTaxAmount?: boolean
    totalAfterTaxAmount?: boolean
    approvedById?: boolean
    cancelledById?: boolean
    status?: boolean
    orderSessionStatus?: boolean
    numberOfCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    dishOrders?: boolean | Order$dishOrdersArgs<ExtArgs>
    returnedDishOrders?: boolean | Order$returnedDishOrdersArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    cancelledBy?: boolean | Order$cancelledByArgs<ExtArgs>
    KitchenLog?: boolean | Order$KitchenLogArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    tableId?: boolean
    orderSessionId?: boolean
    orderNo?: boolean
    customerId?: boolean
    totalQuantity?: boolean
    totalBeforeTaxAmount?: boolean
    totalAfterTaxAmount?: boolean
    approvedById?: boolean
    cancelledById?: boolean
    status?: boolean
    orderSessionStatus?: boolean
    numberOfCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    cancelledBy?: boolean | Order$cancelledByArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    tableId?: boolean
    orderSessionId?: boolean
    orderNo?: boolean
    customerId?: boolean
    totalQuantity?: boolean
    totalBeforeTaxAmount?: boolean
    totalAfterTaxAmount?: boolean
    approvedById?: boolean
    cancelledById?: boolean
    status?: boolean
    orderSessionStatus?: boolean
    numberOfCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    cancelledBy?: boolean | Order$cancelledByArgs<ExtArgs>
  }, ExtArgs["result"]["order"]>

  export type OrderSelectScalar = {
    id?: boolean
    shopId?: boolean
    tableId?: boolean
    orderSessionId?: boolean
    orderNo?: boolean
    customerId?: boolean
    totalQuantity?: boolean
    totalBeforeTaxAmount?: boolean
    totalAfterTaxAmount?: boolean
    approvedById?: boolean
    cancelledById?: boolean
    status?: boolean
    orderSessionStatus?: boolean
    numberOfCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopId" | "tableId" | "orderSessionId" | "orderNo" | "customerId" | "totalQuantity" | "totalBeforeTaxAmount" | "totalAfterTaxAmount" | "approvedById" | "cancelledById" | "status" | "orderSessionStatus" | "numberOfCustomer" | "createdAt" | "updatedAt", ExtArgs["result"]["order"]>
  export type OrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dishOrders?: boolean | Order$dishOrdersArgs<ExtArgs>
    returnedDishOrders?: boolean | Order$returnedDishOrdersArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    cancelledBy?: boolean | Order$cancelledByArgs<ExtArgs>
    KitchenLog?: boolean | Order$KitchenLogArgs<ExtArgs>
    _count?: boolean | OrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    cancelledBy?: boolean | Order$cancelledByArgs<ExtArgs>
  }
  export type OrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    table?: boolean | TableDefaultArgs<ExtArgs>
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
    customer?: boolean | Order$customerArgs<ExtArgs>
    approvedBy?: boolean | Order$approvedByArgs<ExtArgs>
    cancelledBy?: boolean | Order$cancelledByArgs<ExtArgs>
  }

  export type $OrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Order"
    objects: {
      dishOrders: Prisma.$DishOrderPayload<ExtArgs>[]
      returnedDishOrders: Prisma.$DishOrderPayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>
      table: Prisma.$TablePayload<ExtArgs>
      orderSession: Prisma.$OrderSessionPayload<ExtArgs>
      customer: Prisma.$CustomerPayload<ExtArgs> | null
      approvedBy: Prisma.$UserPayload<ExtArgs> | null
      cancelledBy: Prisma.$UserPayload<ExtArgs> | null
      KitchenLog: Prisma.$KitchenLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      tableId: string
      orderSessionId: string
      orderNo: number
      customerId: string | null
      totalQuantity: number
      totalBeforeTaxAmount: number
      totalAfterTaxAmount: number
      approvedById: string | null
      cancelledById: string | null
      status: $Enums.Status
      orderSessionStatus: $Enums.OrderSessionStatus
      numberOfCustomer: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["order"]>
    composites: {}
  }

  type OrderGetPayload<S extends boolean | null | undefined | OrderDefaultArgs> = $Result.GetResult<Prisma.$OrderPayload, S>

  type OrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderCountAggregateInputType | true
    }

  export interface OrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Order'], meta: { name: 'Order' } }
    /**
     * Find zero or one Order that matches the filter.
     * @param {OrderFindUniqueArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderFindUniqueArgs>(args: SelectSubset<T, OrderFindUniqueArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Order that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderFindUniqueOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderFindFirstArgs>(args?: SelectSubset<T, OrderFindFirstArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Order that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindFirstOrThrowArgs} args - Arguments to find a Order
     * @example
     * // Get one Order
     * const order = await prisma.order.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Orders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Orders
     * const orders = await prisma.order.findMany()
     * 
     * // Get first 10 Orders
     * const orders = await prisma.order.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderWithIdOnly = await prisma.order.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderFindManyArgs>(args?: SelectSubset<T, OrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Order.
     * @param {OrderCreateArgs} args - Arguments to create a Order.
     * @example
     * // Create one Order
     * const Order = await prisma.order.create({
     *   data: {
     *     // ... data to create a Order
     *   }
     * })
     * 
     */
    create<T extends OrderCreateArgs>(args: SelectSubset<T, OrderCreateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Orders.
     * @param {OrderCreateManyArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderCreateManyArgs>(args?: SelectSubset<T, OrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Orders and returns the data saved in the database.
     * @param {OrderCreateManyAndReturnArgs} args - Arguments to create many Orders.
     * @example
     * // Create many Orders
     * const order = await prisma.order.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Order.
     * @param {OrderDeleteArgs} args - Arguments to delete one Order.
     * @example
     * // Delete one Order
     * const Order = await prisma.order.delete({
     *   where: {
     *     // ... filter to delete one Order
     *   }
     * })
     * 
     */
    delete<T extends OrderDeleteArgs>(args: SelectSubset<T, OrderDeleteArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Order.
     * @param {OrderUpdateArgs} args - Arguments to update one Order.
     * @example
     * // Update one Order
     * const order = await prisma.order.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderUpdateArgs>(args: SelectSubset<T, OrderUpdateArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Orders.
     * @param {OrderDeleteManyArgs} args - Arguments to filter Orders to delete.
     * @example
     * // Delete a few Orders
     * const { count } = await prisma.order.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderDeleteManyArgs>(args?: SelectSubset<T, OrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderUpdateManyArgs>(args: SelectSubset<T, OrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Orders and returns the data updated in the database.
     * @param {OrderUpdateManyAndReturnArgs} args - Arguments to update many Orders.
     * @example
     * // Update many Orders
     * const order = await prisma.order.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Orders and only return the `id`
     * const orderWithIdOnly = await prisma.order.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Order.
     * @param {OrderUpsertArgs} args - Arguments to update or create a Order.
     * @example
     * // Update or create a Order
     * const order = await prisma.order.upsert({
     *   create: {
     *     // ... data to create a Order
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Order we want to update
     *   }
     * })
     */
    upsert<T extends OrderUpsertArgs>(args: SelectSubset<T, OrderUpsertArgs<ExtArgs>>): Prisma__OrderClient<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Orders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderCountArgs} args - Arguments to filter Orders to count.
     * @example
     * // Count the number of Orders
     * const count = await prisma.order.count({
     *   where: {
     *     // ... the filter for the Orders we want to count
     *   }
     * })
    **/
    count<T extends OrderCountArgs>(
      args?: Subset<T, OrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderAggregateArgs>(args: Subset<T, OrderAggregateArgs>): Prisma.PrismaPromise<GetOrderAggregateType<T>>

    /**
     * Group by Order.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderGroupByArgs['orderBy'] }
        : { orderBy?: OrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Order model
   */
  readonly fields: OrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Order.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dishOrders<T extends Order$dishOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Order$dishOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    returnedDishOrders<T extends Order$returnedDishOrdersArgs<ExtArgs> = {}>(args?: Subset<T, Order$returnedDishOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    table<T extends TableDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TableDefaultArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    orderSession<T extends OrderSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderSessionDefaultArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends Order$customerArgs<ExtArgs> = {}>(args?: Subset<T, Order$customerArgs<ExtArgs>>): Prisma__CustomerClient<$Result.GetResult<Prisma.$CustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    approvedBy<T extends Order$approvedByArgs<ExtArgs> = {}>(args?: Subset<T, Order$approvedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    cancelledBy<T extends Order$cancelledByArgs<ExtArgs> = {}>(args?: Subset<T, Order$cancelledByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    KitchenLog<T extends Order$KitchenLogArgs<ExtArgs> = {}>(args?: Subset<T, Order$KitchenLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Order model
   */
  interface OrderFieldRefs {
    readonly id: FieldRef<"Order", 'String'>
    readonly shopId: FieldRef<"Order", 'String'>
    readonly tableId: FieldRef<"Order", 'String'>
    readonly orderSessionId: FieldRef<"Order", 'String'>
    readonly orderNo: FieldRef<"Order", 'Int'>
    readonly customerId: FieldRef<"Order", 'String'>
    readonly totalQuantity: FieldRef<"Order", 'Int'>
    readonly totalBeforeTaxAmount: FieldRef<"Order", 'Float'>
    readonly totalAfterTaxAmount: FieldRef<"Order", 'Float'>
    readonly approvedById: FieldRef<"Order", 'String'>
    readonly cancelledById: FieldRef<"Order", 'String'>
    readonly status: FieldRef<"Order", 'Status'>
    readonly orderSessionStatus: FieldRef<"Order", 'OrderSessionStatus'>
    readonly numberOfCustomer: FieldRef<"Order", 'Int'>
    readonly createdAt: FieldRef<"Order", 'DateTime'>
    readonly updatedAt: FieldRef<"Order", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Order findUnique
   */
  export type OrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findUniqueOrThrow
   */
  export type OrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order findFirst
   */
  export type OrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findFirstOrThrow
   */
  export type OrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Order to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Orders.
     */
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order findMany
   */
  export type OrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter, which Orders to fetch.
     */
    where?: OrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Orders to fetch.
     */
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Orders.
     */
    cursor?: OrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Orders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Orders.
     */
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Order create
   */
  export type OrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to create a Order.
     */
    data: XOR<OrderCreateInput, OrderUncheckedCreateInput>
  }

  /**
   * Order createMany
   */
  export type OrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Order createManyAndReturn
   */
  export type OrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to create many Orders.
     */
    data: OrderCreateManyInput | OrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order update
   */
  export type OrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The data needed to update a Order.
     */
    data: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
    /**
     * Choose, which Order to update.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order updateMany
   */
  export type OrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
  }

  /**
   * Order updateManyAndReturn
   */
  export type OrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * The data used to update Orders.
     */
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyInput>
    /**
     * Filter which Orders to update
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Order upsert
   */
  export type OrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * The filter to search for the Order to update in case it exists.
     */
    where: OrderWhereUniqueInput
    /**
     * In case the Order found by the `where` argument doesn't exist, create a new Order with this data.
     */
    create: XOR<OrderCreateInput, OrderUncheckedCreateInput>
    /**
     * In case the Order was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderUpdateInput, OrderUncheckedUpdateInput>
  }

  /**
   * Order delete
   */
  export type OrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    /**
     * Filter which Order to delete.
     */
    where: OrderWhereUniqueInput
  }

  /**
   * Order deleteMany
   */
  export type OrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Orders to delete
     */
    where?: OrderWhereInput
    /**
     * Limit how many Orders to delete.
     */
    limit?: number
  }

  /**
   * Order.dishOrders
   */
  export type Order$dishOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    where?: DishOrderWhereInput
    orderBy?: DishOrderOrderByWithRelationInput | DishOrderOrderByWithRelationInput[]
    cursor?: DishOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishOrderScalarFieldEnum | DishOrderScalarFieldEnum[]
  }

  /**
   * Order.returnedDishOrders
   */
  export type Order$returnedDishOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishOrder
     */
    select?: DishOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishOrder
     */
    omit?: DishOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishOrderInclude<ExtArgs> | null
    where?: DishOrderWhereInput
    orderBy?: DishOrderOrderByWithRelationInput | DishOrderOrderByWithRelationInput[]
    cursor?: DishOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishOrderScalarFieldEnum | DishOrderScalarFieldEnum[]
  }

  /**
   * Order.customer
   */
  export type Order$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Customer
     */
    select?: CustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Customer
     */
    omit?: CustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CustomerInclude<ExtArgs> | null
    where?: CustomerWhereInput
  }

  /**
   * Order.approvedBy
   */
  export type Order$approvedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.cancelledBy
   */
  export type Order$cancelledByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Order.KitchenLog
   */
  export type Order$KitchenLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    where?: KitchenLogWhereInput
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    cursor?: KitchenLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenLogScalarFieldEnum | KitchenLogScalarFieldEnum[]
  }

  /**
   * Order without action
   */
  export type OrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
  }


  /**
   * Model DiscountProduct
   */

  export type AggregateDiscountProduct = {
    _count: DiscountProductCountAggregateOutputType | null
    _avg: DiscountProductAvgAggregateOutputType | null
    _sum: DiscountProductSumAggregateOutputType | null
    _min: DiscountProductMinAggregateOutputType | null
    _max: DiscountProductMaxAggregateOutputType | null
  }

  export type DiscountProductAvgAggregateOutputType = {
    discountRate: number | null
    discountValue: number | null
    beforeTaxDiscountPrice: number | null
    afterTaxDiscountPrice: number | null
    taxDiscountPrice: number | null
  }

  export type DiscountProductSumAggregateOutputType = {
    discountRate: number | null
    discountValue: number | null
    beforeTaxDiscountPrice: number | null
    afterTaxDiscountPrice: number | null
    taxDiscountPrice: number | null
  }

  export type DiscountProductMinAggregateOutputType = {
    id: string | null
    dishOrderId: string | null
    dishId: string | null
    dishName: string | null
    discountRate: number | null
    discountValue: number | null
    discountValueType: $Enums.DiscountValueType | null
    beforeTaxDiscountPrice: number | null
    afterTaxDiscountPrice: number | null
    taxDiscountPrice: number | null
    discountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountProductMaxAggregateOutputType = {
    id: string | null
    dishOrderId: string | null
    dishId: string | null
    dishName: string | null
    discountRate: number | null
    discountValue: number | null
    discountValueType: $Enums.DiscountValueType | null
    beforeTaxDiscountPrice: number | null
    afterTaxDiscountPrice: number | null
    taxDiscountPrice: number | null
    discountId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountProductCountAggregateOutputType = {
    id: number
    dishOrderId: number
    dishId: number
    dishName: number
    discountRate: number
    discountValue: number
    discountValueType: number
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    discountId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountProductAvgAggregateInputType = {
    discountRate?: true
    discountValue?: true
    beforeTaxDiscountPrice?: true
    afterTaxDiscountPrice?: true
    taxDiscountPrice?: true
  }

  export type DiscountProductSumAggregateInputType = {
    discountRate?: true
    discountValue?: true
    beforeTaxDiscountPrice?: true
    afterTaxDiscountPrice?: true
    taxDiscountPrice?: true
  }

  export type DiscountProductMinAggregateInputType = {
    id?: true
    dishOrderId?: true
    dishId?: true
    dishName?: true
    discountRate?: true
    discountValue?: true
    discountValueType?: true
    beforeTaxDiscountPrice?: true
    afterTaxDiscountPrice?: true
    taxDiscountPrice?: true
    discountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountProductMaxAggregateInputType = {
    id?: true
    dishOrderId?: true
    dishId?: true
    dishName?: true
    discountRate?: true
    discountValue?: true
    discountValueType?: true
    beforeTaxDiscountPrice?: true
    afterTaxDiscountPrice?: true
    taxDiscountPrice?: true
    discountId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountProductCountAggregateInputType = {
    id?: true
    dishOrderId?: true
    dishId?: true
    dishName?: true
    discountRate?: true
    discountValue?: true
    discountValueType?: true
    beforeTaxDiscountPrice?: true
    afterTaxDiscountPrice?: true
    taxDiscountPrice?: true
    discountId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountProduct to aggregate.
     */
    where?: DiscountProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountProducts to fetch.
     */
    orderBy?: DiscountProductOrderByWithRelationInput | DiscountProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscountProducts
    **/
    _count?: true | DiscountProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountProductMaxAggregateInputType
  }

  export type GetDiscountProductAggregateType<T extends DiscountProductAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscountProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscountProduct[P]>
      : GetScalarType<T[P], AggregateDiscountProduct[P]>
  }




  export type DiscountProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountProductWhereInput
    orderBy?: DiscountProductOrderByWithAggregationInput | DiscountProductOrderByWithAggregationInput[]
    by: DiscountProductScalarFieldEnum[] | DiscountProductScalarFieldEnum
    having?: DiscountProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountProductCountAggregateInputType | true
    _avg?: DiscountProductAvgAggregateInputType
    _sum?: DiscountProductSumAggregateInputType
    _min?: DiscountProductMinAggregateInputType
    _max?: DiscountProductMaxAggregateInputType
  }

  export type DiscountProductGroupByOutputType = {
    id: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    discountId: string
    createdAt: Date
    updatedAt: Date
    _count: DiscountProductCountAggregateOutputType | null
    _avg: DiscountProductAvgAggregateOutputType | null
    _sum: DiscountProductSumAggregateOutputType | null
    _min: DiscountProductMinAggregateOutputType | null
    _max: DiscountProductMaxAggregateOutputType | null
  }

  type GetDiscountProductGroupByPayload<T extends DiscountProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountProductGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountProductGroupByOutputType[P]>
        }
      >
    >


  export type DiscountProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dishOrderId?: boolean
    dishId?: boolean
    dishName?: boolean
    discountRate?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxDiscountPrice?: boolean
    afterTaxDiscountPrice?: boolean
    taxDiscountPrice?: boolean
    discountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountProduct"]>

  export type DiscountProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dishOrderId?: boolean
    dishId?: boolean
    dishName?: boolean
    discountRate?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxDiscountPrice?: boolean
    afterTaxDiscountPrice?: boolean
    taxDiscountPrice?: boolean
    discountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountProduct"]>

  export type DiscountProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dishOrderId?: boolean
    dishId?: boolean
    dishName?: boolean
    discountRate?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxDiscountPrice?: boolean
    afterTaxDiscountPrice?: boolean
    taxDiscountPrice?: boolean
    discountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discountProduct"]>

  export type DiscountProductSelectScalar = {
    id?: boolean
    dishOrderId?: boolean
    dishId?: boolean
    dishName?: boolean
    discountRate?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxDiscountPrice?: boolean
    afterTaxDiscountPrice?: boolean
    taxDiscountPrice?: boolean
    discountId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dishOrderId" | "dishId" | "dishName" | "discountRate" | "discountValue" | "discountValueType" | "beforeTaxDiscountPrice" | "afterTaxDiscountPrice" | "taxDiscountPrice" | "discountId" | "createdAt" | "updatedAt", ExtArgs["result"]["discountProduct"]>
  export type DiscountProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }
  export type DiscountProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }
  export type DiscountProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discount?: boolean | DiscountDefaultArgs<ExtArgs>
  }

  export type $DiscountProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscountProduct"
    objects: {
      discount: Prisma.$DiscountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dishOrderId: string
      dishId: string
      dishName: string
      discountRate: number
      discountValue: number
      discountValueType: $Enums.DiscountValueType
      beforeTaxDiscountPrice: number
      afterTaxDiscountPrice: number
      taxDiscountPrice: number
      discountId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discountProduct"]>
    composites: {}
  }

  type DiscountProductGetPayload<S extends boolean | null | undefined | DiscountProductDefaultArgs> = $Result.GetResult<Prisma.$DiscountProductPayload, S>

  type DiscountProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountProductCountAggregateInputType | true
    }

  export interface DiscountProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscountProduct'], meta: { name: 'DiscountProduct' } }
    /**
     * Find zero or one DiscountProduct that matches the filter.
     * @param {DiscountProductFindUniqueArgs} args - Arguments to find a DiscountProduct
     * @example
     * // Get one DiscountProduct
     * const discountProduct = await prisma.discountProduct.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountProductFindUniqueArgs>(args: SelectSubset<T, DiscountProductFindUniqueArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscountProduct that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountProductFindUniqueOrThrowArgs} args - Arguments to find a DiscountProduct
     * @example
     * // Get one DiscountProduct
     * const discountProduct = await prisma.discountProduct.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountProductFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountProduct that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductFindFirstArgs} args - Arguments to find a DiscountProduct
     * @example
     * // Get one DiscountProduct
     * const discountProduct = await prisma.discountProduct.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountProductFindFirstArgs>(args?: SelectSubset<T, DiscountProductFindFirstArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscountProduct that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductFindFirstOrThrowArgs} args - Arguments to find a DiscountProduct
     * @example
     * // Get one DiscountProduct
     * const discountProduct = await prisma.discountProduct.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountProductFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscountProducts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscountProducts
     * const discountProducts = await prisma.discountProduct.findMany()
     * 
     * // Get first 10 DiscountProducts
     * const discountProducts = await prisma.discountProduct.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountProductWithIdOnly = await prisma.discountProduct.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountProductFindManyArgs>(args?: SelectSubset<T, DiscountProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscountProduct.
     * @param {DiscountProductCreateArgs} args - Arguments to create a DiscountProduct.
     * @example
     * // Create one DiscountProduct
     * const DiscountProduct = await prisma.discountProduct.create({
     *   data: {
     *     // ... data to create a DiscountProduct
     *   }
     * })
     * 
     */
    create<T extends DiscountProductCreateArgs>(args: SelectSubset<T, DiscountProductCreateArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscountProducts.
     * @param {DiscountProductCreateManyArgs} args - Arguments to create many DiscountProducts.
     * @example
     * // Create many DiscountProducts
     * const discountProduct = await prisma.discountProduct.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountProductCreateManyArgs>(args?: SelectSubset<T, DiscountProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscountProducts and returns the data saved in the database.
     * @param {DiscountProductCreateManyAndReturnArgs} args - Arguments to create many DiscountProducts.
     * @example
     * // Create many DiscountProducts
     * const discountProduct = await prisma.discountProduct.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscountProducts and only return the `id`
     * const discountProductWithIdOnly = await prisma.discountProduct.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountProductCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscountProduct.
     * @param {DiscountProductDeleteArgs} args - Arguments to delete one DiscountProduct.
     * @example
     * // Delete one DiscountProduct
     * const DiscountProduct = await prisma.discountProduct.delete({
     *   where: {
     *     // ... filter to delete one DiscountProduct
     *   }
     * })
     * 
     */
    delete<T extends DiscountProductDeleteArgs>(args: SelectSubset<T, DiscountProductDeleteArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscountProduct.
     * @param {DiscountProductUpdateArgs} args - Arguments to update one DiscountProduct.
     * @example
     * // Update one DiscountProduct
     * const discountProduct = await prisma.discountProduct.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountProductUpdateArgs>(args: SelectSubset<T, DiscountProductUpdateArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscountProducts.
     * @param {DiscountProductDeleteManyArgs} args - Arguments to filter DiscountProducts to delete.
     * @example
     * // Delete a few DiscountProducts
     * const { count } = await prisma.discountProduct.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountProductDeleteManyArgs>(args?: SelectSubset<T, DiscountProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscountProducts
     * const discountProduct = await prisma.discountProduct.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountProductUpdateManyArgs>(args: SelectSubset<T, DiscountProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscountProducts and returns the data updated in the database.
     * @param {DiscountProductUpdateManyAndReturnArgs} args - Arguments to update many DiscountProducts.
     * @example
     * // Update many DiscountProducts
     * const discountProduct = await prisma.discountProduct.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscountProducts and only return the `id`
     * const discountProductWithIdOnly = await prisma.discountProduct.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountProductUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscountProduct.
     * @param {DiscountProductUpsertArgs} args - Arguments to update or create a DiscountProduct.
     * @example
     * // Update or create a DiscountProduct
     * const discountProduct = await prisma.discountProduct.upsert({
     *   create: {
     *     // ... data to create a DiscountProduct
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscountProduct we want to update
     *   }
     * })
     */
    upsert<T extends DiscountProductUpsertArgs>(args: SelectSubset<T, DiscountProductUpsertArgs<ExtArgs>>): Prisma__DiscountProductClient<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscountProducts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductCountArgs} args - Arguments to filter DiscountProducts to count.
     * @example
     * // Count the number of DiscountProducts
     * const count = await prisma.discountProduct.count({
     *   where: {
     *     // ... the filter for the DiscountProducts we want to count
     *   }
     * })
    **/
    count<T extends DiscountProductCountArgs>(
      args?: Subset<T, DiscountProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscountProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountProductAggregateArgs>(args: Subset<T, DiscountProductAggregateArgs>): Prisma.PrismaPromise<GetDiscountProductAggregateType<T>>

    /**
     * Group by DiscountProduct.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountProductGroupByArgs['orderBy'] }
        : { orderBy?: DiscountProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscountProduct model
   */
  readonly fields: DiscountProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscountProduct.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discount<T extends DiscountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DiscountDefaultArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscountProduct model
   */
  interface DiscountProductFieldRefs {
    readonly id: FieldRef<"DiscountProduct", 'String'>
    readonly dishOrderId: FieldRef<"DiscountProduct", 'String'>
    readonly dishId: FieldRef<"DiscountProduct", 'String'>
    readonly dishName: FieldRef<"DiscountProduct", 'String'>
    readonly discountRate: FieldRef<"DiscountProduct", 'Float'>
    readonly discountValue: FieldRef<"DiscountProduct", 'Float'>
    readonly discountValueType: FieldRef<"DiscountProduct", 'DiscountValueType'>
    readonly beforeTaxDiscountPrice: FieldRef<"DiscountProduct", 'Float'>
    readonly afterTaxDiscountPrice: FieldRef<"DiscountProduct", 'Float'>
    readonly taxDiscountPrice: FieldRef<"DiscountProduct", 'Float'>
    readonly discountId: FieldRef<"DiscountProduct", 'String'>
    readonly createdAt: FieldRef<"DiscountProduct", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscountProduct", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscountProduct findUnique
   */
  export type DiscountProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * Filter, which DiscountProduct to fetch.
     */
    where: DiscountProductWhereUniqueInput
  }

  /**
   * DiscountProduct findUniqueOrThrow
   */
  export type DiscountProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * Filter, which DiscountProduct to fetch.
     */
    where: DiscountProductWhereUniqueInput
  }

  /**
   * DiscountProduct findFirst
   */
  export type DiscountProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * Filter, which DiscountProduct to fetch.
     */
    where?: DiscountProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountProducts to fetch.
     */
    orderBy?: DiscountProductOrderByWithRelationInput | DiscountProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountProducts.
     */
    cursor?: DiscountProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountProducts.
     */
    distinct?: DiscountProductScalarFieldEnum | DiscountProductScalarFieldEnum[]
  }

  /**
   * DiscountProduct findFirstOrThrow
   */
  export type DiscountProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * Filter, which DiscountProduct to fetch.
     */
    where?: DiscountProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountProducts to fetch.
     */
    orderBy?: DiscountProductOrderByWithRelationInput | DiscountProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscountProducts.
     */
    cursor?: DiscountProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountProducts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscountProducts.
     */
    distinct?: DiscountProductScalarFieldEnum | DiscountProductScalarFieldEnum[]
  }

  /**
   * DiscountProduct findMany
   */
  export type DiscountProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * Filter, which DiscountProducts to fetch.
     */
    where?: DiscountProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscountProducts to fetch.
     */
    orderBy?: DiscountProductOrderByWithRelationInput | DiscountProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscountProducts.
     */
    cursor?: DiscountProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DiscountProducts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscountProducts.
     */
    skip?: number
    distinct?: DiscountProductScalarFieldEnum | DiscountProductScalarFieldEnum[]
  }

  /**
   * DiscountProduct create
   */
  export type DiscountProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscountProduct.
     */
    data: XOR<DiscountProductCreateInput, DiscountProductUncheckedCreateInput>
  }

  /**
   * DiscountProduct createMany
   */
  export type DiscountProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscountProducts.
     */
    data: DiscountProductCreateManyInput | DiscountProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscountProduct createManyAndReturn
   */
  export type DiscountProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * The data used to create many DiscountProducts.
     */
    data: DiscountProductCreateManyInput | DiscountProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscountProduct update
   */
  export type DiscountProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscountProduct.
     */
    data: XOR<DiscountProductUpdateInput, DiscountProductUncheckedUpdateInput>
    /**
     * Choose, which DiscountProduct to update.
     */
    where: DiscountProductWhereUniqueInput
  }

  /**
   * DiscountProduct updateMany
   */
  export type DiscountProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscountProducts.
     */
    data: XOR<DiscountProductUpdateManyMutationInput, DiscountProductUncheckedUpdateManyInput>
    /**
     * Filter which DiscountProducts to update
     */
    where?: DiscountProductWhereInput
    /**
     * Limit how many DiscountProducts to update.
     */
    limit?: number
  }

  /**
   * DiscountProduct updateManyAndReturn
   */
  export type DiscountProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * The data used to update DiscountProducts.
     */
    data: XOR<DiscountProductUpdateManyMutationInput, DiscountProductUncheckedUpdateManyInput>
    /**
     * Filter which DiscountProducts to update
     */
    where?: DiscountProductWhereInput
    /**
     * Limit how many DiscountProducts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscountProduct upsert
   */
  export type DiscountProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscountProduct to update in case it exists.
     */
    where: DiscountProductWhereUniqueInput
    /**
     * In case the DiscountProduct found by the `where` argument doesn't exist, create a new DiscountProduct with this data.
     */
    create: XOR<DiscountProductCreateInput, DiscountProductUncheckedCreateInput>
    /**
     * In case the DiscountProduct was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountProductUpdateInput, DiscountProductUncheckedUpdateInput>
  }

  /**
   * DiscountProduct delete
   */
  export type DiscountProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    /**
     * Filter which DiscountProduct to delete.
     */
    where: DiscountProductWhereUniqueInput
  }

  /**
   * DiscountProduct deleteMany
   */
  export type DiscountProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscountProducts to delete
     */
    where?: DiscountProductWhereInput
    /**
     * Limit how many DiscountProducts to delete.
     */
    limit?: number
  }

  /**
   * DiscountProduct without action
   */
  export type DiscountProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
  }


  /**
   * Model Discount
   */

  export type AggregateDiscount = {
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  export type DiscountAvgAggregateOutputType = {
    discountValue: number | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
  }

  export type DiscountSumAggregateOutputType = {
    discountValue: number | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
  }

  export type DiscountMinAggregateOutputType = {
    id: string | null
    name: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    discountValueType: $Enums.DiscountValueType | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
    orderSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    discountType: $Enums.DiscountType | null
    discountValue: number | null
    discountValueType: $Enums.DiscountValueType | null
    beforeTaxTotalDiscountAmount: number | null
    afterTaxTotalDiscountAmount: number | null
    taxTotalDiscountAmount: number | null
    orderSessionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DiscountCountAggregateOutputType = {
    id: number
    name: number
    discountType: number
    discountValue: number
    discountValueType: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    orderSessionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DiscountAvgAggregateInputType = {
    discountValue?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
  }

  export type DiscountSumAggregateInputType = {
    discountValue?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
  }

  export type DiscountMinAggregateInputType = {
    id?: true
    name?: true
    discountType?: true
    discountValue?: true
    discountValueType?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    orderSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountMaxAggregateInputType = {
    id?: true
    name?: true
    discountType?: true
    discountValue?: true
    discountValueType?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    orderSessionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DiscountCountAggregateInputType = {
    id?: true
    name?: true
    discountType?: true
    discountValue?: true
    discountValueType?: true
    beforeTaxTotalDiscountAmount?: true
    afterTaxTotalDiscountAmount?: true
    taxTotalDiscountAmount?: true
    orderSessionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DiscountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discount to aggregate.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Discounts
    **/
    _count?: true | DiscountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DiscountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DiscountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscountMaxAggregateInputType
  }

  export type GetDiscountAggregateType<T extends DiscountAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscount[P]>
      : GetScalarType<T[P], AggregateDiscount[P]>
  }




  export type DiscountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithAggregationInput | DiscountOrderByWithAggregationInput[]
    by: DiscountScalarFieldEnum[] | DiscountScalarFieldEnum
    having?: DiscountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscountCountAggregateInputType | true
    _avg?: DiscountAvgAggregateInputType
    _sum?: DiscountSumAggregateInputType
    _min?: DiscountMinAggregateInputType
    _max?: DiscountMaxAggregateInputType
  }

  export type DiscountGroupByOutputType = {
    id: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    orderSessionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: DiscountCountAggregateOutputType | null
    _avg: DiscountAvgAggregateOutputType | null
    _sum: DiscountSumAggregateOutputType | null
    _min: DiscountMinAggregateOutputType | null
    _max: DiscountMaxAggregateOutputType | null
  }

  type GetDiscountGroupByPayload<T extends DiscountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscountGroupByOutputType[P]>
            : GetScalarType<T[P], DiscountGroupByOutputType[P]>
        }
      >
    >


  export type DiscountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    orderSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    discountProducts?: boolean | Discount$discountProductsArgs<ExtArgs>
    orderSession?: boolean | Discount$orderSessionArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    orderSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderSession?: boolean | Discount$orderSessionArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    orderSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orderSession?: boolean | Discount$orderSessionArgs<ExtArgs>
  }, ExtArgs["result"]["discount"]>

  export type DiscountSelectScalar = {
    id?: boolean
    name?: boolean
    discountType?: boolean
    discountValue?: boolean
    discountValueType?: boolean
    beforeTaxTotalDiscountAmount?: boolean
    afterTaxTotalDiscountAmount?: boolean
    taxTotalDiscountAmount?: boolean
    orderSessionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DiscountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "discountType" | "discountValue" | "discountValueType" | "beforeTaxTotalDiscountAmount" | "afterTaxTotalDiscountAmount" | "taxTotalDiscountAmount" | "orderSessionId" | "createdAt" | "updatedAt", ExtArgs["result"]["discount"]>
  export type DiscountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    discountProducts?: boolean | Discount$discountProductsArgs<ExtArgs>
    orderSession?: boolean | Discount$orderSessionArgs<ExtArgs>
    _count?: boolean | DiscountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DiscountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | Discount$orderSessionArgs<ExtArgs>
  }
  export type DiscountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | Discount$orderSessionArgs<ExtArgs>
  }

  export type $DiscountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Discount"
    objects: {
      discountProducts: Prisma.$DiscountProductPayload<ExtArgs>[]
      orderSession: Prisma.$OrderSessionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      discountType: $Enums.DiscountType
      discountValue: number
      discountValueType: $Enums.DiscountValueType
      beforeTaxTotalDiscountAmount: number
      afterTaxTotalDiscountAmount: number
      taxTotalDiscountAmount: number
      orderSessionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["discount"]>
    composites: {}
  }

  type DiscountGetPayload<S extends boolean | null | undefined | DiscountDefaultArgs> = $Result.GetResult<Prisma.$DiscountPayload, S>

  type DiscountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscountCountAggregateInputType | true
    }

  export interface DiscountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Discount'], meta: { name: 'Discount' } }
    /**
     * Find zero or one Discount that matches the filter.
     * @param {DiscountFindUniqueArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscountFindUniqueArgs>(args: SelectSubset<T, DiscountFindUniqueArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Discount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscountFindUniqueOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscountFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscountFindFirstArgs>(args?: SelectSubset<T, DiscountFindFirstArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Discount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindFirstOrThrowArgs} args - Arguments to find a Discount
     * @example
     * // Get one Discount
     * const discount = await prisma.discount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscountFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscountFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Discounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Discounts
     * const discounts = await prisma.discount.findMany()
     * 
     * // Get first 10 Discounts
     * const discounts = await prisma.discount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const discountWithIdOnly = await prisma.discount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DiscountFindManyArgs>(args?: SelectSubset<T, DiscountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Discount.
     * @param {DiscountCreateArgs} args - Arguments to create a Discount.
     * @example
     * // Create one Discount
     * const Discount = await prisma.discount.create({
     *   data: {
     *     // ... data to create a Discount
     *   }
     * })
     * 
     */
    create<T extends DiscountCreateArgs>(args: SelectSubset<T, DiscountCreateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Discounts.
     * @param {DiscountCreateManyArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscountCreateManyArgs>(args?: SelectSubset<T, DiscountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Discounts and returns the data saved in the database.
     * @param {DiscountCreateManyAndReturnArgs} args - Arguments to create many Discounts.
     * @example
     * // Create many Discounts
     * const discount = await prisma.discount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscountCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Discount.
     * @param {DiscountDeleteArgs} args - Arguments to delete one Discount.
     * @example
     * // Delete one Discount
     * const Discount = await prisma.discount.delete({
     *   where: {
     *     // ... filter to delete one Discount
     *   }
     * })
     * 
     */
    delete<T extends DiscountDeleteArgs>(args: SelectSubset<T, DiscountDeleteArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Discount.
     * @param {DiscountUpdateArgs} args - Arguments to update one Discount.
     * @example
     * // Update one Discount
     * const discount = await prisma.discount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscountUpdateArgs>(args: SelectSubset<T, DiscountUpdateArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Discounts.
     * @param {DiscountDeleteManyArgs} args - Arguments to filter Discounts to delete.
     * @example
     * // Delete a few Discounts
     * const { count } = await prisma.discount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscountDeleteManyArgs>(args?: SelectSubset<T, DiscountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscountUpdateManyArgs>(args: SelectSubset<T, DiscountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Discounts and returns the data updated in the database.
     * @param {DiscountUpdateManyAndReturnArgs} args - Arguments to update many Discounts.
     * @example
     * // Update many Discounts
     * const discount = await prisma.discount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Discounts and only return the `id`
     * const discountWithIdOnly = await prisma.discount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscountUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Discount.
     * @param {DiscountUpsertArgs} args - Arguments to update or create a Discount.
     * @example
     * // Update or create a Discount
     * const discount = await prisma.discount.upsert({
     *   create: {
     *     // ... data to create a Discount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Discount we want to update
     *   }
     * })
     */
    upsert<T extends DiscountUpsertArgs>(args: SelectSubset<T, DiscountUpsertArgs<ExtArgs>>): Prisma__DiscountClient<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Discounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountCountArgs} args - Arguments to filter Discounts to count.
     * @example
     * // Count the number of Discounts
     * const count = await prisma.discount.count({
     *   where: {
     *     // ... the filter for the Discounts we want to count
     *   }
     * })
    **/
    count<T extends DiscountCountArgs>(
      args?: Subset<T, DiscountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscountAggregateArgs>(args: Subset<T, DiscountAggregateArgs>): Prisma.PrismaPromise<GetDiscountAggregateType<T>>

    /**
     * Group by Discount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscountGroupByArgs['orderBy'] }
        : { orderBy?: DiscountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Discount model
   */
  readonly fields: DiscountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Discount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    discountProducts<T extends Discount$discountProductsArgs<ExtArgs> = {}>(args?: Subset<T, Discount$discountProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    orderSession<T extends Discount$orderSessionArgs<ExtArgs> = {}>(args?: Subset<T, Discount$orderSessionArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Discount model
   */
  interface DiscountFieldRefs {
    readonly id: FieldRef<"Discount", 'String'>
    readonly name: FieldRef<"Discount", 'String'>
    readonly discountType: FieldRef<"Discount", 'DiscountType'>
    readonly discountValue: FieldRef<"Discount", 'Float'>
    readonly discountValueType: FieldRef<"Discount", 'DiscountValueType'>
    readonly beforeTaxTotalDiscountAmount: FieldRef<"Discount", 'Float'>
    readonly afterTaxTotalDiscountAmount: FieldRef<"Discount", 'Float'>
    readonly taxTotalDiscountAmount: FieldRef<"Discount", 'Float'>
    readonly orderSessionId: FieldRef<"Discount", 'String'>
    readonly createdAt: FieldRef<"Discount", 'DateTime'>
    readonly updatedAt: FieldRef<"Discount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Discount findUnique
   */
  export type DiscountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findUniqueOrThrow
   */
  export type DiscountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount findFirst
   */
  export type DiscountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findFirstOrThrow
   */
  export type DiscountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discount to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Discounts.
     */
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount findMany
   */
  export type DiscountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter, which Discounts to fetch.
     */
    where?: DiscountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Discounts to fetch.
     */
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Discounts.
     */
    cursor?: DiscountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Discounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Discounts.
     */
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * Discount create
   */
  export type DiscountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to create a Discount.
     */
    data: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
  }

  /**
   * Discount createMany
   */
  export type DiscountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Discount createManyAndReturn
   */
  export type DiscountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to create many Discounts.
     */
    data: DiscountCreateManyInput | DiscountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discount update
   */
  export type DiscountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The data needed to update a Discount.
     */
    data: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
    /**
     * Choose, which Discount to update.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount updateMany
   */
  export type DiscountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
  }

  /**
   * Discount updateManyAndReturn
   */
  export type DiscountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * The data used to update Discounts.
     */
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyInput>
    /**
     * Filter which Discounts to update
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Discount upsert
   */
  export type DiscountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * The filter to search for the Discount to update in case it exists.
     */
    where: DiscountWhereUniqueInput
    /**
     * In case the Discount found by the `where` argument doesn't exist, create a new Discount with this data.
     */
    create: XOR<DiscountCreateInput, DiscountUncheckedCreateInput>
    /**
     * In case the Discount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscountUpdateInput, DiscountUncheckedUpdateInput>
  }

  /**
   * Discount delete
   */
  export type DiscountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    /**
     * Filter which Discount to delete.
     */
    where: DiscountWhereUniqueInput
  }

  /**
   * Discount deleteMany
   */
  export type DiscountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Discounts to delete
     */
    where?: DiscountWhereInput
    /**
     * Limit how many Discounts to delete.
     */
    limit?: number
  }

  /**
   * Discount.discountProducts
   */
  export type Discount$discountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscountProduct
     */
    select?: DiscountProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscountProduct
     */
    omit?: DiscountProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountProductInclude<ExtArgs> | null
    where?: DiscountProductWhereInput
    orderBy?: DiscountProductOrderByWithRelationInput | DiscountProductOrderByWithRelationInput[]
    cursor?: DiscountProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountProductScalarFieldEnum | DiscountProductScalarFieldEnum[]
  }

  /**
   * Discount.orderSession
   */
  export type Discount$orderSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    where?: OrderSessionWhereInput
  }

  /**
   * Discount without action
   */
  export type DiscountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
  }


  /**
   * Model TaxDetail
   */

  export type AggregateTaxDetail = {
    _count: TaxDetailCountAggregateOutputType | null
    _avg: TaxDetailAvgAggregateOutputType | null
    _sum: TaxDetailSumAggregateOutputType | null
    _min: TaxDetailMinAggregateOutputType | null
    _max: TaxDetailMaxAggregateOutputType | null
  }

  export type TaxDetailAvgAggregateOutputType = {
    taxAmount: number | null
    taxRate: number | null
  }

  export type TaxDetailSumAggregateOutputType = {
    taxAmount: number | null
    taxRate: number | null
  }

  export type TaxDetailMinAggregateOutputType = {
    id: string | null
    taxAmount: number | null
    taxRate: number | null
    orderSessionId: string | null
  }

  export type TaxDetailMaxAggregateOutputType = {
    id: string | null
    taxAmount: number | null
    taxRate: number | null
    orderSessionId: string | null
  }

  export type TaxDetailCountAggregateOutputType = {
    id: number
    taxAmount: number
    taxRate: number
    orderSessionId: number
    _all: number
  }


  export type TaxDetailAvgAggregateInputType = {
    taxAmount?: true
    taxRate?: true
  }

  export type TaxDetailSumAggregateInputType = {
    taxAmount?: true
    taxRate?: true
  }

  export type TaxDetailMinAggregateInputType = {
    id?: true
    taxAmount?: true
    taxRate?: true
    orderSessionId?: true
  }

  export type TaxDetailMaxAggregateInputType = {
    id?: true
    taxAmount?: true
    taxRate?: true
    orderSessionId?: true
  }

  export type TaxDetailCountAggregateInputType = {
    id?: true
    taxAmount?: true
    taxRate?: true
    orderSessionId?: true
    _all?: true
  }

  export type TaxDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxDetail to aggregate.
     */
    where?: TaxDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxDetails to fetch.
     */
    orderBy?: TaxDetailOrderByWithRelationInput | TaxDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaxDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TaxDetails
    **/
    _count?: true | TaxDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TaxDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TaxDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaxDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaxDetailMaxAggregateInputType
  }

  export type GetTaxDetailAggregateType<T extends TaxDetailAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxDetail[P]>
      : GetScalarType<T[P], AggregateTaxDetail[P]>
  }




  export type TaxDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaxDetailWhereInput
    orderBy?: TaxDetailOrderByWithAggregationInput | TaxDetailOrderByWithAggregationInput[]
    by: TaxDetailScalarFieldEnum[] | TaxDetailScalarFieldEnum
    having?: TaxDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaxDetailCountAggregateInputType | true
    _avg?: TaxDetailAvgAggregateInputType
    _sum?: TaxDetailSumAggregateInputType
    _min?: TaxDetailMinAggregateInputType
    _max?: TaxDetailMaxAggregateInputType
  }

  export type TaxDetailGroupByOutputType = {
    id: string
    taxAmount: number
    taxRate: number
    orderSessionId: string
    _count: TaxDetailCountAggregateOutputType | null
    _avg: TaxDetailAvgAggregateOutputType | null
    _sum: TaxDetailSumAggregateOutputType | null
    _min: TaxDetailMinAggregateOutputType | null
    _max: TaxDetailMaxAggregateOutputType | null
  }

  type GetTaxDetailGroupByPayload<T extends TaxDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaxDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaxDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaxDetailGroupByOutputType[P]>
            : GetScalarType<T[P], TaxDetailGroupByOutputType[P]>
        }
      >
    >


  export type TaxDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxAmount?: boolean
    taxRate?: boolean
    orderSessionId?: boolean
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxDetail"]>

  export type TaxDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxAmount?: boolean
    taxRate?: boolean
    orderSessionId?: boolean
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxDetail"]>

  export type TaxDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taxAmount?: boolean
    taxRate?: boolean
    orderSessionId?: boolean
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["taxDetail"]>

  export type TaxDetailSelectScalar = {
    id?: boolean
    taxAmount?: boolean
    taxRate?: boolean
    orderSessionId?: boolean
  }

  export type TaxDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taxAmount" | "taxRate" | "orderSessionId", ExtArgs["result"]["taxDetail"]>
  export type TaxDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }
  export type TaxDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }
  export type TaxDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }

  export type $TaxDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TaxDetail"
    objects: {
      orderSession: Prisma.$OrderSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taxAmount: number
      taxRate: number
      orderSessionId: string
    }, ExtArgs["result"]["taxDetail"]>
    composites: {}
  }

  type TaxDetailGetPayload<S extends boolean | null | undefined | TaxDetailDefaultArgs> = $Result.GetResult<Prisma.$TaxDetailPayload, S>

  type TaxDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaxDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaxDetailCountAggregateInputType | true
    }

  export interface TaxDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TaxDetail'], meta: { name: 'TaxDetail' } }
    /**
     * Find zero or one TaxDetail that matches the filter.
     * @param {TaxDetailFindUniqueArgs} args - Arguments to find a TaxDetail
     * @example
     * // Get one TaxDetail
     * const taxDetail = await prisma.taxDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaxDetailFindUniqueArgs>(args: SelectSubset<T, TaxDetailFindUniqueArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TaxDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaxDetailFindUniqueOrThrowArgs} args - Arguments to find a TaxDetail
     * @example
     * // Get one TaxDetail
     * const taxDetail = await prisma.taxDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaxDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, TaxDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailFindFirstArgs} args - Arguments to find a TaxDetail
     * @example
     * // Get one TaxDetail
     * const taxDetail = await prisma.taxDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaxDetailFindFirstArgs>(args?: SelectSubset<T, TaxDetailFindFirstArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TaxDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailFindFirstOrThrowArgs} args - Arguments to find a TaxDetail
     * @example
     * // Get one TaxDetail
     * const taxDetail = await prisma.taxDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaxDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, TaxDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TaxDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TaxDetails
     * const taxDetails = await prisma.taxDetail.findMany()
     * 
     * // Get first 10 TaxDetails
     * const taxDetails = await prisma.taxDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxDetailWithIdOnly = await prisma.taxDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaxDetailFindManyArgs>(args?: SelectSubset<T, TaxDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TaxDetail.
     * @param {TaxDetailCreateArgs} args - Arguments to create a TaxDetail.
     * @example
     * // Create one TaxDetail
     * const TaxDetail = await prisma.taxDetail.create({
     *   data: {
     *     // ... data to create a TaxDetail
     *   }
     * })
     * 
     */
    create<T extends TaxDetailCreateArgs>(args: SelectSubset<T, TaxDetailCreateArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TaxDetails.
     * @param {TaxDetailCreateManyArgs} args - Arguments to create many TaxDetails.
     * @example
     * // Create many TaxDetails
     * const taxDetail = await prisma.taxDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaxDetailCreateManyArgs>(args?: SelectSubset<T, TaxDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TaxDetails and returns the data saved in the database.
     * @param {TaxDetailCreateManyAndReturnArgs} args - Arguments to create many TaxDetails.
     * @example
     * // Create many TaxDetails
     * const taxDetail = await prisma.taxDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TaxDetails and only return the `id`
     * const taxDetailWithIdOnly = await prisma.taxDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaxDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, TaxDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TaxDetail.
     * @param {TaxDetailDeleteArgs} args - Arguments to delete one TaxDetail.
     * @example
     * // Delete one TaxDetail
     * const TaxDetail = await prisma.taxDetail.delete({
     *   where: {
     *     // ... filter to delete one TaxDetail
     *   }
     * })
     * 
     */
    delete<T extends TaxDetailDeleteArgs>(args: SelectSubset<T, TaxDetailDeleteArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TaxDetail.
     * @param {TaxDetailUpdateArgs} args - Arguments to update one TaxDetail.
     * @example
     * // Update one TaxDetail
     * const taxDetail = await prisma.taxDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaxDetailUpdateArgs>(args: SelectSubset<T, TaxDetailUpdateArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TaxDetails.
     * @param {TaxDetailDeleteManyArgs} args - Arguments to filter TaxDetails to delete.
     * @example
     * // Delete a few TaxDetails
     * const { count } = await prisma.taxDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaxDetailDeleteManyArgs>(args?: SelectSubset<T, TaxDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TaxDetails
     * const taxDetail = await prisma.taxDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaxDetailUpdateManyArgs>(args: SelectSubset<T, TaxDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TaxDetails and returns the data updated in the database.
     * @param {TaxDetailUpdateManyAndReturnArgs} args - Arguments to update many TaxDetails.
     * @example
     * // Update many TaxDetails
     * const taxDetail = await prisma.taxDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TaxDetails and only return the `id`
     * const taxDetailWithIdOnly = await prisma.taxDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaxDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, TaxDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TaxDetail.
     * @param {TaxDetailUpsertArgs} args - Arguments to update or create a TaxDetail.
     * @example
     * // Update or create a TaxDetail
     * const taxDetail = await prisma.taxDetail.upsert({
     *   create: {
     *     // ... data to create a TaxDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TaxDetail we want to update
     *   }
     * })
     */
    upsert<T extends TaxDetailUpsertArgs>(args: SelectSubset<T, TaxDetailUpsertArgs<ExtArgs>>): Prisma__TaxDetailClient<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TaxDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailCountArgs} args - Arguments to filter TaxDetails to count.
     * @example
     * // Count the number of TaxDetails
     * const count = await prisma.taxDetail.count({
     *   where: {
     *     // ... the filter for the TaxDetails we want to count
     *   }
     * })
    **/
    count<T extends TaxDetailCountArgs>(
      args?: Subset<T, TaxDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaxDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TaxDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaxDetailAggregateArgs>(args: Subset<T, TaxDetailAggregateArgs>): Prisma.PrismaPromise<GetTaxDetailAggregateType<T>>

    /**
     * Group by TaxDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaxDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaxDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaxDetailGroupByArgs['orderBy'] }
        : { orderBy?: TaxDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaxDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TaxDetail model
   */
  readonly fields: TaxDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TaxDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaxDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderSession<T extends OrderSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderSessionDefaultArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TaxDetail model
   */
  interface TaxDetailFieldRefs {
    readonly id: FieldRef<"TaxDetail", 'String'>
    readonly taxAmount: FieldRef<"TaxDetail", 'Float'>
    readonly taxRate: FieldRef<"TaxDetail", 'Float'>
    readonly orderSessionId: FieldRef<"TaxDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TaxDetail findUnique
   */
  export type TaxDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * Filter, which TaxDetail to fetch.
     */
    where: TaxDetailWhereUniqueInput
  }

  /**
   * TaxDetail findUniqueOrThrow
   */
  export type TaxDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * Filter, which TaxDetail to fetch.
     */
    where: TaxDetailWhereUniqueInput
  }

  /**
   * TaxDetail findFirst
   */
  export type TaxDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * Filter, which TaxDetail to fetch.
     */
    where?: TaxDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxDetails to fetch.
     */
    orderBy?: TaxDetailOrderByWithRelationInput | TaxDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxDetails.
     */
    cursor?: TaxDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxDetails.
     */
    distinct?: TaxDetailScalarFieldEnum | TaxDetailScalarFieldEnum[]
  }

  /**
   * TaxDetail findFirstOrThrow
   */
  export type TaxDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * Filter, which TaxDetail to fetch.
     */
    where?: TaxDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxDetails to fetch.
     */
    orderBy?: TaxDetailOrderByWithRelationInput | TaxDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TaxDetails.
     */
    cursor?: TaxDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TaxDetails.
     */
    distinct?: TaxDetailScalarFieldEnum | TaxDetailScalarFieldEnum[]
  }

  /**
   * TaxDetail findMany
   */
  export type TaxDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * Filter, which TaxDetails to fetch.
     */
    where?: TaxDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TaxDetails to fetch.
     */
    orderBy?: TaxDetailOrderByWithRelationInput | TaxDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TaxDetails.
     */
    cursor?: TaxDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TaxDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TaxDetails.
     */
    skip?: number
    distinct?: TaxDetailScalarFieldEnum | TaxDetailScalarFieldEnum[]
  }

  /**
   * TaxDetail create
   */
  export type TaxDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a TaxDetail.
     */
    data: XOR<TaxDetailCreateInput, TaxDetailUncheckedCreateInput>
  }

  /**
   * TaxDetail createMany
   */
  export type TaxDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TaxDetails.
     */
    data: TaxDetailCreateManyInput | TaxDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TaxDetail createManyAndReturn
   */
  export type TaxDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * The data used to create many TaxDetails.
     */
    data: TaxDetailCreateManyInput | TaxDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxDetail update
   */
  export type TaxDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a TaxDetail.
     */
    data: XOR<TaxDetailUpdateInput, TaxDetailUncheckedUpdateInput>
    /**
     * Choose, which TaxDetail to update.
     */
    where: TaxDetailWhereUniqueInput
  }

  /**
   * TaxDetail updateMany
   */
  export type TaxDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TaxDetails.
     */
    data: XOR<TaxDetailUpdateManyMutationInput, TaxDetailUncheckedUpdateManyInput>
    /**
     * Filter which TaxDetails to update
     */
    where?: TaxDetailWhereInput
    /**
     * Limit how many TaxDetails to update.
     */
    limit?: number
  }

  /**
   * TaxDetail updateManyAndReturn
   */
  export type TaxDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * The data used to update TaxDetails.
     */
    data: XOR<TaxDetailUpdateManyMutationInput, TaxDetailUncheckedUpdateManyInput>
    /**
     * Filter which TaxDetails to update
     */
    where?: TaxDetailWhereInput
    /**
     * Limit how many TaxDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TaxDetail upsert
   */
  export type TaxDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the TaxDetail to update in case it exists.
     */
    where: TaxDetailWhereUniqueInput
    /**
     * In case the TaxDetail found by the `where` argument doesn't exist, create a new TaxDetail with this data.
     */
    create: XOR<TaxDetailCreateInput, TaxDetailUncheckedCreateInput>
    /**
     * In case the TaxDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaxDetailUpdateInput, TaxDetailUncheckedUpdateInput>
  }

  /**
   * TaxDetail delete
   */
  export type TaxDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    /**
     * Filter which TaxDetail to delete.
     */
    where: TaxDetailWhereUniqueInput
  }

  /**
   * TaxDetail deleteMany
   */
  export type TaxDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TaxDetails to delete
     */
    where?: TaxDetailWhereInput
    /**
     * Limit how many TaxDetails to delete.
     */
    limit?: number
  }

  /**
   * TaxDetail without action
   */
  export type TaxDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
  }


  /**
   * Model PaymentDetail
   */

  export type AggregatePaymentDetail = {
    _count: PaymentDetailCountAggregateOutputType | null
    _avg: PaymentDetailAvgAggregateOutputType | null
    _sum: PaymentDetailSumAggregateOutputType | null
    _min: PaymentDetailMinAggregateOutputType | null
    _max: PaymentDetailMaxAggregateOutputType | null
  }

  export type PaymentDetailAvgAggregateOutputType = {
    paymentAmount: number | null
  }

  export type PaymentDetailSumAggregateOutputType = {
    paymentAmount: number | null
  }

  export type PaymentDetailMinAggregateOutputType = {
    id: string | null
    paymentMethod: $Enums.PaymentMethodEnum | null
    paymentAmount: number | null
    orderSessionId: string | null
  }

  export type PaymentDetailMaxAggregateOutputType = {
    id: string | null
    paymentMethod: $Enums.PaymentMethodEnum | null
    paymentAmount: number | null
    orderSessionId: string | null
  }

  export type PaymentDetailCountAggregateOutputType = {
    id: number
    paymentMethod: number
    paymentAmount: number
    orderSessionId: number
    _all: number
  }


  export type PaymentDetailAvgAggregateInputType = {
    paymentAmount?: true
  }

  export type PaymentDetailSumAggregateInputType = {
    paymentAmount?: true
  }

  export type PaymentDetailMinAggregateInputType = {
    id?: true
    paymentMethod?: true
    paymentAmount?: true
    orderSessionId?: true
  }

  export type PaymentDetailMaxAggregateInputType = {
    id?: true
    paymentMethod?: true
    paymentAmount?: true
    orderSessionId?: true
  }

  export type PaymentDetailCountAggregateInputType = {
    id?: true
    paymentMethod?: true
    paymentAmount?: true
    orderSessionId?: true
    _all?: true
  }

  export type PaymentDetailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentDetail to aggregate.
     */
    where?: PaymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailOrderByWithRelationInput | PaymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentDetails
    **/
    _count?: true | PaymentDetailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentDetailAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentDetailSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentDetailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentDetailMaxAggregateInputType
  }

  export type GetPaymentDetailAggregateType<T extends PaymentDetailAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentDetail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentDetail[P]>
      : GetScalarType<T[P], AggregatePaymentDetail[P]>
  }




  export type PaymentDetailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentDetailWhereInput
    orderBy?: PaymentDetailOrderByWithAggregationInput | PaymentDetailOrderByWithAggregationInput[]
    by: PaymentDetailScalarFieldEnum[] | PaymentDetailScalarFieldEnum
    having?: PaymentDetailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentDetailCountAggregateInputType | true
    _avg?: PaymentDetailAvgAggregateInputType
    _sum?: PaymentDetailSumAggregateInputType
    _min?: PaymentDetailMinAggregateInputType
    _max?: PaymentDetailMaxAggregateInputType
  }

  export type PaymentDetailGroupByOutputType = {
    id: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
    orderSessionId: string
    _count: PaymentDetailCountAggregateOutputType | null
    _avg: PaymentDetailAvgAggregateOutputType | null
    _sum: PaymentDetailSumAggregateOutputType | null
    _min: PaymentDetailMinAggregateOutputType | null
    _max: PaymentDetailMaxAggregateOutputType | null
  }

  type GetPaymentDetailGroupByPayload<T extends PaymentDetailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentDetailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentDetailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentDetailGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentDetailGroupByOutputType[P]>
        }
      >
    >


  export type PaymentDetailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    paymentAmount?: boolean
    orderSessionId?: boolean
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetail"]>

  export type PaymentDetailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    paymentAmount?: boolean
    orderSessionId?: boolean
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetail"]>

  export type PaymentDetailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    paymentMethod?: boolean
    paymentAmount?: boolean
    orderSessionId?: boolean
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentDetail"]>

  export type PaymentDetailSelectScalar = {
    id?: boolean
    paymentMethod?: boolean
    paymentAmount?: boolean
    orderSessionId?: boolean
  }

  export type PaymentDetailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "paymentMethod" | "paymentAmount" | "orderSessionId", ExtArgs["result"]["paymentDetail"]>
  export type PaymentDetailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }
  export type PaymentDetailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }
  export type PaymentDetailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderSession?: boolean | OrderSessionDefaultArgs<ExtArgs>
  }

  export type $PaymentDetailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentDetail"
    objects: {
      orderSession: Prisma.$OrderSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      paymentMethod: $Enums.PaymentMethodEnum
      paymentAmount: number
      orderSessionId: string
    }, ExtArgs["result"]["paymentDetail"]>
    composites: {}
  }

  type PaymentDetailGetPayload<S extends boolean | null | undefined | PaymentDetailDefaultArgs> = $Result.GetResult<Prisma.$PaymentDetailPayload, S>

  type PaymentDetailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentDetailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentDetailCountAggregateInputType | true
    }

  export interface PaymentDetailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentDetail'], meta: { name: 'PaymentDetail' } }
    /**
     * Find zero or one PaymentDetail that matches the filter.
     * @param {PaymentDetailFindUniqueArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentDetailFindUniqueArgs>(args: SelectSubset<T, PaymentDetailFindUniqueArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PaymentDetail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentDetailFindUniqueOrThrowArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentDetailFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentDetailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentDetail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailFindFirstArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentDetailFindFirstArgs>(args?: SelectSubset<T, PaymentDetailFindFirstArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PaymentDetail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailFindFirstOrThrowArgs} args - Arguments to find a PaymentDetail
     * @example
     * // Get one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentDetailFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentDetailFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PaymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentDetails
     * const paymentDetails = await prisma.paymentDetail.findMany()
     * 
     * // Get first 10 PaymentDetails
     * const paymentDetails = await prisma.paymentDetail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentDetailWithIdOnly = await prisma.paymentDetail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentDetailFindManyArgs>(args?: SelectSubset<T, PaymentDetailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PaymentDetail.
     * @param {PaymentDetailCreateArgs} args - Arguments to create a PaymentDetail.
     * @example
     * // Create one PaymentDetail
     * const PaymentDetail = await prisma.paymentDetail.create({
     *   data: {
     *     // ... data to create a PaymentDetail
     *   }
     * })
     * 
     */
    create<T extends PaymentDetailCreateArgs>(args: SelectSubset<T, PaymentDetailCreateArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PaymentDetails.
     * @param {PaymentDetailCreateManyArgs} args - Arguments to create many PaymentDetails.
     * @example
     * // Create many PaymentDetails
     * const paymentDetail = await prisma.paymentDetail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentDetailCreateManyArgs>(args?: SelectSubset<T, PaymentDetailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentDetails and returns the data saved in the database.
     * @param {PaymentDetailCreateManyAndReturnArgs} args - Arguments to create many PaymentDetails.
     * @example
     * // Create many PaymentDetails
     * const paymentDetail = await prisma.paymentDetail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentDetails and only return the `id`
     * const paymentDetailWithIdOnly = await prisma.paymentDetail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentDetailCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentDetailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PaymentDetail.
     * @param {PaymentDetailDeleteArgs} args - Arguments to delete one PaymentDetail.
     * @example
     * // Delete one PaymentDetail
     * const PaymentDetail = await prisma.paymentDetail.delete({
     *   where: {
     *     // ... filter to delete one PaymentDetail
     *   }
     * })
     * 
     */
    delete<T extends PaymentDetailDeleteArgs>(args: SelectSubset<T, PaymentDetailDeleteArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PaymentDetail.
     * @param {PaymentDetailUpdateArgs} args - Arguments to update one PaymentDetail.
     * @example
     * // Update one PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentDetailUpdateArgs>(args: SelectSubset<T, PaymentDetailUpdateArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PaymentDetails.
     * @param {PaymentDetailDeleteManyArgs} args - Arguments to filter PaymentDetails to delete.
     * @example
     * // Delete a few PaymentDetails
     * const { count } = await prisma.paymentDetail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDetailDeleteManyArgs>(args?: SelectSubset<T, PaymentDetailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentDetails
     * const paymentDetail = await prisma.paymentDetail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentDetailUpdateManyArgs>(args: SelectSubset<T, PaymentDetailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentDetails and returns the data updated in the database.
     * @param {PaymentDetailUpdateManyAndReturnArgs} args - Arguments to update many PaymentDetails.
     * @example
     * // Update many PaymentDetails
     * const paymentDetail = await prisma.paymentDetail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PaymentDetails and only return the `id`
     * const paymentDetailWithIdOnly = await prisma.paymentDetail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentDetailUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentDetailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PaymentDetail.
     * @param {PaymentDetailUpsertArgs} args - Arguments to update or create a PaymentDetail.
     * @example
     * // Update or create a PaymentDetail
     * const paymentDetail = await prisma.paymentDetail.upsert({
     *   create: {
     *     // ... data to create a PaymentDetail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentDetail we want to update
     *   }
     * })
     */
    upsert<T extends PaymentDetailUpsertArgs>(args: SelectSubset<T, PaymentDetailUpsertArgs<ExtArgs>>): Prisma__PaymentDetailClient<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PaymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailCountArgs} args - Arguments to filter PaymentDetails to count.
     * @example
     * // Count the number of PaymentDetails
     * const count = await prisma.paymentDetail.count({
     *   where: {
     *     // ... the filter for the PaymentDetails we want to count
     *   }
     * })
    **/
    count<T extends PaymentDetailCountArgs>(
      args?: Subset<T, PaymentDetailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentDetailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentDetailAggregateArgs>(args: Subset<T, PaymentDetailAggregateArgs>): Prisma.PrismaPromise<GetPaymentDetailAggregateType<T>>

    /**
     * Group by PaymentDetail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentDetailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentDetailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentDetailGroupByArgs['orderBy'] }
        : { orderBy?: PaymentDetailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentDetailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentDetailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentDetail model
   */
  readonly fields: PaymentDetailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentDetail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentDetailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderSession<T extends OrderSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OrderSessionDefaultArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentDetail model
   */
  interface PaymentDetailFieldRefs {
    readonly id: FieldRef<"PaymentDetail", 'String'>
    readonly paymentMethod: FieldRef<"PaymentDetail", 'PaymentMethodEnum'>
    readonly paymentAmount: FieldRef<"PaymentDetail", 'Float'>
    readonly orderSessionId: FieldRef<"PaymentDetail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PaymentDetail findUnique
   */
  export type PaymentDetailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where: PaymentDetailWhereUniqueInput
  }

  /**
   * PaymentDetail findUniqueOrThrow
   */
  export type PaymentDetailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where: PaymentDetailWhereUniqueInput
  }

  /**
   * PaymentDetail findFirst
   */
  export type PaymentDetailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where?: PaymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailOrderByWithRelationInput | PaymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[]
  }

  /**
   * PaymentDetail findFirstOrThrow
   */
  export type PaymentDetailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetail to fetch.
     */
    where?: PaymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailOrderByWithRelationInput | PaymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentDetails.
     */
    cursor?: PaymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentDetails.
     */
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[]
  }

  /**
   * PaymentDetail findMany
   */
  export type PaymentDetailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * Filter, which PaymentDetails to fetch.
     */
    where?: PaymentDetailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentDetails to fetch.
     */
    orderBy?: PaymentDetailOrderByWithRelationInput | PaymentDetailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentDetails.
     */
    cursor?: PaymentDetailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentDetails.
     */
    skip?: number
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[]
  }

  /**
   * PaymentDetail create
   */
  export type PaymentDetailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentDetail.
     */
    data: XOR<PaymentDetailCreateInput, PaymentDetailUncheckedCreateInput>
  }

  /**
   * PaymentDetail createMany
   */
  export type PaymentDetailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentDetails.
     */
    data: PaymentDetailCreateManyInput | PaymentDetailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentDetail createManyAndReturn
   */
  export type PaymentDetailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * The data used to create many PaymentDetails.
     */
    data: PaymentDetailCreateManyInput | PaymentDetailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentDetail update
   */
  export type PaymentDetailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentDetail.
     */
    data: XOR<PaymentDetailUpdateInput, PaymentDetailUncheckedUpdateInput>
    /**
     * Choose, which PaymentDetail to update.
     */
    where: PaymentDetailWhereUniqueInput
  }

  /**
   * PaymentDetail updateMany
   */
  export type PaymentDetailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentDetails.
     */
    data: XOR<PaymentDetailUpdateManyMutationInput, PaymentDetailUncheckedUpdateManyInput>
    /**
     * Filter which PaymentDetails to update
     */
    where?: PaymentDetailWhereInput
    /**
     * Limit how many PaymentDetails to update.
     */
    limit?: number
  }

  /**
   * PaymentDetail updateManyAndReturn
   */
  export type PaymentDetailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * The data used to update PaymentDetails.
     */
    data: XOR<PaymentDetailUpdateManyMutationInput, PaymentDetailUncheckedUpdateManyInput>
    /**
     * Filter which PaymentDetails to update
     */
    where?: PaymentDetailWhereInput
    /**
     * Limit how many PaymentDetails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentDetail upsert
   */
  export type PaymentDetailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentDetail to update in case it exists.
     */
    where: PaymentDetailWhereUniqueInput
    /**
     * In case the PaymentDetail found by the `where` argument doesn't exist, create a new PaymentDetail with this data.
     */
    create: XOR<PaymentDetailCreateInput, PaymentDetailUncheckedCreateInput>
    /**
     * In case the PaymentDetail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentDetailUpdateInput, PaymentDetailUncheckedUpdateInput>
  }

  /**
   * PaymentDetail delete
   */
  export type PaymentDetailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    /**
     * Filter which PaymentDetail to delete.
     */
    where: PaymentDetailWhereUniqueInput
  }

  /**
   * PaymentDetail deleteMany
   */
  export type PaymentDetailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentDetails to delete
     */
    where?: PaymentDetailWhereInput
    /**
     * Limit how many PaymentDetails to delete.
     */
    limit?: number
  }

  /**
   * PaymentDetail without action
   */
  export type PaymentDetailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
  }


  /**
   * Model OrderSession
   */

  export type AggregateOrderSession = {
    _count: OrderSessionCountAggregateOutputType | null
    _avg: OrderSessionAvgAggregateOutputType | null
    _sum: OrderSessionSumAggregateOutputType | null
    _min: OrderSessionMinAggregateOutputType | null
    _max: OrderSessionMaxAggregateOutputType | null
  }

  export type OrderSessionAvgAggregateOutputType = {
    orderSessionNo: number | null
    taxRate: number | null
    totalTaxAmount: number | null
    pretaxPaymentAmount: number | null
    paymentAmount: number | null
    numberOfCustomer: number | null
    totalDiscountAmountBeforeTax: number | null
    totalDiscountAmountAfterTax: number | null
  }

  export type OrderSessionSumAggregateOutputType = {
    orderSessionNo: number | null
    taxRate: number | null
    totalTaxAmount: number | null
    pretaxPaymentAmount: number | null
    paymentAmount: number | null
    numberOfCustomer: number | null
    totalDiscountAmountBeforeTax: number | null
    totalDiscountAmountAfterTax: number | null
  }

  export type OrderSessionMinAggregateOutputType = {
    id: string | null
    shopId: string | null
    orderSessionNo: number | null
    taxRate: number | null
    totalTaxAmount: number | null
    endedAt: Date | null
    auditedAt: Date | null
    status: $Enums.OrderSessionStatus | null
    pretaxPaymentAmount: number | null
    paymentAmount: number | null
    paidByEmployeeId: string | null
    paidByEmployeeName: string | null
    cancelledByEmployeeId: string | null
    cancelledByEmployeeName: string | null
    cancellationReason: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerAddress: string | null
    numberOfCustomer: number | null
    totalDiscountAmountBeforeTax: number | null
    totalDiscountAmountAfterTax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderSessionMaxAggregateOutputType = {
    id: string | null
    shopId: string | null
    orderSessionNo: number | null
    taxRate: number | null
    totalTaxAmount: number | null
    endedAt: Date | null
    auditedAt: Date | null
    status: $Enums.OrderSessionStatus | null
    pretaxPaymentAmount: number | null
    paymentAmount: number | null
    paidByEmployeeId: string | null
    paidByEmployeeName: string | null
    cancelledByEmployeeId: string | null
    cancelledByEmployeeName: string | null
    cancellationReason: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerAddress: string | null
    numberOfCustomer: number | null
    totalDiscountAmountBeforeTax: number | null
    totalDiscountAmountAfterTax: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type OrderSessionCountAggregateOutputType = {
    id: number
    shopId: number
    tableIds: number
    tableNames: number
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt: number
    auditedAt: number
    status: number
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId: number
    paidByEmployeeName: number
    cancelledByEmployeeId: number
    cancelledByEmployeeName: number
    cancellationReason: number
    customerId: number
    customerName: number
    customerPhone: number
    customerAddress: number
    numberOfCustomer: number
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type OrderSessionAvgAggregateInputType = {
    orderSessionNo?: true
    taxRate?: true
    totalTaxAmount?: true
    pretaxPaymentAmount?: true
    paymentAmount?: true
    numberOfCustomer?: true
    totalDiscountAmountBeforeTax?: true
    totalDiscountAmountAfterTax?: true
  }

  export type OrderSessionSumAggregateInputType = {
    orderSessionNo?: true
    taxRate?: true
    totalTaxAmount?: true
    pretaxPaymentAmount?: true
    paymentAmount?: true
    numberOfCustomer?: true
    totalDiscountAmountBeforeTax?: true
    totalDiscountAmountAfterTax?: true
  }

  export type OrderSessionMinAggregateInputType = {
    id?: true
    shopId?: true
    orderSessionNo?: true
    taxRate?: true
    totalTaxAmount?: true
    endedAt?: true
    auditedAt?: true
    status?: true
    pretaxPaymentAmount?: true
    paymentAmount?: true
    paidByEmployeeId?: true
    paidByEmployeeName?: true
    cancelledByEmployeeId?: true
    cancelledByEmployeeName?: true
    cancellationReason?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerAddress?: true
    numberOfCustomer?: true
    totalDiscountAmountBeforeTax?: true
    totalDiscountAmountAfterTax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderSessionMaxAggregateInputType = {
    id?: true
    shopId?: true
    orderSessionNo?: true
    taxRate?: true
    totalTaxAmount?: true
    endedAt?: true
    auditedAt?: true
    status?: true
    pretaxPaymentAmount?: true
    paymentAmount?: true
    paidByEmployeeId?: true
    paidByEmployeeName?: true
    cancelledByEmployeeId?: true
    cancelledByEmployeeName?: true
    cancellationReason?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerAddress?: true
    numberOfCustomer?: true
    totalDiscountAmountBeforeTax?: true
    totalDiscountAmountAfterTax?: true
    createdAt?: true
    updatedAt?: true
  }

  export type OrderSessionCountAggregateInputType = {
    id?: true
    shopId?: true
    tableIds?: true
    tableNames?: true
    orderSessionNo?: true
    taxRate?: true
    totalTaxAmount?: true
    endedAt?: true
    auditedAt?: true
    status?: true
    pretaxPaymentAmount?: true
    paymentAmount?: true
    paidByEmployeeId?: true
    paidByEmployeeName?: true
    cancelledByEmployeeId?: true
    cancelledByEmployeeName?: true
    cancellationReason?: true
    customerId?: true
    customerName?: true
    customerPhone?: true
    customerAddress?: true
    numberOfCustomer?: true
    totalDiscountAmountBeforeTax?: true
    totalDiscountAmountAfterTax?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type OrderSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSession to aggregate.
     */
    where?: OrderSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSessions to fetch.
     */
    orderBy?: OrderSessionOrderByWithRelationInput | OrderSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderSessions
    **/
    _count?: true | OrderSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderSessionMaxAggregateInputType
  }

  export type GetOrderSessionAggregateType<T extends OrderSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderSession[P]>
      : GetScalarType<T[P], AggregateOrderSession[P]>
  }




  export type OrderSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderSessionWhereInput
    orderBy?: OrderSessionOrderByWithAggregationInput | OrderSessionOrderByWithAggregationInput[]
    by: OrderSessionScalarFieldEnum[] | OrderSessionScalarFieldEnum
    having?: OrderSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderSessionCountAggregateInputType | true
    _avg?: OrderSessionAvgAggregateInputType
    _sum?: OrderSessionSumAggregateInputType
    _min?: OrderSessionMinAggregateInputType
    _max?: OrderSessionMaxAggregateInputType
  }

  export type OrderSessionGroupByOutputType = {
    id: string
    shopId: string
    tableIds: string[]
    tableNames: string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt: Date | null
    auditedAt: Date | null
    status: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId: string | null
    paidByEmployeeName: string | null
    cancelledByEmployeeId: string | null
    cancelledByEmployeeName: string | null
    cancellationReason: string | null
    customerId: string | null
    customerName: string | null
    customerPhone: string | null
    customerAddress: string | null
    numberOfCustomer: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt: Date
    updatedAt: Date
    _count: OrderSessionCountAggregateOutputType | null
    _avg: OrderSessionAvgAggregateOutputType | null
    _sum: OrderSessionSumAggregateOutputType | null
    _min: OrderSessionMinAggregateOutputType | null
    _max: OrderSessionMaxAggregateOutputType | null
  }

  type GetOrderSessionGroupByPayload<T extends OrderSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderSessionGroupByOutputType[P]>
            : GetScalarType<T[P], OrderSessionGroupByOutputType[P]>
        }
      >
    >


  export type OrderSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    tableIds?: boolean
    tableNames?: boolean
    orderSessionNo?: boolean
    taxRate?: boolean
    totalTaxAmount?: boolean
    endedAt?: boolean
    auditedAt?: boolean
    status?: boolean
    pretaxPaymentAmount?: boolean
    paymentAmount?: boolean
    paidByEmployeeId?: boolean
    paidByEmployeeName?: boolean
    cancelledByEmployeeId?: boolean
    cancelledByEmployeeName?: boolean
    cancellationReason?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerAddress?: boolean
    numberOfCustomer?: boolean
    totalDiscountAmountBeforeTax?: boolean
    totalDiscountAmountAfterTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    orders?: boolean | OrderSession$ordersArgs<ExtArgs>
    discounts?: boolean | OrderSession$discountsArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    taxDetails?: boolean | OrderSession$taxDetailsArgs<ExtArgs>
    paymentDetails?: boolean | OrderSession$paymentDetailsArgs<ExtArgs>
    _count?: boolean | OrderSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderSession"]>

  export type OrderSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    tableIds?: boolean
    tableNames?: boolean
    orderSessionNo?: boolean
    taxRate?: boolean
    totalTaxAmount?: boolean
    endedAt?: boolean
    auditedAt?: boolean
    status?: boolean
    pretaxPaymentAmount?: boolean
    paymentAmount?: boolean
    paidByEmployeeId?: boolean
    paidByEmployeeName?: boolean
    cancelledByEmployeeId?: boolean
    cancelledByEmployeeName?: boolean
    cancellationReason?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerAddress?: boolean
    numberOfCustomer?: boolean
    totalDiscountAmountBeforeTax?: boolean
    totalDiscountAmountAfterTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderSession"]>

  export type OrderSessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    shopId?: boolean
    tableIds?: boolean
    tableNames?: boolean
    orderSessionNo?: boolean
    taxRate?: boolean
    totalTaxAmount?: boolean
    endedAt?: boolean
    auditedAt?: boolean
    status?: boolean
    pretaxPaymentAmount?: boolean
    paymentAmount?: boolean
    paidByEmployeeId?: boolean
    paidByEmployeeName?: boolean
    cancelledByEmployeeId?: boolean
    cancelledByEmployeeName?: boolean
    cancellationReason?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerAddress?: boolean
    numberOfCustomer?: boolean
    totalDiscountAmountBeforeTax?: boolean
    totalDiscountAmountAfterTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderSession"]>

  export type OrderSessionSelectScalar = {
    id?: boolean
    shopId?: boolean
    tableIds?: boolean
    tableNames?: boolean
    orderSessionNo?: boolean
    taxRate?: boolean
    totalTaxAmount?: boolean
    endedAt?: boolean
    auditedAt?: boolean
    status?: boolean
    pretaxPaymentAmount?: boolean
    paymentAmount?: boolean
    paidByEmployeeId?: boolean
    paidByEmployeeName?: boolean
    cancelledByEmployeeId?: boolean
    cancelledByEmployeeName?: boolean
    cancellationReason?: boolean
    customerId?: boolean
    customerName?: boolean
    customerPhone?: boolean
    customerAddress?: boolean
    numberOfCustomer?: boolean
    totalDiscountAmountBeforeTax?: boolean
    totalDiscountAmountAfterTax?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type OrderSessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "shopId" | "tableIds" | "tableNames" | "orderSessionNo" | "taxRate" | "totalTaxAmount" | "endedAt" | "auditedAt" | "status" | "pretaxPaymentAmount" | "paymentAmount" | "paidByEmployeeId" | "paidByEmployeeName" | "cancelledByEmployeeId" | "cancelledByEmployeeName" | "cancellationReason" | "customerId" | "customerName" | "customerPhone" | "customerAddress" | "numberOfCustomer" | "totalDiscountAmountBeforeTax" | "totalDiscountAmountAfterTax" | "createdAt" | "updatedAt", ExtArgs["result"]["orderSession"]>
  export type OrderSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orders?: boolean | OrderSession$ordersArgs<ExtArgs>
    discounts?: boolean | OrderSession$discountsArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    taxDetails?: boolean | OrderSession$taxDetailsArgs<ExtArgs>
    paymentDetails?: boolean | OrderSession$paymentDetailsArgs<ExtArgs>
    _count?: boolean | OrderSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OrderSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type OrderSessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $OrderSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderSession"
    objects: {
      orders: Prisma.$OrderPayload<ExtArgs>[]
      discounts: Prisma.$DiscountPayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>
      taxDetails: Prisma.$TaxDetailPayload<ExtArgs>[]
      paymentDetails: Prisma.$PaymentDetailPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      shopId: string
      tableIds: string[]
      tableNames: string[]
      orderSessionNo: number
      taxRate: number
      totalTaxAmount: number
      endedAt: Date | null
      auditedAt: Date | null
      status: $Enums.OrderSessionStatus
      pretaxPaymentAmount: number
      paymentAmount: number
      paidByEmployeeId: string | null
      paidByEmployeeName: string | null
      cancelledByEmployeeId: string | null
      cancelledByEmployeeName: string | null
      cancellationReason: string | null
      customerId: string | null
      customerName: string | null
      customerPhone: string | null
      customerAddress: string | null
      numberOfCustomer: number | null
      totalDiscountAmountBeforeTax: number
      totalDiscountAmountAfterTax: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["orderSession"]>
    composites: {}
  }

  type OrderSessionGetPayload<S extends boolean | null | undefined | OrderSessionDefaultArgs> = $Result.GetResult<Prisma.$OrderSessionPayload, S>

  type OrderSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OrderSessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OrderSessionCountAggregateInputType | true
    }

  export interface OrderSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderSession'], meta: { name: 'OrderSession' } }
    /**
     * Find zero or one OrderSession that matches the filter.
     * @param {OrderSessionFindUniqueArgs} args - Arguments to find a OrderSession
     * @example
     * // Get one OrderSession
     * const orderSession = await prisma.orderSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderSessionFindUniqueArgs>(args: SelectSubset<T, OrderSessionFindUniqueArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OrderSession that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OrderSessionFindUniqueOrThrowArgs} args - Arguments to find a OrderSession
     * @example
     * // Get one OrderSession
     * const orderSession = await prisma.orderSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionFindFirstArgs} args - Arguments to find a OrderSession
     * @example
     * // Get one OrderSession
     * const orderSession = await prisma.orderSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderSessionFindFirstArgs>(args?: SelectSubset<T, OrderSessionFindFirstArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OrderSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionFindFirstOrThrowArgs} args - Arguments to find a OrderSession
     * @example
     * // Get one OrderSession
     * const orderSession = await prisma.orderSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OrderSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderSessions
     * const orderSessions = await prisma.orderSession.findMany()
     * 
     * // Get first 10 OrderSessions
     * const orderSessions = await prisma.orderSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderSessionWithIdOnly = await prisma.orderSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderSessionFindManyArgs>(args?: SelectSubset<T, OrderSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OrderSession.
     * @param {OrderSessionCreateArgs} args - Arguments to create a OrderSession.
     * @example
     * // Create one OrderSession
     * const OrderSession = await prisma.orderSession.create({
     *   data: {
     *     // ... data to create a OrderSession
     *   }
     * })
     * 
     */
    create<T extends OrderSessionCreateArgs>(args: SelectSubset<T, OrderSessionCreateArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OrderSessions.
     * @param {OrderSessionCreateManyArgs} args - Arguments to create many OrderSessions.
     * @example
     * // Create many OrderSessions
     * const orderSession = await prisma.orderSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderSessionCreateManyArgs>(args?: SelectSubset<T, OrderSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OrderSessions and returns the data saved in the database.
     * @param {OrderSessionCreateManyAndReturnArgs} args - Arguments to create many OrderSessions.
     * @example
     * // Create many OrderSessions
     * const orderSession = await prisma.orderSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OrderSessions and only return the `id`
     * const orderSessionWithIdOnly = await prisma.orderSession.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OrderSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, OrderSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OrderSession.
     * @param {OrderSessionDeleteArgs} args - Arguments to delete one OrderSession.
     * @example
     * // Delete one OrderSession
     * const OrderSession = await prisma.orderSession.delete({
     *   where: {
     *     // ... filter to delete one OrderSession
     *   }
     * })
     * 
     */
    delete<T extends OrderSessionDeleteArgs>(args: SelectSubset<T, OrderSessionDeleteArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OrderSession.
     * @param {OrderSessionUpdateArgs} args - Arguments to update one OrderSession.
     * @example
     * // Update one OrderSession
     * const orderSession = await prisma.orderSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderSessionUpdateArgs>(args: SelectSubset<T, OrderSessionUpdateArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OrderSessions.
     * @param {OrderSessionDeleteManyArgs} args - Arguments to filter OrderSessions to delete.
     * @example
     * // Delete a few OrderSessions
     * const { count } = await prisma.orderSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderSessionDeleteManyArgs>(args?: SelectSubset<T, OrderSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderSessions
     * const orderSession = await prisma.orderSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderSessionUpdateManyArgs>(args: SelectSubset<T, OrderSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderSessions and returns the data updated in the database.
     * @param {OrderSessionUpdateManyAndReturnArgs} args - Arguments to update many OrderSessions.
     * @example
     * // Update many OrderSessions
     * const orderSession = await prisma.orderSession.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OrderSessions and only return the `id`
     * const orderSessionWithIdOnly = await prisma.orderSession.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OrderSessionUpdateManyAndReturnArgs>(args: SelectSubset<T, OrderSessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OrderSession.
     * @param {OrderSessionUpsertArgs} args - Arguments to update or create a OrderSession.
     * @example
     * // Update or create a OrderSession
     * const orderSession = await prisma.orderSession.upsert({
     *   create: {
     *     // ... data to create a OrderSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderSession we want to update
     *   }
     * })
     */
    upsert<T extends OrderSessionUpsertArgs>(args: SelectSubset<T, OrderSessionUpsertArgs<ExtArgs>>): Prisma__OrderSessionClient<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OrderSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionCountArgs} args - Arguments to filter OrderSessions to count.
     * @example
     * // Count the number of OrderSessions
     * const count = await prisma.orderSession.count({
     *   where: {
     *     // ... the filter for the OrderSessions we want to count
     *   }
     * })
    **/
    count<T extends OrderSessionCountArgs>(
      args?: Subset<T, OrderSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderSessionAggregateArgs>(args: Subset<T, OrderSessionAggregateArgs>): Prisma.PrismaPromise<GetOrderSessionAggregateType<T>>

    /**
     * Group by OrderSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderSessionGroupByArgs['orderBy'] }
        : { orderBy?: OrderSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderSession model
   */
  readonly fields: OrderSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orders<T extends OrderSession$ordersArgs<ExtArgs> = {}>(args?: Subset<T, OrderSession$ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    discounts<T extends OrderSession$discountsArgs<ExtArgs> = {}>(args?: Subset<T, OrderSession$discountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    taxDetails<T extends OrderSession$taxDetailsArgs<ExtArgs> = {}>(args?: Subset<T, OrderSession$taxDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaxDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    paymentDetails<T extends OrderSession$paymentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, OrderSession$paymentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentDetailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderSession model
   */
  interface OrderSessionFieldRefs {
    readonly id: FieldRef<"OrderSession", 'String'>
    readonly shopId: FieldRef<"OrderSession", 'String'>
    readonly tableIds: FieldRef<"OrderSession", 'String[]'>
    readonly tableNames: FieldRef<"OrderSession", 'String[]'>
    readonly orderSessionNo: FieldRef<"OrderSession", 'Int'>
    readonly taxRate: FieldRef<"OrderSession", 'Float'>
    readonly totalTaxAmount: FieldRef<"OrderSession", 'Float'>
    readonly endedAt: FieldRef<"OrderSession", 'DateTime'>
    readonly auditedAt: FieldRef<"OrderSession", 'DateTime'>
    readonly status: FieldRef<"OrderSession", 'OrderSessionStatus'>
    readonly pretaxPaymentAmount: FieldRef<"OrderSession", 'Float'>
    readonly paymentAmount: FieldRef<"OrderSession", 'Float'>
    readonly paidByEmployeeId: FieldRef<"OrderSession", 'String'>
    readonly paidByEmployeeName: FieldRef<"OrderSession", 'String'>
    readonly cancelledByEmployeeId: FieldRef<"OrderSession", 'String'>
    readonly cancelledByEmployeeName: FieldRef<"OrderSession", 'String'>
    readonly cancellationReason: FieldRef<"OrderSession", 'String'>
    readonly customerId: FieldRef<"OrderSession", 'String'>
    readonly customerName: FieldRef<"OrderSession", 'String'>
    readonly customerPhone: FieldRef<"OrderSession", 'String'>
    readonly customerAddress: FieldRef<"OrderSession", 'String'>
    readonly numberOfCustomer: FieldRef<"OrderSession", 'Int'>
    readonly totalDiscountAmountBeforeTax: FieldRef<"OrderSession", 'Float'>
    readonly totalDiscountAmountAfterTax: FieldRef<"OrderSession", 'Float'>
    readonly createdAt: FieldRef<"OrderSession", 'DateTime'>
    readonly updatedAt: FieldRef<"OrderSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OrderSession findUnique
   */
  export type OrderSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * Filter, which OrderSession to fetch.
     */
    where: OrderSessionWhereUniqueInput
  }

  /**
   * OrderSession findUniqueOrThrow
   */
  export type OrderSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * Filter, which OrderSession to fetch.
     */
    where: OrderSessionWhereUniqueInput
  }

  /**
   * OrderSession findFirst
   */
  export type OrderSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * Filter, which OrderSession to fetch.
     */
    where?: OrderSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSessions to fetch.
     */
    orderBy?: OrderSessionOrderByWithRelationInput | OrderSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSessions.
     */
    cursor?: OrderSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSessions.
     */
    distinct?: OrderSessionScalarFieldEnum | OrderSessionScalarFieldEnum[]
  }

  /**
   * OrderSession findFirstOrThrow
   */
  export type OrderSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * Filter, which OrderSession to fetch.
     */
    where?: OrderSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSessions to fetch.
     */
    orderBy?: OrderSessionOrderByWithRelationInput | OrderSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderSessions.
     */
    cursor?: OrderSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderSessions.
     */
    distinct?: OrderSessionScalarFieldEnum | OrderSessionScalarFieldEnum[]
  }

  /**
   * OrderSession findMany
   */
  export type OrderSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * Filter, which OrderSessions to fetch.
     */
    where?: OrderSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderSessions to fetch.
     */
    orderBy?: OrderSessionOrderByWithRelationInput | OrderSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderSessions.
     */
    cursor?: OrderSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderSessions.
     */
    skip?: number
    distinct?: OrderSessionScalarFieldEnum | OrderSessionScalarFieldEnum[]
  }

  /**
   * OrderSession create
   */
  export type OrderSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderSession.
     */
    data: XOR<OrderSessionCreateInput, OrderSessionUncheckedCreateInput>
  }

  /**
   * OrderSession createMany
   */
  export type OrderSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderSessions.
     */
    data: OrderSessionCreateManyInput | OrderSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderSession createManyAndReturn
   */
  export type OrderSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * The data used to create many OrderSessions.
     */
    data: OrderSessionCreateManyInput | OrderSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderSession update
   */
  export type OrderSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderSession.
     */
    data: XOR<OrderSessionUpdateInput, OrderSessionUncheckedUpdateInput>
    /**
     * Choose, which OrderSession to update.
     */
    where: OrderSessionWhereUniqueInput
  }

  /**
   * OrderSession updateMany
   */
  export type OrderSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderSessions.
     */
    data: XOR<OrderSessionUpdateManyMutationInput, OrderSessionUncheckedUpdateManyInput>
    /**
     * Filter which OrderSessions to update
     */
    where?: OrderSessionWhereInput
    /**
     * Limit how many OrderSessions to update.
     */
    limit?: number
  }

  /**
   * OrderSession updateManyAndReturn
   */
  export type OrderSessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * The data used to update OrderSessions.
     */
    data: XOR<OrderSessionUpdateManyMutationInput, OrderSessionUncheckedUpdateManyInput>
    /**
     * Filter which OrderSessions to update
     */
    where?: OrderSessionWhereInput
    /**
     * Limit how many OrderSessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OrderSession upsert
   */
  export type OrderSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderSession to update in case it exists.
     */
    where: OrderSessionWhereUniqueInput
    /**
     * In case the OrderSession found by the `where` argument doesn't exist, create a new OrderSession with this data.
     */
    create: XOR<OrderSessionCreateInput, OrderSessionUncheckedCreateInput>
    /**
     * In case the OrderSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderSessionUpdateInput, OrderSessionUncheckedUpdateInput>
  }

  /**
   * OrderSession delete
   */
  export type OrderSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    /**
     * Filter which OrderSession to delete.
     */
    where: OrderSessionWhereUniqueInput
  }

  /**
   * OrderSession deleteMany
   */
  export type OrderSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderSessions to delete
     */
    where?: OrderSessionWhereInput
    /**
     * Limit how many OrderSessions to delete.
     */
    limit?: number
  }

  /**
   * OrderSession.orders
   */
  export type OrderSession$ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * OrderSession.discounts
   */
  export type OrderSession$discountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Discount
     */
    select?: DiscountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Discount
     */
    omit?: DiscountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscountInclude<ExtArgs> | null
    where?: DiscountWhereInput
    orderBy?: DiscountOrderByWithRelationInput | DiscountOrderByWithRelationInput[]
    cursor?: DiscountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DiscountScalarFieldEnum | DiscountScalarFieldEnum[]
  }

  /**
   * OrderSession.taxDetails
   */
  export type OrderSession$taxDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TaxDetail
     */
    select?: TaxDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TaxDetail
     */
    omit?: TaxDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaxDetailInclude<ExtArgs> | null
    where?: TaxDetailWhereInput
    orderBy?: TaxDetailOrderByWithRelationInput | TaxDetailOrderByWithRelationInput[]
    cursor?: TaxDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaxDetailScalarFieldEnum | TaxDetailScalarFieldEnum[]
  }

  /**
   * OrderSession.paymentDetails
   */
  export type OrderSession$paymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentDetail
     */
    select?: PaymentDetailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PaymentDetail
     */
    omit?: PaymentDetailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentDetailInclude<ExtArgs> | null
    where?: PaymentDetailWhereInput
    orderBy?: PaymentDetailOrderByWithRelationInput | PaymentDetailOrderByWithRelationInput[]
    cursor?: PaymentDetailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentDetailScalarFieldEnum | PaymentDetailScalarFieldEnum[]
  }

  /**
   * OrderSession without action
   */
  export type OrderSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
  }


  /**
   * Model Shop
   */

  export type AggregateShop = {
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  export type ShopAvgAggregateOutputType = {
    taxRate: number | null
    utcOffset: number | null
    reportTime: number | null
  }

  export type ShopSumAggregateOutputType = {
    taxRate: number | null
    utcOffset: number | null
    reportTime: number | null
  }

  export type ShopMinAggregateOutputType = {
    status: $Enums.Status | null
    name: string | null
    phone: string | null
    email: string | null
    ownerId: string | null
    taxRate: number | null
    location: string | null
    dishPriceRoundingType: $Enums.RoundingPaymentType | null
    discountRoundingType: $Enums.RoundingPaymentType | null
    taxRoundingType: $Enums.RoundingPaymentType | null
    calculateTaxDirectly: boolean | null
    countryName: string | null
    countryCurrency: string | null
    utcOffset: number | null
    timezone: string | null
    reportTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type ShopMaxAggregateOutputType = {
    status: $Enums.Status | null
    name: string | null
    phone: string | null
    email: string | null
    ownerId: string | null
    taxRate: number | null
    location: string | null
    dishPriceRoundingType: $Enums.RoundingPaymentType | null
    discountRoundingType: $Enums.RoundingPaymentType | null
    taxRoundingType: $Enums.RoundingPaymentType | null
    calculateTaxDirectly: boolean | null
    countryName: string | null
    countryCurrency: string | null
    utcOffset: number | null
    timezone: string | null
    reportTime: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type ShopCountAggregateOutputType = {
    status: number
    name: number
    phone: number
    email: number
    ownerId: number
    taxRate: number
    location: number
    dishPriceRoundingType: number
    discountRoundingType: number
    taxRoundingType: number
    calculateTaxDirectly: number
    countryName: number
    countryCurrency: number
    utcOffset: number
    timezone: number
    reportTime: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type ShopAvgAggregateInputType = {
    taxRate?: true
    utcOffset?: true
    reportTime?: true
  }

  export type ShopSumAggregateInputType = {
    taxRate?: true
    utcOffset?: true
    reportTime?: true
  }

  export type ShopMinAggregateInputType = {
    status?: true
    name?: true
    phone?: true
    email?: true
    ownerId?: true
    taxRate?: true
    location?: true
    dishPriceRoundingType?: true
    discountRoundingType?: true
    taxRoundingType?: true
    calculateTaxDirectly?: true
    countryName?: true
    countryCurrency?: true
    utcOffset?: true
    timezone?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type ShopMaxAggregateInputType = {
    status?: true
    name?: true
    phone?: true
    email?: true
    ownerId?: true
    taxRate?: true
    location?: true
    dishPriceRoundingType?: true
    discountRoundingType?: true
    taxRoundingType?: true
    calculateTaxDirectly?: true
    countryName?: true
    countryCurrency?: true
    utcOffset?: true
    timezone?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type ShopCountAggregateInputType = {
    status?: true
    name?: true
    phone?: true
    email?: true
    ownerId?: true
    taxRate?: true
    location?: true
    dishPriceRoundingType?: true
    discountRoundingType?: true
    taxRoundingType?: true
    calculateTaxDirectly?: true
    countryName?: true
    countryCurrency?: true
    utcOffset?: true
    timezone?: true
    reportTime?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type ShopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shop to aggregate.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shops
    **/
    _count?: true | ShopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShopMaxAggregateInputType
  }

  export type GetShopAggregateType<T extends ShopAggregateArgs> = {
        [P in keyof T & keyof AggregateShop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShop[P]>
      : GetScalarType<T[P], AggregateShop[P]>
  }




  export type ShopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShopWhereInput
    orderBy?: ShopOrderByWithAggregationInput | ShopOrderByWithAggregationInput[]
    by: ShopScalarFieldEnum[] | ShopScalarFieldEnum
    having?: ShopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShopCountAggregateInputType | true
    _avg?: ShopAvgAggregateInputType
    _sum?: ShopSumAggregateInputType
    _min?: ShopMinAggregateInputType
    _max?: ShopMaxAggregateInputType
  }

  export type ShopGroupByOutputType = {
    status: $Enums.Status
    name: string | null
    phone: string | null
    email: string | null
    ownerId: string | null
    taxRate: number | null
    location: string | null
    dishPriceRoundingType: $Enums.RoundingPaymentType
    discountRoundingType: $Enums.RoundingPaymentType
    taxRoundingType: $Enums.RoundingPaymentType
    calculateTaxDirectly: boolean | null
    countryName: string | null
    countryCurrency: string | null
    utcOffset: number
    timezone: string
    reportTime: number
    createdAt: Date
    updatedAt: Date
    id: string
    _count: ShopCountAggregateOutputType | null
    _avg: ShopAvgAggregateOutputType | null
    _sum: ShopSumAggregateOutputType | null
    _min: ShopMinAggregateOutputType | null
    _max: ShopMaxAggregateOutputType | null
  }

  type GetShopGroupByPayload<T extends ShopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShopGroupByOutputType[P]>
            : GetScalarType<T[P], ShopGroupByOutputType[P]>
        }
      >
    >


  export type ShopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    ownerId?: boolean
    taxRate?: boolean
    location?: boolean
    dishPriceRoundingType?: boolean
    discountRoundingType?: boolean
    taxRoundingType?: boolean
    calculateTaxDirectly?: boolean
    countryName?: boolean
    countryCurrency?: boolean
    utcOffset?: boolean
    timezone?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    dish?: boolean | Shop$dishArgs<ExtArgs>
    dishCategory?: boolean | Shop$dishCategoryArgs<ExtArgs>
    employees?: boolean | Shop$employeesArgs<ExtArgs>
    employeeDepartments?: boolean | Shop$employeeDepartmentsArgs<ExtArgs>
    employeePositions?: boolean | Shop$employeePositionsArgs<ExtArgs>
    imageUrls?: boolean | Shop$imageUrlsArgs<ExtArgs>
    owner?: boolean | Shop$ownerArgs<ExtArgs>
    table?: boolean | Shop$tableArgs<ExtArgs>
    tablePosition?: boolean | Shop$tablePositionArgs<ExtArgs>
    unit?: boolean | Shop$unitArgs<ExtArgs>
    Kitchen?: boolean | Shop$KitchenArgs<ExtArgs>
    KitchenLog?: boolean | Shop$KitchenLogArgs<ExtArgs>
    Order?: boolean | Shop$OrderArgs<ExtArgs>
    OrderSession?: boolean | Shop$OrderSessionArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    ownerId?: boolean
    taxRate?: boolean
    location?: boolean
    dishPriceRoundingType?: boolean
    discountRoundingType?: boolean
    taxRoundingType?: boolean
    calculateTaxDirectly?: boolean
    countryName?: boolean
    countryCurrency?: boolean
    utcOffset?: boolean
    timezone?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    owner?: boolean | Shop$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    status?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    ownerId?: boolean
    taxRate?: boolean
    location?: boolean
    dishPriceRoundingType?: boolean
    discountRoundingType?: boolean
    taxRoundingType?: boolean
    calculateTaxDirectly?: boolean
    countryName?: boolean
    countryCurrency?: boolean
    utcOffset?: boolean
    timezone?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    owner?: boolean | Shop$ownerArgs<ExtArgs>
  }, ExtArgs["result"]["shop"]>

  export type ShopSelectScalar = {
    status?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    ownerId?: boolean
    taxRate?: boolean
    location?: boolean
    dishPriceRoundingType?: boolean
    discountRoundingType?: boolean
    taxRoundingType?: boolean
    calculateTaxDirectly?: boolean
    countryName?: boolean
    countryCurrency?: boolean
    utcOffset?: boolean
    timezone?: boolean
    reportTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type ShopOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"status" | "name" | "phone" | "email" | "ownerId" | "taxRate" | "location" | "dishPriceRoundingType" | "discountRoundingType" | "taxRoundingType" | "calculateTaxDirectly" | "countryName" | "countryCurrency" | "utcOffset" | "timezone" | "reportTime" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["shop"]>
  export type ShopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | Shop$dishArgs<ExtArgs>
    dishCategory?: boolean | Shop$dishCategoryArgs<ExtArgs>
    employees?: boolean | Shop$employeesArgs<ExtArgs>
    employeeDepartments?: boolean | Shop$employeeDepartmentsArgs<ExtArgs>
    employeePositions?: boolean | Shop$employeePositionsArgs<ExtArgs>
    imageUrls?: boolean | Shop$imageUrlsArgs<ExtArgs>
    owner?: boolean | Shop$ownerArgs<ExtArgs>
    table?: boolean | Shop$tableArgs<ExtArgs>
    tablePosition?: boolean | Shop$tablePositionArgs<ExtArgs>
    unit?: boolean | Shop$unitArgs<ExtArgs>
    Kitchen?: boolean | Shop$KitchenArgs<ExtArgs>
    KitchenLog?: boolean | Shop$KitchenLogArgs<ExtArgs>
    Order?: boolean | Shop$OrderArgs<ExtArgs>
    OrderSession?: boolean | Shop$OrderSessionArgs<ExtArgs>
    _count?: boolean | ShopCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Shop$ownerArgs<ExtArgs>
  }
  export type ShopIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | Shop$ownerArgs<ExtArgs>
  }

  export type $ShopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shop"
    objects: {
      dish: Prisma.$DishPayload<ExtArgs>[]
      dishCategory: Prisma.$DishCategoryPayload<ExtArgs>[]
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      employeeDepartments: Prisma.$EmployeeDepartmentPayload<ExtArgs>[]
      employeePositions: Prisma.$EmployeePositionPayload<ExtArgs>[]
      imageUrls: Prisma.$ImagePayload<ExtArgs>[]
      owner: Prisma.$UserPayload<ExtArgs> | null
      table: Prisma.$TablePayload<ExtArgs>[]
      tablePosition: Prisma.$TablePositionPayload<ExtArgs>[]
      unit: Prisma.$UnitPayload<ExtArgs>[]
      Kitchen: Prisma.$KitchenPayload<ExtArgs>[]
      KitchenLog: Prisma.$KitchenLogPayload<ExtArgs>[]
      Order: Prisma.$OrderPayload<ExtArgs>[]
      OrderSession: Prisma.$OrderSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      status: $Enums.Status
      name: string | null
      phone: string | null
      email: string | null
      ownerId: string | null
      taxRate: number | null
      location: string | null
      dishPriceRoundingType: $Enums.RoundingPaymentType
      discountRoundingType: $Enums.RoundingPaymentType
      taxRoundingType: $Enums.RoundingPaymentType
      calculateTaxDirectly: boolean | null
      countryName: string | null
      countryCurrency: string | null
      utcOffset: number
      timezone: string
      reportTime: number
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["shop"]>
    composites: {}
  }

  type ShopGetPayload<S extends boolean | null | undefined | ShopDefaultArgs> = $Result.GetResult<Prisma.$ShopPayload, S>

  type ShopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShopFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShopCountAggregateInputType | true
    }

  export interface ShopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shop'], meta: { name: 'Shop' } }
    /**
     * Find zero or one Shop that matches the filter.
     * @param {ShopFindUniqueArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShopFindUniqueArgs>(args: SelectSubset<T, ShopFindUniqueArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shop that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShopFindUniqueOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShopFindUniqueOrThrowArgs>(args: SelectSubset<T, ShopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShopFindFirstArgs>(args?: SelectSubset<T, ShopFindFirstArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindFirstOrThrowArgs} args - Arguments to find a Shop
     * @example
     * // Get one Shop
     * const shop = await prisma.shop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShopFindFirstOrThrowArgs>(args?: SelectSubset<T, ShopFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shops
     * const shops = await prisma.shop.findMany()
     * 
     * // Get first 10 Shops
     * const shops = await prisma.shop.findMany({ take: 10 })
     * 
     * // Only select the `name`
     * const shopWithNameOnly = await prisma.shop.findMany({ select: { name: true } })
     * 
     */
    findMany<T extends ShopFindManyArgs>(args?: SelectSubset<T, ShopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shop.
     * @param {ShopCreateArgs} args - Arguments to create a Shop.
     * @example
     * // Create one Shop
     * const Shop = await prisma.shop.create({
     *   data: {
     *     // ... data to create a Shop
     *   }
     * })
     * 
     */
    create<T extends ShopCreateArgs>(args: SelectSubset<T, ShopCreateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shops.
     * @param {ShopCreateManyArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShopCreateManyArgs>(args?: SelectSubset<T, ShopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shops and returns the data saved in the database.
     * @param {ShopCreateManyAndReturnArgs} args - Arguments to create many Shops.
     * @example
     * // Create many Shops
     * const shop = await prisma.shop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shops and only return the `name`
     * const shopWithNameOnly = await prisma.shop.createManyAndReturn({
     *   select: { name: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShopCreateManyAndReturnArgs>(args?: SelectSubset<T, ShopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shop.
     * @param {ShopDeleteArgs} args - Arguments to delete one Shop.
     * @example
     * // Delete one Shop
     * const Shop = await prisma.shop.delete({
     *   where: {
     *     // ... filter to delete one Shop
     *   }
     * })
     * 
     */
    delete<T extends ShopDeleteArgs>(args: SelectSubset<T, ShopDeleteArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shop.
     * @param {ShopUpdateArgs} args - Arguments to update one Shop.
     * @example
     * // Update one Shop
     * const shop = await prisma.shop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShopUpdateArgs>(args: SelectSubset<T, ShopUpdateArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shops.
     * @param {ShopDeleteManyArgs} args - Arguments to filter Shops to delete.
     * @example
     * // Delete a few Shops
     * const { count } = await prisma.shop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShopDeleteManyArgs>(args?: SelectSubset<T, ShopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShopUpdateManyArgs>(args: SelectSubset<T, ShopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shops and returns the data updated in the database.
     * @param {ShopUpdateManyAndReturnArgs} args - Arguments to update many Shops.
     * @example
     * // Update many Shops
     * const shop = await prisma.shop.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shops and only return the `name`
     * const shopWithNameOnly = await prisma.shop.updateManyAndReturn({
     *   select: { name: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShopUpdateManyAndReturnArgs>(args: SelectSubset<T, ShopUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shop.
     * @param {ShopUpsertArgs} args - Arguments to update or create a Shop.
     * @example
     * // Update or create a Shop
     * const shop = await prisma.shop.upsert({
     *   create: {
     *     // ... data to create a Shop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shop we want to update
     *   }
     * })
     */
    upsert<T extends ShopUpsertArgs>(args: SelectSubset<T, ShopUpsertArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopCountArgs} args - Arguments to filter Shops to count.
     * @example
     * // Count the number of Shops
     * const count = await prisma.shop.count({
     *   where: {
     *     // ... the filter for the Shops we want to count
     *   }
     * })
    **/
    count<T extends ShopCountArgs>(
      args?: Subset<T, ShopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShopAggregateArgs>(args: Subset<T, ShopAggregateArgs>): Prisma.PrismaPromise<GetShopAggregateType<T>>

    /**
     * Group by Shop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShopGroupByArgs['orderBy'] }
        : { orderBy?: ShopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shop model
   */
  readonly fields: ShopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dish<T extends Shop$dishArgs<ExtArgs> = {}>(args?: Subset<T, Shop$dishArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    dishCategory<T extends Shop$dishCategoryArgs<ExtArgs> = {}>(args?: Subset<T, Shop$dishCategoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employees<T extends Shop$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Shop$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeDepartments<T extends Shop$employeeDepartmentsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$employeeDepartmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeePositions<T extends Shop$employeePositionsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$employeePositionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageUrls<T extends Shop$imageUrlsArgs<ExtArgs> = {}>(args?: Subset<T, Shop$imageUrlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    owner<T extends Shop$ownerArgs<ExtArgs> = {}>(args?: Subset<T, Shop$ownerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    table<T extends Shop$tableArgs<ExtArgs> = {}>(args?: Subset<T, Shop$tableArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tablePosition<T extends Shop$tablePositionArgs<ExtArgs> = {}>(args?: Subset<T, Shop$tablePositionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    unit<T extends Shop$unitArgs<ExtArgs> = {}>(args?: Subset<T, Shop$unitArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Kitchen<T extends Shop$KitchenArgs<ExtArgs> = {}>(args?: Subset<T, Shop$KitchenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    KitchenLog<T extends Shop$KitchenLogArgs<ExtArgs> = {}>(args?: Subset<T, Shop$KitchenLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Order<T extends Shop$OrderArgs<ExtArgs> = {}>(args?: Subset<T, Shop$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    OrderSession<T extends Shop$OrderSessionArgs<ExtArgs> = {}>(args?: Subset<T, Shop$OrderSessionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderSessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shop model
   */
  interface ShopFieldRefs {
    readonly status: FieldRef<"Shop", 'Status'>
    readonly name: FieldRef<"Shop", 'String'>
    readonly phone: FieldRef<"Shop", 'String'>
    readonly email: FieldRef<"Shop", 'String'>
    readonly ownerId: FieldRef<"Shop", 'String'>
    readonly taxRate: FieldRef<"Shop", 'Float'>
    readonly location: FieldRef<"Shop", 'String'>
    readonly dishPriceRoundingType: FieldRef<"Shop", 'RoundingPaymentType'>
    readonly discountRoundingType: FieldRef<"Shop", 'RoundingPaymentType'>
    readonly taxRoundingType: FieldRef<"Shop", 'RoundingPaymentType'>
    readonly calculateTaxDirectly: FieldRef<"Shop", 'Boolean'>
    readonly countryName: FieldRef<"Shop", 'String'>
    readonly countryCurrency: FieldRef<"Shop", 'String'>
    readonly utcOffset: FieldRef<"Shop", 'Int'>
    readonly timezone: FieldRef<"Shop", 'String'>
    readonly reportTime: FieldRef<"Shop", 'Int'>
    readonly createdAt: FieldRef<"Shop", 'DateTime'>
    readonly updatedAt: FieldRef<"Shop", 'DateTime'>
    readonly id: FieldRef<"Shop", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Shop findUnique
   */
  export type ShopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findUniqueOrThrow
   */
  export type ShopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop findFirst
   */
  export type ShopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findFirstOrThrow
   */
  export type ShopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shop to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shops.
     */
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop findMany
   */
  export type ShopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter, which Shops to fetch.
     */
    where?: ShopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shops to fetch.
     */
    orderBy?: ShopOrderByWithRelationInput | ShopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shops.
     */
    cursor?: ShopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shops.
     */
    skip?: number
    distinct?: ShopScalarFieldEnum | ShopScalarFieldEnum[]
  }

  /**
   * Shop create
   */
  export type ShopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to create a Shop.
     */
    data: XOR<ShopCreateInput, ShopUncheckedCreateInput>
  }

  /**
   * Shop createMany
   */
  export type ShopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shop createManyAndReturn
   */
  export type ShopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * The data used to create many Shops.
     */
    data: ShopCreateManyInput | ShopCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop update
   */
  export type ShopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The data needed to update a Shop.
     */
    data: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
    /**
     * Choose, which Shop to update.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop updateMany
   */
  export type ShopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
  }

  /**
   * Shop updateManyAndReturn
   */
  export type ShopUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * The data used to update Shops.
     */
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyInput>
    /**
     * Filter which Shops to update
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shop upsert
   */
  export type ShopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * The filter to search for the Shop to update in case it exists.
     */
    where: ShopWhereUniqueInput
    /**
     * In case the Shop found by the `where` argument doesn't exist, create a new Shop with this data.
     */
    create: XOR<ShopCreateInput, ShopUncheckedCreateInput>
    /**
     * In case the Shop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShopUpdateInput, ShopUncheckedUpdateInput>
  }

  /**
   * Shop delete
   */
  export type ShopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    /**
     * Filter which Shop to delete.
     */
    where: ShopWhereUniqueInput
  }

  /**
   * Shop deleteMany
   */
  export type ShopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shops to delete
     */
    where?: ShopWhereInput
    /**
     * Limit how many Shops to delete.
     */
    limit?: number
  }

  /**
   * Shop.dish
   */
  export type Shop$dishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Shop.dishCategory
   */
  export type Shop$dishCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    where?: DishCategoryWhereInput
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    cursor?: DishCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishCategoryScalarFieldEnum | DishCategoryScalarFieldEnum[]
  }

  /**
   * Shop.employees
   */
  export type Shop$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Shop.employeeDepartments
   */
  export type Shop$employeeDepartmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    where?: EmployeeDepartmentWhereInput
    orderBy?: EmployeeDepartmentOrderByWithRelationInput | EmployeeDepartmentOrderByWithRelationInput[]
    cursor?: EmployeeDepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeDepartmentScalarFieldEnum | EmployeeDepartmentScalarFieldEnum[]
  }

  /**
   * Shop.employeePositions
   */
  export type Shop$employeePositionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    where?: EmployeePositionWhereInput
    orderBy?: EmployeePositionOrderByWithRelationInput | EmployeePositionOrderByWithRelationInput[]
    cursor?: EmployeePositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeePositionScalarFieldEnum | EmployeePositionScalarFieldEnum[]
  }

  /**
   * Shop.imageUrls
   */
  export type Shop$imageUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Shop.owner
   */
  export type Shop$ownerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Shop.table
   */
  export type Shop$tableArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Shop.tablePosition
   */
  export type Shop$tablePositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    where?: TablePositionWhereInput
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    cursor?: TablePositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TablePositionScalarFieldEnum | TablePositionScalarFieldEnum[]
  }

  /**
   * Shop.unit
   */
  export type Shop$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    cursor?: UnitWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Shop.Kitchen
   */
  export type Shop$KitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    where?: KitchenWhereInput
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    cursor?: KitchenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * Shop.KitchenLog
   */
  export type Shop$KitchenLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KitchenLog
     */
    select?: KitchenLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KitchenLog
     */
    omit?: KitchenLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenLogInclude<ExtArgs> | null
    where?: KitchenLogWhereInput
    orderBy?: KitchenLogOrderByWithRelationInput | KitchenLogOrderByWithRelationInput[]
    cursor?: KitchenLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenLogScalarFieldEnum | KitchenLogScalarFieldEnum[]
  }

  /**
   * Shop.Order
   */
  export type Shop$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Shop.OrderSession
   */
  export type Shop$OrderSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderSession
     */
    select?: OrderSessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OrderSession
     */
    omit?: OrderSessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderSessionInclude<ExtArgs> | null
    where?: OrderSessionWhereInput
    orderBy?: OrderSessionOrderByWithRelationInput | OrderSessionOrderByWithRelationInput[]
    cursor?: OrderSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderSessionScalarFieldEnum | OrderSessionScalarFieldEnum[]
  }

  /**
   * Shop without action
   */
  export type ShopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
  }


  /**
   * Model Image
   */

  export type AggregateImage = {
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  export type ImageMinAggregateOutputType = {
    url: string | null
    shopId: string | null
    dishId: string | null
    id: string | null
  }

  export type ImageMaxAggregateOutputType = {
    url: string | null
    shopId: string | null
    dishId: string | null
    id: string | null
  }

  export type ImageCountAggregateOutputType = {
    url: number
    shopId: number
    dishId: number
    id: number
    _all: number
  }


  export type ImageMinAggregateInputType = {
    url?: true
    shopId?: true
    dishId?: true
    id?: true
  }

  export type ImageMaxAggregateInputType = {
    url?: true
    shopId?: true
    dishId?: true
    id?: true
  }

  export type ImageCountAggregateInputType = {
    url?: true
    shopId?: true
    dishId?: true
    id?: true
    _all?: true
  }

  export type ImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Image to aggregate.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Images
    **/
    _count?: true | ImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ImageMaxAggregateInputType
  }

  export type GetImageAggregateType<T extends ImageAggregateArgs> = {
        [P in keyof T & keyof AggregateImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateImage[P]>
      : GetScalarType<T[P], AggregateImage[P]>
  }




  export type ImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithAggregationInput | ImageOrderByWithAggregationInput[]
    by: ImageScalarFieldEnum[] | ImageScalarFieldEnum
    having?: ImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ImageCountAggregateInputType | true
    _min?: ImageMinAggregateInputType
    _max?: ImageMaxAggregateInputType
  }

  export type ImageGroupByOutputType = {
    url: string
    shopId: string | null
    dishId: string | null
    id: string
    _count: ImageCountAggregateOutputType | null
    _min: ImageMinAggregateOutputType | null
    _max: ImageMaxAggregateOutputType | null
  }

  type GetImageGroupByPayload<T extends ImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ImageGroupByOutputType[P]>
            : GetScalarType<T[P], ImageGroupByOutputType[P]>
        }
      >
    >


  export type ImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    url?: boolean
    shopId?: boolean
    dishId?: boolean
    id?: boolean
    dish?: boolean | Image$dishArgs<ExtArgs>
    shop?: boolean | Image$shopArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    url?: boolean
    shopId?: boolean
    dishId?: boolean
    id?: boolean
    dish?: boolean | Image$dishArgs<ExtArgs>
    shop?: boolean | Image$shopArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    url?: boolean
    shopId?: boolean
    dishId?: boolean
    id?: boolean
    dish?: boolean | Image$dishArgs<ExtArgs>
    shop?: boolean | Image$shopArgs<ExtArgs>
  }, ExtArgs["result"]["image"]>

  export type ImageSelectScalar = {
    url?: boolean
    shopId?: boolean
    dishId?: boolean
    id?: boolean
  }

  export type ImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"url" | "shopId" | "dishId" | "id", ExtArgs["result"]["image"]>
  export type ImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | Image$dishArgs<ExtArgs>
    shop?: boolean | Image$shopArgs<ExtArgs>
  }
  export type ImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | Image$dishArgs<ExtArgs>
    shop?: boolean | Image$shopArgs<ExtArgs>
  }
  export type ImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | Image$dishArgs<ExtArgs>
    shop?: boolean | Image$shopArgs<ExtArgs>
  }

  export type $ImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Image"
    objects: {
      dish: Prisma.$DishPayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      url: string
      shopId: string | null
      dishId: string | null
      id: string
    }, ExtArgs["result"]["image"]>
    composites: {}
  }

  type ImageGetPayload<S extends boolean | null | undefined | ImageDefaultArgs> = $Result.GetResult<Prisma.$ImagePayload, S>

  type ImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ImageCountAggregateInputType | true
    }

  export interface ImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Image'], meta: { name: 'Image' } }
    /**
     * Find zero or one Image that matches the filter.
     * @param {ImageFindUniqueArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ImageFindUniqueArgs>(args: SelectSubset<T, ImageFindUniqueArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Image that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ImageFindUniqueOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ImageFindFirstArgs>(args?: SelectSubset<T, ImageFindFirstArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Image that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindFirstOrThrowArgs} args - Arguments to find a Image
     * @example
     * // Get one Image
     * const image = await prisma.image.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Images
     * const images = await prisma.image.findMany()
     * 
     * // Get first 10 Images
     * const images = await prisma.image.findMany({ take: 10 })
     * 
     * // Only select the `url`
     * const imageWithUrlOnly = await prisma.image.findMany({ select: { url: true } })
     * 
     */
    findMany<T extends ImageFindManyArgs>(args?: SelectSubset<T, ImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Image.
     * @param {ImageCreateArgs} args - Arguments to create a Image.
     * @example
     * // Create one Image
     * const Image = await prisma.image.create({
     *   data: {
     *     // ... data to create a Image
     *   }
     * })
     * 
     */
    create<T extends ImageCreateArgs>(args: SelectSubset<T, ImageCreateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Images.
     * @param {ImageCreateManyArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ImageCreateManyArgs>(args?: SelectSubset<T, ImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Images and returns the data saved in the database.
     * @param {ImageCreateManyAndReturnArgs} args - Arguments to create many Images.
     * @example
     * // Create many Images
     * const image = await prisma.image.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Images and only return the `url`
     * const imageWithUrlOnly = await prisma.image.createManyAndReturn({
     *   select: { url: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Image.
     * @param {ImageDeleteArgs} args - Arguments to delete one Image.
     * @example
     * // Delete one Image
     * const Image = await prisma.image.delete({
     *   where: {
     *     // ... filter to delete one Image
     *   }
     * })
     * 
     */
    delete<T extends ImageDeleteArgs>(args: SelectSubset<T, ImageDeleteArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Image.
     * @param {ImageUpdateArgs} args - Arguments to update one Image.
     * @example
     * // Update one Image
     * const image = await prisma.image.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ImageUpdateArgs>(args: SelectSubset<T, ImageUpdateArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Images.
     * @param {ImageDeleteManyArgs} args - Arguments to filter Images to delete.
     * @example
     * // Delete a few Images
     * const { count } = await prisma.image.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ImageDeleteManyArgs>(args?: SelectSubset<T, ImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ImageUpdateManyArgs>(args: SelectSubset<T, ImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Images and returns the data updated in the database.
     * @param {ImageUpdateManyAndReturnArgs} args - Arguments to update many Images.
     * @example
     * // Update many Images
     * const image = await prisma.image.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Images and only return the `url`
     * const imageWithUrlOnly = await prisma.image.updateManyAndReturn({
     *   select: { url: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Image.
     * @param {ImageUpsertArgs} args - Arguments to update or create a Image.
     * @example
     * // Update or create a Image
     * const image = await prisma.image.upsert({
     *   create: {
     *     // ... data to create a Image
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Image we want to update
     *   }
     * })
     */
    upsert<T extends ImageUpsertArgs>(args: SelectSubset<T, ImageUpsertArgs<ExtArgs>>): Prisma__ImageClient<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageCountArgs} args - Arguments to filter Images to count.
     * @example
     * // Count the number of Images
     * const count = await prisma.image.count({
     *   where: {
     *     // ... the filter for the Images we want to count
     *   }
     * })
    **/
    count<T extends ImageCountArgs>(
      args?: Subset<T, ImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ImageAggregateArgs>(args: Subset<T, ImageAggregateArgs>): Prisma.PrismaPromise<GetImageAggregateType<T>>

    /**
     * Group by Image.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ImageGroupByArgs['orderBy'] }
        : { orderBy?: ImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Image model
   */
  readonly fields: ImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Image.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dish<T extends Image$dishArgs<ExtArgs> = {}>(args?: Subset<T, Image$dishArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends Image$shopArgs<ExtArgs> = {}>(args?: Subset<T, Image$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Image model
   */
  interface ImageFieldRefs {
    readonly url: FieldRef<"Image", 'String'>
    readonly shopId: FieldRef<"Image", 'String'>
    readonly dishId: FieldRef<"Image", 'String'>
    readonly id: FieldRef<"Image", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Image findUnique
   */
  export type ImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findUniqueOrThrow
   */
  export type ImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image findFirst
   */
  export type ImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findFirstOrThrow
   */
  export type ImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Image to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Images.
     */
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image findMany
   */
  export type ImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter, which Images to fetch.
     */
    where?: ImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Images to fetch.
     */
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Images.
     */
    cursor?: ImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Images.
     */
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Image create
   */
  export type ImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to create a Image.
     */
    data: XOR<ImageCreateInput, ImageUncheckedCreateInput>
  }

  /**
   * Image createMany
   */
  export type ImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Image createManyAndReturn
   */
  export type ImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to create many Images.
     */
    data: ImageCreateManyInput | ImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image update
   */
  export type ImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The data needed to update a Image.
     */
    data: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
    /**
     * Choose, which Image to update.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image updateMany
   */
  export type ImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
  }

  /**
   * Image updateManyAndReturn
   */
  export type ImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * The data used to update Images.
     */
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyInput>
    /**
     * Filter which Images to update
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Image upsert
   */
  export type ImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * The filter to search for the Image to update in case it exists.
     */
    where: ImageWhereUniqueInput
    /**
     * In case the Image found by the `where` argument doesn't exist, create a new Image with this data.
     */
    create: XOR<ImageCreateInput, ImageUncheckedCreateInput>
    /**
     * In case the Image was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ImageUpdateInput, ImageUncheckedUpdateInput>
  }

  /**
   * Image delete
   */
  export type ImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    /**
     * Filter which Image to delete.
     */
    where: ImageWhereUniqueInput
  }

  /**
   * Image deleteMany
   */
  export type ImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Images to delete
     */
    where?: ImageWhereInput
    /**
     * Limit how many Images to delete.
     */
    limit?: number
  }

  /**
   * Image.dish
   */
  export type Image$dishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
  }

  /**
   * Image.shop
   */
  export type Image$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Image without action
   */
  export type ImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
  }


  /**
   * Model DishCategory
   */

  export type AggregateDishCategory = {
    _count: DishCategoryCountAggregateOutputType | null
    _min: DishCategoryMinAggregateOutputType | null
    _max: DishCategoryMaxAggregateOutputType | null
  }

  export type DishCategoryMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type DishCategoryMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type DishCategoryCountAggregateOutputType = {
    shopId: number
    name: number
    code: number
    status: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type DishCategoryMinAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type DishCategoryMaxAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type DishCategoryCountAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type DishCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DishCategory to aggregate.
     */
    where?: DishCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishCategories to fetch.
     */
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DishCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DishCategories
    **/
    _count?: true | DishCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DishCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DishCategoryMaxAggregateInputType
  }

  export type GetDishCategoryAggregateType<T extends DishCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateDishCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDishCategory[P]>
      : GetScalarType<T[P], AggregateDishCategory[P]>
  }




  export type DishCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishCategoryWhereInput
    orderBy?: DishCategoryOrderByWithAggregationInput | DishCategoryOrderByWithAggregationInput[]
    by: DishCategoryScalarFieldEnum[] | DishCategoryScalarFieldEnum
    having?: DishCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DishCategoryCountAggregateInputType | true
    _min?: DishCategoryMinAggregateInputType
    _max?: DishCategoryMaxAggregateInputType
  }

  export type DishCategoryGroupByOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    id: string
    _count: DishCategoryCountAggregateOutputType | null
    _min: DishCategoryMinAggregateOutputType | null
    _max: DishCategoryMaxAggregateOutputType | null
  }

  type GetDishCategoryGroupByPayload<T extends DishCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DishCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DishCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DishCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], DishCategoryGroupByOutputType[P]>
        }
      >
    >


  export type DishCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    dish?: boolean | DishCategory$dishArgs<ExtArgs>
    shop?: boolean | DishCategory$shopArgs<ExtArgs>
    tablePosition?: boolean | DishCategory$tablePositionArgs<ExtArgs>
    kitchen?: boolean | DishCategory$kitchenArgs<ExtArgs>
    _count?: boolean | DishCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dishCategory"]>

  export type DishCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | DishCategory$shopArgs<ExtArgs>
  }, ExtArgs["result"]["dishCategory"]>

  export type DishCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | DishCategory$shopArgs<ExtArgs>
  }, ExtArgs["result"]["dishCategory"]>

  export type DishCategorySelectScalar = {
    shopId?: boolean
    name?: boolean
    code?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type DishCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "code" | "status" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["dishCategory"]>
  export type DishCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | DishCategory$dishArgs<ExtArgs>
    shop?: boolean | DishCategory$shopArgs<ExtArgs>
    tablePosition?: boolean | DishCategory$tablePositionArgs<ExtArgs>
    kitchen?: boolean | DishCategory$kitchenArgs<ExtArgs>
    _count?: boolean | DishCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DishCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | DishCategory$shopArgs<ExtArgs>
  }
  export type DishCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | DishCategory$shopArgs<ExtArgs>
  }

  export type $DishCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DishCategory"
    objects: {
      dish: Prisma.$DishPayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs> | null
      tablePosition: Prisma.$TablePositionPayload<ExtArgs>[]
      kitchen: Prisma.$KitchenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string | null
      name: string | null
      code: string | null
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["dishCategory"]>
    composites: {}
  }

  type DishCategoryGetPayload<S extends boolean | null | undefined | DishCategoryDefaultArgs> = $Result.GetResult<Prisma.$DishCategoryPayload, S>

  type DishCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DishCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DishCategoryCountAggregateInputType | true
    }

  export interface DishCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DishCategory'], meta: { name: 'DishCategory' } }
    /**
     * Find zero or one DishCategory that matches the filter.
     * @param {DishCategoryFindUniqueArgs} args - Arguments to find a DishCategory
     * @example
     * // Get one DishCategory
     * const dishCategory = await prisma.dishCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DishCategoryFindUniqueArgs>(args: SelectSubset<T, DishCategoryFindUniqueArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DishCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DishCategoryFindUniqueOrThrowArgs} args - Arguments to find a DishCategory
     * @example
     * // Get one DishCategory
     * const dishCategory = await prisma.dishCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DishCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, DishCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DishCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryFindFirstArgs} args - Arguments to find a DishCategory
     * @example
     * // Get one DishCategory
     * const dishCategory = await prisma.dishCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DishCategoryFindFirstArgs>(args?: SelectSubset<T, DishCategoryFindFirstArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DishCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryFindFirstOrThrowArgs} args - Arguments to find a DishCategory
     * @example
     * // Get one DishCategory
     * const dishCategory = await prisma.dishCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DishCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, DishCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DishCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DishCategories
     * const dishCategories = await prisma.dishCategory.findMany()
     * 
     * // Get first 10 DishCategories
     * const dishCategories = await prisma.dishCategory.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const dishCategoryWithShopIdOnly = await prisma.dishCategory.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends DishCategoryFindManyArgs>(args?: SelectSubset<T, DishCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DishCategory.
     * @param {DishCategoryCreateArgs} args - Arguments to create a DishCategory.
     * @example
     * // Create one DishCategory
     * const DishCategory = await prisma.dishCategory.create({
     *   data: {
     *     // ... data to create a DishCategory
     *   }
     * })
     * 
     */
    create<T extends DishCategoryCreateArgs>(args: SelectSubset<T, DishCategoryCreateArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DishCategories.
     * @param {DishCategoryCreateManyArgs} args - Arguments to create many DishCategories.
     * @example
     * // Create many DishCategories
     * const dishCategory = await prisma.dishCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DishCategoryCreateManyArgs>(args?: SelectSubset<T, DishCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DishCategories and returns the data saved in the database.
     * @param {DishCategoryCreateManyAndReturnArgs} args - Arguments to create many DishCategories.
     * @example
     * // Create many DishCategories
     * const dishCategory = await prisma.dishCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DishCategories and only return the `shopId`
     * const dishCategoryWithShopIdOnly = await prisma.dishCategory.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DishCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, DishCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DishCategory.
     * @param {DishCategoryDeleteArgs} args - Arguments to delete one DishCategory.
     * @example
     * // Delete one DishCategory
     * const DishCategory = await prisma.dishCategory.delete({
     *   where: {
     *     // ... filter to delete one DishCategory
     *   }
     * })
     * 
     */
    delete<T extends DishCategoryDeleteArgs>(args: SelectSubset<T, DishCategoryDeleteArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DishCategory.
     * @param {DishCategoryUpdateArgs} args - Arguments to update one DishCategory.
     * @example
     * // Update one DishCategory
     * const dishCategory = await prisma.dishCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DishCategoryUpdateArgs>(args: SelectSubset<T, DishCategoryUpdateArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DishCategories.
     * @param {DishCategoryDeleteManyArgs} args - Arguments to filter DishCategories to delete.
     * @example
     * // Delete a few DishCategories
     * const { count } = await prisma.dishCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DishCategoryDeleteManyArgs>(args?: SelectSubset<T, DishCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DishCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DishCategories
     * const dishCategory = await prisma.dishCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DishCategoryUpdateManyArgs>(args: SelectSubset<T, DishCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DishCategories and returns the data updated in the database.
     * @param {DishCategoryUpdateManyAndReturnArgs} args - Arguments to update many DishCategories.
     * @example
     * // Update many DishCategories
     * const dishCategory = await prisma.dishCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DishCategories and only return the `shopId`
     * const dishCategoryWithShopIdOnly = await prisma.dishCategory.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DishCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, DishCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DishCategory.
     * @param {DishCategoryUpsertArgs} args - Arguments to update or create a DishCategory.
     * @example
     * // Update or create a DishCategory
     * const dishCategory = await prisma.dishCategory.upsert({
     *   create: {
     *     // ... data to create a DishCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DishCategory we want to update
     *   }
     * })
     */
    upsert<T extends DishCategoryUpsertArgs>(args: SelectSubset<T, DishCategoryUpsertArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DishCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryCountArgs} args - Arguments to filter DishCategories to count.
     * @example
     * // Count the number of DishCategories
     * const count = await prisma.dishCategory.count({
     *   where: {
     *     // ... the filter for the DishCategories we want to count
     *   }
     * })
    **/
    count<T extends DishCategoryCountArgs>(
      args?: Subset<T, DishCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DishCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DishCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DishCategoryAggregateArgs>(args: Subset<T, DishCategoryAggregateArgs>): Prisma.PrismaPromise<GetDishCategoryAggregateType<T>>

    /**
     * Group by DishCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DishCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DishCategoryGroupByArgs['orderBy'] }
        : { orderBy?: DishCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DishCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDishCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DishCategory model
   */
  readonly fields: DishCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DishCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DishCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dish<T extends DishCategory$dishArgs<ExtArgs> = {}>(args?: Subset<T, DishCategory$dishArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends DishCategory$shopArgs<ExtArgs> = {}>(args?: Subset<T, DishCategory$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tablePosition<T extends DishCategory$tablePositionArgs<ExtArgs> = {}>(args?: Subset<T, DishCategory$tablePositionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    kitchen<T extends DishCategory$kitchenArgs<ExtArgs> = {}>(args?: Subset<T, DishCategory$kitchenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DishCategory model
   */
  interface DishCategoryFieldRefs {
    readonly shopId: FieldRef<"DishCategory", 'String'>
    readonly name: FieldRef<"DishCategory", 'String'>
    readonly code: FieldRef<"DishCategory", 'String'>
    readonly status: FieldRef<"DishCategory", 'Status'>
    readonly createdAt: FieldRef<"DishCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"DishCategory", 'DateTime'>
    readonly id: FieldRef<"DishCategory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DishCategory findUnique
   */
  export type DishCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DishCategory to fetch.
     */
    where: DishCategoryWhereUniqueInput
  }

  /**
   * DishCategory findUniqueOrThrow
   */
  export type DishCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DishCategory to fetch.
     */
    where: DishCategoryWhereUniqueInput
  }

  /**
   * DishCategory findFirst
   */
  export type DishCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DishCategory to fetch.
     */
    where?: DishCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishCategories to fetch.
     */
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DishCategories.
     */
    cursor?: DishCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DishCategories.
     */
    distinct?: DishCategoryScalarFieldEnum | DishCategoryScalarFieldEnum[]
  }

  /**
   * DishCategory findFirstOrThrow
   */
  export type DishCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DishCategory to fetch.
     */
    where?: DishCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishCategories to fetch.
     */
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DishCategories.
     */
    cursor?: DishCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DishCategories.
     */
    distinct?: DishCategoryScalarFieldEnum | DishCategoryScalarFieldEnum[]
  }

  /**
   * DishCategory findMany
   */
  export type DishCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * Filter, which DishCategories to fetch.
     */
    where?: DishCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DishCategories to fetch.
     */
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DishCategories.
     */
    cursor?: DishCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DishCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DishCategories.
     */
    skip?: number
    distinct?: DishCategoryScalarFieldEnum | DishCategoryScalarFieldEnum[]
  }

  /**
   * DishCategory create
   */
  export type DishCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a DishCategory.
     */
    data: XOR<DishCategoryCreateInput, DishCategoryUncheckedCreateInput>
  }

  /**
   * DishCategory createMany
   */
  export type DishCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DishCategories.
     */
    data: DishCategoryCreateManyInput | DishCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DishCategory createManyAndReturn
   */
  export type DishCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many DishCategories.
     */
    data: DishCategoryCreateManyInput | DishCategoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DishCategory update
   */
  export type DishCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a DishCategory.
     */
    data: XOR<DishCategoryUpdateInput, DishCategoryUncheckedUpdateInput>
    /**
     * Choose, which DishCategory to update.
     */
    where: DishCategoryWhereUniqueInput
  }

  /**
   * DishCategory updateMany
   */
  export type DishCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DishCategories.
     */
    data: XOR<DishCategoryUpdateManyMutationInput, DishCategoryUncheckedUpdateManyInput>
    /**
     * Filter which DishCategories to update
     */
    where?: DishCategoryWhereInput
    /**
     * Limit how many DishCategories to update.
     */
    limit?: number
  }

  /**
   * DishCategory updateManyAndReturn
   */
  export type DishCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * The data used to update DishCategories.
     */
    data: XOR<DishCategoryUpdateManyMutationInput, DishCategoryUncheckedUpdateManyInput>
    /**
     * Filter which DishCategories to update
     */
    where?: DishCategoryWhereInput
    /**
     * Limit how many DishCategories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DishCategory upsert
   */
  export type DishCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the DishCategory to update in case it exists.
     */
    where: DishCategoryWhereUniqueInput
    /**
     * In case the DishCategory found by the `where` argument doesn't exist, create a new DishCategory with this data.
     */
    create: XOR<DishCategoryCreateInput, DishCategoryUncheckedCreateInput>
    /**
     * In case the DishCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DishCategoryUpdateInput, DishCategoryUncheckedUpdateInput>
  }

  /**
   * DishCategory delete
   */
  export type DishCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    /**
     * Filter which DishCategory to delete.
     */
    where: DishCategoryWhereUniqueInput
  }

  /**
   * DishCategory deleteMany
   */
  export type DishCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DishCategories to delete
     */
    where?: DishCategoryWhereInput
    /**
     * Limit how many DishCategories to delete.
     */
    limit?: number
  }

  /**
   * DishCategory.dish
   */
  export type DishCategory$dishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * DishCategory.shop
   */
  export type DishCategory$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * DishCategory.tablePosition
   */
  export type DishCategory$tablePositionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    where?: TablePositionWhereInput
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    cursor?: TablePositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TablePositionScalarFieldEnum | TablePositionScalarFieldEnum[]
  }

  /**
   * DishCategory.kitchen
   */
  export type DishCategory$kitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    where?: KitchenWhereInput
    orderBy?: KitchenOrderByWithRelationInput | KitchenOrderByWithRelationInput[]
    cursor?: KitchenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: KitchenScalarFieldEnum | KitchenScalarFieldEnum[]
  }

  /**
   * DishCategory without action
   */
  export type DishCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Dish
   */

  export type AggregateDish = {
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  export type DishAvgAggregateOutputType = {
    price: number | null
    taxIncludedPrice: number | null
    taxRate: number | null
    stockQuantity: number | null
    soldCount: number | null
  }

  export type DishSumAggregateOutputType = {
    price: number | null
    taxIncludedPrice: number | null
    taxRate: number | null
    stockQuantity: number | null
    soldCount: number | null
  }

  export type DishMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    unitId: string | null
    price: number | null
    taxIncludedPrice: number | null
    isTaxIncludedPrice: boolean | null
    categoryId: string | null
    type: string | null
    taxRate: number | null
    status: $Enums.Switchabletatus | null
    isNewlyCreated: boolean | null
    isBestSeller: boolean | null
    stockQuantity: number | null
    hideForCustomers: boolean | null
    hideForEmployees: boolean | null
    outOfStockNotification: boolean | null
    description: string | null
    soldCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type DishMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    unitId: string | null
    price: number | null
    taxIncludedPrice: number | null
    isTaxIncludedPrice: boolean | null
    categoryId: string | null
    type: string | null
    taxRate: number | null
    status: $Enums.Switchabletatus | null
    isNewlyCreated: boolean | null
    isBestSeller: boolean | null
    stockQuantity: number | null
    hideForCustomers: boolean | null
    hideForEmployees: boolean | null
    outOfStockNotification: boolean | null
    description: string | null
    soldCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type DishCountAggregateOutputType = {
    shopId: number
    name: number
    code: number
    unitId: number
    price: number
    taxIncludedPrice: number
    isTaxIncludedPrice: number
    categoryId: number
    type: number
    taxRate: number
    status: number
    isNewlyCreated: number
    isBestSeller: number
    stockQuantity: number
    hideForCustomers: number
    hideForEmployees: number
    outOfStockNotification: number
    description: number
    soldCount: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type DishAvgAggregateInputType = {
    price?: true
    taxIncludedPrice?: true
    taxRate?: true
    stockQuantity?: true
    soldCount?: true
  }

  export type DishSumAggregateInputType = {
    price?: true
    taxIncludedPrice?: true
    taxRate?: true
    stockQuantity?: true
    soldCount?: true
  }

  export type DishMinAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    unitId?: true
    price?: true
    taxIncludedPrice?: true
    isTaxIncludedPrice?: true
    categoryId?: true
    type?: true
    taxRate?: true
    status?: true
    isNewlyCreated?: true
    isBestSeller?: true
    stockQuantity?: true
    hideForCustomers?: true
    hideForEmployees?: true
    outOfStockNotification?: true
    description?: true
    soldCount?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type DishMaxAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    unitId?: true
    price?: true
    taxIncludedPrice?: true
    isTaxIncludedPrice?: true
    categoryId?: true
    type?: true
    taxRate?: true
    status?: true
    isNewlyCreated?: true
    isBestSeller?: true
    stockQuantity?: true
    hideForCustomers?: true
    hideForEmployees?: true
    outOfStockNotification?: true
    description?: true
    soldCount?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type DishCountAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    unitId?: true
    price?: true
    taxIncludedPrice?: true
    isTaxIncludedPrice?: true
    categoryId?: true
    type?: true
    taxRate?: true
    status?: true
    isNewlyCreated?: true
    isBestSeller?: true
    stockQuantity?: true
    hideForCustomers?: true
    hideForEmployees?: true
    outOfStockNotification?: true
    description?: true
    soldCount?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type DishAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dish to aggregate.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Dishes
    **/
    _count?: true | DishCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DishAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DishSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DishMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DishMaxAggregateInputType
  }

  export type GetDishAggregateType<T extends DishAggregateArgs> = {
        [P in keyof T & keyof AggregateDish]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDish[P]>
      : GetScalarType<T[P], AggregateDish[P]>
  }




  export type DishGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DishWhereInput
    orderBy?: DishOrderByWithAggregationInput | DishOrderByWithAggregationInput[]
    by: DishScalarFieldEnum[] | DishScalarFieldEnum
    having?: DishScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DishCountAggregateInputType | true
    _avg?: DishAvgAggregateInputType
    _sum?: DishSumAggregateInputType
    _min?: DishMinAggregateInputType
    _max?: DishMaxAggregateInputType
  }

  export type DishGroupByOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    unitId: string | null
    price: number | null
    taxIncludedPrice: number | null
    isTaxIncludedPrice: boolean | null
    categoryId: string | null
    type: string | null
    taxRate: number | null
    status: $Enums.Switchabletatus
    isNewlyCreated: boolean
    isBestSeller: boolean | null
    stockQuantity: number | null
    hideForCustomers: boolean | null
    hideForEmployees: boolean | null
    outOfStockNotification: boolean | null
    description: string | null
    soldCount: number | null
    createdAt: Date
    updatedAt: Date
    id: string
    _count: DishCountAggregateOutputType | null
    _avg: DishAvgAggregateOutputType | null
    _sum: DishSumAggregateOutputType | null
    _min: DishMinAggregateOutputType | null
    _max: DishMaxAggregateOutputType | null
  }

  type GetDishGroupByPayload<T extends DishGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DishGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DishGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DishGroupByOutputType[P]>
            : GetScalarType<T[P], DishGroupByOutputType[P]>
        }
      >
    >


  export type DishSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    unitId?: boolean
    price?: boolean
    taxIncludedPrice?: boolean
    isTaxIncludedPrice?: boolean
    categoryId?: boolean
    type?: boolean
    taxRate?: boolean
    status?: boolean
    isNewlyCreated?: boolean
    isBestSeller?: boolean
    stockQuantity?: boolean
    hideForCustomers?: boolean
    hideForEmployees?: boolean
    outOfStockNotification?: boolean
    description?: boolean
    soldCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    category?: boolean | Dish$categoryArgs<ExtArgs>
    shop?: boolean | Dish$shopArgs<ExtArgs>
    unit?: boolean | Dish$unitArgs<ExtArgs>
    imageUrls?: boolean | Dish$imageUrlsArgs<ExtArgs>
    _count?: boolean | DishCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    unitId?: boolean
    price?: boolean
    taxIncludedPrice?: boolean
    isTaxIncludedPrice?: boolean
    categoryId?: boolean
    type?: boolean
    taxRate?: boolean
    status?: boolean
    isNewlyCreated?: boolean
    isBestSeller?: boolean
    stockQuantity?: boolean
    hideForCustomers?: boolean
    hideForEmployees?: boolean
    outOfStockNotification?: boolean
    description?: boolean
    soldCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    category?: boolean | Dish$categoryArgs<ExtArgs>
    shop?: boolean | Dish$shopArgs<ExtArgs>
    unit?: boolean | Dish$unitArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    unitId?: boolean
    price?: boolean
    taxIncludedPrice?: boolean
    isTaxIncludedPrice?: boolean
    categoryId?: boolean
    type?: boolean
    taxRate?: boolean
    status?: boolean
    isNewlyCreated?: boolean
    isBestSeller?: boolean
    stockQuantity?: boolean
    hideForCustomers?: boolean
    hideForEmployees?: boolean
    outOfStockNotification?: boolean
    description?: boolean
    soldCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    category?: boolean | Dish$categoryArgs<ExtArgs>
    shop?: boolean | Dish$shopArgs<ExtArgs>
    unit?: boolean | Dish$unitArgs<ExtArgs>
  }, ExtArgs["result"]["dish"]>

  export type DishSelectScalar = {
    shopId?: boolean
    name?: boolean
    code?: boolean
    unitId?: boolean
    price?: boolean
    taxIncludedPrice?: boolean
    isTaxIncludedPrice?: boolean
    categoryId?: boolean
    type?: boolean
    taxRate?: boolean
    status?: boolean
    isNewlyCreated?: boolean
    isBestSeller?: boolean
    stockQuantity?: boolean
    hideForCustomers?: boolean
    hideForEmployees?: boolean
    outOfStockNotification?: boolean
    description?: boolean
    soldCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type DishOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "code" | "unitId" | "price" | "taxIncludedPrice" | "isTaxIncludedPrice" | "categoryId" | "type" | "taxRate" | "status" | "isNewlyCreated" | "isBestSeller" | "stockQuantity" | "hideForCustomers" | "hideForEmployees" | "outOfStockNotification" | "description" | "soldCount" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["dish"]>
  export type DishInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Dish$categoryArgs<ExtArgs>
    shop?: boolean | Dish$shopArgs<ExtArgs>
    unit?: boolean | Dish$unitArgs<ExtArgs>
    imageUrls?: boolean | Dish$imageUrlsArgs<ExtArgs>
    _count?: boolean | DishCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DishIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Dish$categoryArgs<ExtArgs>
    shop?: boolean | Dish$shopArgs<ExtArgs>
    unit?: boolean | Dish$unitArgs<ExtArgs>
  }
  export type DishIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | Dish$categoryArgs<ExtArgs>
    shop?: boolean | Dish$shopArgs<ExtArgs>
    unit?: boolean | Dish$unitArgs<ExtArgs>
  }

  export type $DishPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Dish"
    objects: {
      category: Prisma.$DishCategoryPayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs> | null
      unit: Prisma.$UnitPayload<ExtArgs> | null
      imageUrls: Prisma.$ImagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string | null
      name: string | null
      code: string | null
      unitId: string | null
      price: number | null
      taxIncludedPrice: number | null
      isTaxIncludedPrice: boolean | null
      categoryId: string | null
      type: string | null
      taxRate: number | null
      status: $Enums.Switchabletatus
      isNewlyCreated: boolean
      isBestSeller: boolean | null
      stockQuantity: number | null
      hideForCustomers: boolean | null
      hideForEmployees: boolean | null
      outOfStockNotification: boolean | null
      description: string | null
      soldCount: number | null
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["dish"]>
    composites: {}
  }

  type DishGetPayload<S extends boolean | null | undefined | DishDefaultArgs> = $Result.GetResult<Prisma.$DishPayload, S>

  type DishCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DishFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DishCountAggregateInputType | true
    }

  export interface DishDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Dish'], meta: { name: 'Dish' } }
    /**
     * Find zero or one Dish that matches the filter.
     * @param {DishFindUniqueArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DishFindUniqueArgs>(args: SelectSubset<T, DishFindUniqueArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Dish that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DishFindUniqueOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DishFindUniqueOrThrowArgs>(args: SelectSubset<T, DishFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dish that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindFirstArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DishFindFirstArgs>(args?: SelectSubset<T, DishFindFirstArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Dish that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindFirstOrThrowArgs} args - Arguments to find a Dish
     * @example
     * // Get one Dish
     * const dish = await prisma.dish.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DishFindFirstOrThrowArgs>(args?: SelectSubset<T, DishFindFirstOrThrowArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Dishes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dishes
     * const dishes = await prisma.dish.findMany()
     * 
     * // Get first 10 Dishes
     * const dishes = await prisma.dish.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const dishWithShopIdOnly = await prisma.dish.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends DishFindManyArgs>(args?: SelectSubset<T, DishFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Dish.
     * @param {DishCreateArgs} args - Arguments to create a Dish.
     * @example
     * // Create one Dish
     * const Dish = await prisma.dish.create({
     *   data: {
     *     // ... data to create a Dish
     *   }
     * })
     * 
     */
    create<T extends DishCreateArgs>(args: SelectSubset<T, DishCreateArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Dishes.
     * @param {DishCreateManyArgs} args - Arguments to create many Dishes.
     * @example
     * // Create many Dishes
     * const dish = await prisma.dish.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DishCreateManyArgs>(args?: SelectSubset<T, DishCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Dishes and returns the data saved in the database.
     * @param {DishCreateManyAndReturnArgs} args - Arguments to create many Dishes.
     * @example
     * // Create many Dishes
     * const dish = await prisma.dish.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Dishes and only return the `shopId`
     * const dishWithShopIdOnly = await prisma.dish.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DishCreateManyAndReturnArgs>(args?: SelectSubset<T, DishCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Dish.
     * @param {DishDeleteArgs} args - Arguments to delete one Dish.
     * @example
     * // Delete one Dish
     * const Dish = await prisma.dish.delete({
     *   where: {
     *     // ... filter to delete one Dish
     *   }
     * })
     * 
     */
    delete<T extends DishDeleteArgs>(args: SelectSubset<T, DishDeleteArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Dish.
     * @param {DishUpdateArgs} args - Arguments to update one Dish.
     * @example
     * // Update one Dish
     * const dish = await prisma.dish.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DishUpdateArgs>(args: SelectSubset<T, DishUpdateArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Dishes.
     * @param {DishDeleteManyArgs} args - Arguments to filter Dishes to delete.
     * @example
     * // Delete a few Dishes
     * const { count } = await prisma.dish.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DishDeleteManyArgs>(args?: SelectSubset<T, DishDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dishes
     * const dish = await prisma.dish.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DishUpdateManyArgs>(args: SelectSubset<T, DishUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dishes and returns the data updated in the database.
     * @param {DishUpdateManyAndReturnArgs} args - Arguments to update many Dishes.
     * @example
     * // Update many Dishes
     * const dish = await prisma.dish.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Dishes and only return the `shopId`
     * const dishWithShopIdOnly = await prisma.dish.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DishUpdateManyAndReturnArgs>(args: SelectSubset<T, DishUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Dish.
     * @param {DishUpsertArgs} args - Arguments to update or create a Dish.
     * @example
     * // Update or create a Dish
     * const dish = await prisma.dish.upsert({
     *   create: {
     *     // ... data to create a Dish
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dish we want to update
     *   }
     * })
     */
    upsert<T extends DishUpsertArgs>(args: SelectSubset<T, DishUpsertArgs<ExtArgs>>): Prisma__DishClient<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Dishes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishCountArgs} args - Arguments to filter Dishes to count.
     * @example
     * // Count the number of Dishes
     * const count = await prisma.dish.count({
     *   where: {
     *     // ... the filter for the Dishes we want to count
     *   }
     * })
    **/
    count<T extends DishCountArgs>(
      args?: Subset<T, DishCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DishCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DishAggregateArgs>(args: Subset<T, DishAggregateArgs>): Prisma.PrismaPromise<GetDishAggregateType<T>>

    /**
     * Group by Dish.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DishGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DishGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DishGroupByArgs['orderBy'] }
        : { orderBy?: DishGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DishGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDishGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Dish model
   */
  readonly fields: DishFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Dish.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DishClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends Dish$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Dish$categoryArgs<ExtArgs>>): Prisma__DishCategoryClient<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends Dish$shopArgs<ExtArgs> = {}>(args?: Subset<T, Dish$shopArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    unit<T extends Dish$unitArgs<ExtArgs> = {}>(args?: Subset<T, Dish$unitArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    imageUrls<T extends Dish$imageUrlsArgs<ExtArgs> = {}>(args?: Subset<T, Dish$imageUrlsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Dish model
   */
  interface DishFieldRefs {
    readonly shopId: FieldRef<"Dish", 'String'>
    readonly name: FieldRef<"Dish", 'String'>
    readonly code: FieldRef<"Dish", 'String'>
    readonly unitId: FieldRef<"Dish", 'String'>
    readonly price: FieldRef<"Dish", 'Float'>
    readonly taxIncludedPrice: FieldRef<"Dish", 'Float'>
    readonly isTaxIncludedPrice: FieldRef<"Dish", 'Boolean'>
    readonly categoryId: FieldRef<"Dish", 'String'>
    readonly type: FieldRef<"Dish", 'String'>
    readonly taxRate: FieldRef<"Dish", 'Float'>
    readonly status: FieldRef<"Dish", 'Switchabletatus'>
    readonly isNewlyCreated: FieldRef<"Dish", 'Boolean'>
    readonly isBestSeller: FieldRef<"Dish", 'Boolean'>
    readonly stockQuantity: FieldRef<"Dish", 'Float'>
    readonly hideForCustomers: FieldRef<"Dish", 'Boolean'>
    readonly hideForEmployees: FieldRef<"Dish", 'Boolean'>
    readonly outOfStockNotification: FieldRef<"Dish", 'Boolean'>
    readonly description: FieldRef<"Dish", 'String'>
    readonly soldCount: FieldRef<"Dish", 'Float'>
    readonly createdAt: FieldRef<"Dish", 'DateTime'>
    readonly updatedAt: FieldRef<"Dish", 'DateTime'>
    readonly id: FieldRef<"Dish", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Dish findUnique
   */
  export type DishFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish findUniqueOrThrow
   */
  export type DishFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish findFirst
   */
  export type DishFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dishes.
     */
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Dish findFirstOrThrow
   */
  export type DishFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dish to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Dishes.
     */
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Dish findMany
   */
  export type DishFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter, which Dishes to fetch.
     */
    where?: DishWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Dishes to fetch.
     */
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Dishes.
     */
    cursor?: DishWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Dishes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Dishes.
     */
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Dish create
   */
  export type DishCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The data needed to create a Dish.
     */
    data: XOR<DishCreateInput, DishUncheckedCreateInput>
  }

  /**
   * Dish createMany
   */
  export type DishCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Dishes.
     */
    data: DishCreateManyInput | DishCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Dish createManyAndReturn
   */
  export type DishCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * The data used to create many Dishes.
     */
    data: DishCreateManyInput | DishCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dish update
   */
  export type DishUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The data needed to update a Dish.
     */
    data: XOR<DishUpdateInput, DishUncheckedUpdateInput>
    /**
     * Choose, which Dish to update.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish updateMany
   */
  export type DishUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Dishes.
     */
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyInput>
    /**
     * Filter which Dishes to update
     */
    where?: DishWhereInput
    /**
     * Limit how many Dishes to update.
     */
    limit?: number
  }

  /**
   * Dish updateManyAndReturn
   */
  export type DishUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * The data used to update Dishes.
     */
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyInput>
    /**
     * Filter which Dishes to update
     */
    where?: DishWhereInput
    /**
     * Limit how many Dishes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Dish upsert
   */
  export type DishUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * The filter to search for the Dish to update in case it exists.
     */
    where: DishWhereUniqueInput
    /**
     * In case the Dish found by the `where` argument doesn't exist, create a new Dish with this data.
     */
    create: XOR<DishCreateInput, DishUncheckedCreateInput>
    /**
     * In case the Dish was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DishUpdateInput, DishUncheckedUpdateInput>
  }

  /**
   * Dish delete
   */
  export type DishDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    /**
     * Filter which Dish to delete.
     */
    where: DishWhereUniqueInput
  }

  /**
   * Dish deleteMany
   */
  export type DishDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Dishes to delete
     */
    where?: DishWhereInput
    /**
     * Limit how many Dishes to delete.
     */
    limit?: number
  }

  /**
   * Dish.category
   */
  export type Dish$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    where?: DishCategoryWhereInput
  }

  /**
   * Dish.shop
   */
  export type Dish$shopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shop
     */
    select?: ShopSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shop
     */
    omit?: ShopOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShopInclude<ExtArgs> | null
    where?: ShopWhereInput
  }

  /**
   * Dish.unit
   */
  export type Dish$unitArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    where?: UnitWhereInput
  }

  /**
   * Dish.imageUrls
   */
  export type Dish$imageUrlsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Image
     */
    select?: ImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Image
     */
    omit?: ImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ImageInclude<ExtArgs> | null
    where?: ImageWhereInput
    orderBy?: ImageOrderByWithRelationInput | ImageOrderByWithRelationInput[]
    cursor?: ImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ImageScalarFieldEnum | ImageScalarFieldEnum[]
  }

  /**
   * Dish without action
   */
  export type DishDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
  }


  /**
   * Model Unit
   */

  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    description: string | null
    status: $Enums.Switchabletatus | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UnitMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    code: string | null
    description: string | null
    status: $Enums.Switchabletatus | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type UnitCountAggregateOutputType = {
    shopId: number
    name: number
    code: number
    description: number
    status: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type UnitMinAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UnitMaxAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type UnitCountAggregateInputType = {
    shopId?: true
    name?: true
    code?: true
    description?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type UnitAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Unit to aggregate.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UnitWhereInput
    orderBy?: UnitOrderByWithAggregationInput | UnitOrderByWithAggregationInput[]
    by: UnitScalarFieldEnum[] | UnitScalarFieldEnum
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }

  export type UnitGroupByOutputType = {
    shopId: string
    name: string | null
    code: string | null
    description: string | null
    status: $Enums.Switchabletatus
    createdAt: Date
    updatedAt: Date
    id: string
    _count: UnitCountAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    dish?: boolean | Unit$dishArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["unit"]>

  export type UnitSelectScalar = {
    shopId?: boolean
    name?: boolean
    code?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type UnitOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "code" | "description" | "status" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["unit"]>
  export type UnitInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dish?: boolean | Unit$dishArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | UnitCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UnitIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type UnitIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $UnitPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Unit"
    objects: {
      dish: Prisma.$DishPayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      name: string | null
      code: string | null
      description: string | null
      status: $Enums.Switchabletatus
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["unit"]>
    composites: {}
  }

  type UnitGetPayload<S extends boolean | null | undefined | UnitDefaultArgs> = $Result.GetResult<Prisma.$UnitPayload, S>

  type UnitCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UnitFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UnitCountAggregateInputType | true
    }

  export interface UnitDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Unit'], meta: { name: 'Unit' } }
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UnitFindUniqueArgs>(args: SelectSubset<T, UnitFindUniqueArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Unit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UnitFindUniqueOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UnitFindUniqueOrThrowArgs>(args: SelectSubset<T, UnitFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UnitFindFirstArgs>(args?: SelectSubset<T, UnitFindFirstArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Unit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstOrThrowArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UnitFindFirstOrThrowArgs>(args?: SelectSubset<T, UnitFindFirstOrThrowArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const unitWithShopIdOnly = await prisma.unit.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends UnitFindManyArgs>(args?: SelectSubset<T, UnitFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
     */
    create<T extends UnitCreateArgs>(args: SelectSubset<T, UnitCreateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Units.
     * @param {UnitCreateManyArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UnitCreateManyArgs>(args?: SelectSubset<T, UnitCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Units and returns the data saved in the database.
     * @param {UnitCreateManyAndReturnArgs} args - Arguments to create many Units.
     * @example
     * // Create many Units
     * const unit = await prisma.unit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Units and only return the `shopId`
     * const unitWithShopIdOnly = await prisma.unit.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UnitCreateManyAndReturnArgs>(args?: SelectSubset<T, UnitCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
     */
    delete<T extends UnitDeleteArgs>(args: SelectSubset<T, UnitDeleteArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UnitUpdateArgs>(args: SelectSubset<T, UnitUpdateArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UnitDeleteManyArgs>(args?: SelectSubset<T, UnitDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UnitUpdateManyArgs>(args: SelectSubset<T, UnitUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units and returns the data updated in the database.
     * @param {UnitUpdateManyAndReturnArgs} args - Arguments to update many Units.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Units and only return the `shopId`
     * const unitWithShopIdOnly = await prisma.unit.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UnitUpdateManyAndReturnArgs>(args: SelectSubset<T, UnitUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
     */
    upsert<T extends UnitUpsertArgs>(args: SelectSubset<T, UnitUpsertArgs<ExtArgs>>): Prisma__UnitClient<$Result.GetResult<Prisma.$UnitPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): Prisma.PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Unit model
   */
  readonly fields: UnitFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UnitClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dish<T extends Unit$dishArgs<ExtArgs> = {}>(args?: Subset<T, Unit$dishArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Unit model
   */
  interface UnitFieldRefs {
    readonly shopId: FieldRef<"Unit", 'String'>
    readonly name: FieldRef<"Unit", 'String'>
    readonly code: FieldRef<"Unit", 'String'>
    readonly description: FieldRef<"Unit", 'String'>
    readonly status: FieldRef<"Unit", 'Switchabletatus'>
    readonly createdAt: FieldRef<"Unit", 'DateTime'>
    readonly updatedAt: FieldRef<"Unit", 'DateTime'>
    readonly id: FieldRef<"Unit", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findUniqueOrThrow
   */
  export type UnitFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findFirstOrThrow
   */
  export type UnitFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Unit to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     */
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit findMany
   */
  export type UnitFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter, which Units to fetch.
     */
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     */
    orderBy?: UnitOrderByWithRelationInput | UnitOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     */
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     */
    skip?: number
    distinct?: UnitScalarFieldEnum | UnitScalarFieldEnum[]
  }

  /**
   * Unit create
   */
  export type UnitCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to create a Unit.
     */
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }

  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Unit createManyAndReturn
   */
  export type UnitCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to create many Units.
     */
    data: UnitCreateManyInput | UnitCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit update
   */
  export type UnitUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The data needed to update a Unit.
     */
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
  }

  /**
   * Unit updateManyAndReturn
   */
  export type UnitUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * The data used to update Units.
     */
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Unit upsert
   */
  export type UnitUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * The filter to search for the Unit to update in case it exists.
     */
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     */
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }

  /**
   * Unit delete
   */
  export type UnitDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
    /**
     * Filter which Unit to delete.
     */
    where: UnitWhereUniqueInput
  }

  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Units to delete
     */
    where?: UnitWhereInput
    /**
     * Limit how many Units to delete.
     */
    limit?: number
  }

  /**
   * Unit.dish
   */
  export type Unit$dishArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Dish
     */
    select?: DishSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Dish
     */
    omit?: DishOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishInclude<ExtArgs> | null
    where?: DishWhereInput
    orderBy?: DishOrderByWithRelationInput | DishOrderByWithRelationInput[]
    cursor?: DishWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishScalarFieldEnum | DishScalarFieldEnum[]
  }

  /**
   * Unit without action
   */
  export type UnitDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Unit
     */
    select?: UnitSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Unit
     */
    omit?: UnitOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UnitInclude<ExtArgs> | null
  }


  /**
   * Model TablePosition
   */

  export type AggregateTablePosition = {
    _count: TablePositionCountAggregateOutputType | null
    _min: TablePositionMinAggregateOutputType | null
    _max: TablePositionMaxAggregateOutputType | null
  }

  export type TablePositionMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type TablePositionMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type TablePositionCountAggregateOutputType = {
    shopId: number
    name: number
    dishCategoryIds: number
    tableIds: number
    status: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type TablePositionMinAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type TablePositionMaxAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type TablePositionCountAggregateInputType = {
    shopId?: true
    name?: true
    dishCategoryIds?: true
    tableIds?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type TablePositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TablePosition to aggregate.
     */
    where?: TablePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TablePositions to fetch.
     */
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TablePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TablePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TablePositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TablePositions
    **/
    _count?: true | TablePositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TablePositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TablePositionMaxAggregateInputType
  }

  export type GetTablePositionAggregateType<T extends TablePositionAggregateArgs> = {
        [P in keyof T & keyof AggregateTablePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTablePosition[P]>
      : GetScalarType<T[P], AggregateTablePosition[P]>
  }




  export type TablePositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TablePositionWhereInput
    orderBy?: TablePositionOrderByWithAggregationInput | TablePositionOrderByWithAggregationInput[]
    by: TablePositionScalarFieldEnum[] | TablePositionScalarFieldEnum
    having?: TablePositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TablePositionCountAggregateInputType | true
    _min?: TablePositionMinAggregateInputType
    _max?: TablePositionMaxAggregateInputType
  }

  export type TablePositionGroupByOutputType = {
    shopId: string
    name: string | null
    dishCategoryIds: string[]
    tableIds: string[]
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    id: string
    _count: TablePositionCountAggregateOutputType | null
    _min: TablePositionMinAggregateOutputType | null
    _max: TablePositionMaxAggregateOutputType | null
  }

  type GetTablePositionGroupByPayload<T extends TablePositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TablePositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TablePositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TablePositionGroupByOutputType[P]>
            : GetScalarType<T[P], TablePositionGroupByOutputType[P]>
        }
      >
    >


  export type TablePositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    dishCategoryIds?: boolean
    tableIds?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    dishCategories?: boolean | TablePosition$dishCategoriesArgs<ExtArgs>
    tables?: boolean | TablePosition$tablesArgs<ExtArgs>
    _count?: boolean | TablePositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tablePosition"]>

  export type TablePositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    dishCategoryIds?: boolean
    tableIds?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tablePosition"]>

  export type TablePositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    dishCategoryIds?: boolean
    tableIds?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tablePosition"]>

  export type TablePositionSelectScalar = {
    shopId?: boolean
    name?: boolean
    dishCategoryIds?: boolean
    tableIds?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type TablePositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "dishCategoryIds" | "tableIds" | "status" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["tablePosition"]>
  export type TablePositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    dishCategories?: boolean | TablePosition$dishCategoriesArgs<ExtArgs>
    tables?: boolean | TablePosition$tablesArgs<ExtArgs>
    _count?: boolean | TablePositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TablePositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type TablePositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $TablePositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TablePosition"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      dishCategories: Prisma.$DishCategoryPayload<ExtArgs>[]
      tables: Prisma.$TablePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      name: string | null
      dishCategoryIds: string[]
      tableIds: string[]
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["tablePosition"]>
    composites: {}
  }

  type TablePositionGetPayload<S extends boolean | null | undefined | TablePositionDefaultArgs> = $Result.GetResult<Prisma.$TablePositionPayload, S>

  type TablePositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TablePositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TablePositionCountAggregateInputType | true
    }

  export interface TablePositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TablePosition'], meta: { name: 'TablePosition' } }
    /**
     * Find zero or one TablePosition that matches the filter.
     * @param {TablePositionFindUniqueArgs} args - Arguments to find a TablePosition
     * @example
     * // Get one TablePosition
     * const tablePosition = await prisma.tablePosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TablePositionFindUniqueArgs>(args: SelectSubset<T, TablePositionFindUniqueArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TablePosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TablePositionFindUniqueOrThrowArgs} args - Arguments to find a TablePosition
     * @example
     * // Get one TablePosition
     * const tablePosition = await prisma.tablePosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TablePositionFindUniqueOrThrowArgs>(args: SelectSubset<T, TablePositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TablePosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionFindFirstArgs} args - Arguments to find a TablePosition
     * @example
     * // Get one TablePosition
     * const tablePosition = await prisma.tablePosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TablePositionFindFirstArgs>(args?: SelectSubset<T, TablePositionFindFirstArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TablePosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionFindFirstOrThrowArgs} args - Arguments to find a TablePosition
     * @example
     * // Get one TablePosition
     * const tablePosition = await prisma.tablePosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TablePositionFindFirstOrThrowArgs>(args?: SelectSubset<T, TablePositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TablePositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TablePositions
     * const tablePositions = await prisma.tablePosition.findMany()
     * 
     * // Get first 10 TablePositions
     * const tablePositions = await prisma.tablePosition.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const tablePositionWithShopIdOnly = await prisma.tablePosition.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends TablePositionFindManyArgs>(args?: SelectSubset<T, TablePositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TablePosition.
     * @param {TablePositionCreateArgs} args - Arguments to create a TablePosition.
     * @example
     * // Create one TablePosition
     * const TablePosition = await prisma.tablePosition.create({
     *   data: {
     *     // ... data to create a TablePosition
     *   }
     * })
     * 
     */
    create<T extends TablePositionCreateArgs>(args: SelectSubset<T, TablePositionCreateArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TablePositions.
     * @param {TablePositionCreateManyArgs} args - Arguments to create many TablePositions.
     * @example
     * // Create many TablePositions
     * const tablePosition = await prisma.tablePosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TablePositionCreateManyArgs>(args?: SelectSubset<T, TablePositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TablePositions and returns the data saved in the database.
     * @param {TablePositionCreateManyAndReturnArgs} args - Arguments to create many TablePositions.
     * @example
     * // Create many TablePositions
     * const tablePosition = await prisma.tablePosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TablePositions and only return the `shopId`
     * const tablePositionWithShopIdOnly = await prisma.tablePosition.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TablePositionCreateManyAndReturnArgs>(args?: SelectSubset<T, TablePositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TablePosition.
     * @param {TablePositionDeleteArgs} args - Arguments to delete one TablePosition.
     * @example
     * // Delete one TablePosition
     * const TablePosition = await prisma.tablePosition.delete({
     *   where: {
     *     // ... filter to delete one TablePosition
     *   }
     * })
     * 
     */
    delete<T extends TablePositionDeleteArgs>(args: SelectSubset<T, TablePositionDeleteArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TablePosition.
     * @param {TablePositionUpdateArgs} args - Arguments to update one TablePosition.
     * @example
     * // Update one TablePosition
     * const tablePosition = await prisma.tablePosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TablePositionUpdateArgs>(args: SelectSubset<T, TablePositionUpdateArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TablePositions.
     * @param {TablePositionDeleteManyArgs} args - Arguments to filter TablePositions to delete.
     * @example
     * // Delete a few TablePositions
     * const { count } = await prisma.tablePosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TablePositionDeleteManyArgs>(args?: SelectSubset<T, TablePositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TablePositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TablePositions
     * const tablePosition = await prisma.tablePosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TablePositionUpdateManyArgs>(args: SelectSubset<T, TablePositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TablePositions and returns the data updated in the database.
     * @param {TablePositionUpdateManyAndReturnArgs} args - Arguments to update many TablePositions.
     * @example
     * // Update many TablePositions
     * const tablePosition = await prisma.tablePosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TablePositions and only return the `shopId`
     * const tablePositionWithShopIdOnly = await prisma.tablePosition.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TablePositionUpdateManyAndReturnArgs>(args: SelectSubset<T, TablePositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TablePosition.
     * @param {TablePositionUpsertArgs} args - Arguments to update or create a TablePosition.
     * @example
     * // Update or create a TablePosition
     * const tablePosition = await prisma.tablePosition.upsert({
     *   create: {
     *     // ... data to create a TablePosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TablePosition we want to update
     *   }
     * })
     */
    upsert<T extends TablePositionUpsertArgs>(args: SelectSubset<T, TablePositionUpsertArgs<ExtArgs>>): Prisma__TablePositionClient<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TablePositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionCountArgs} args - Arguments to filter TablePositions to count.
     * @example
     * // Count the number of TablePositions
     * const count = await prisma.tablePosition.count({
     *   where: {
     *     // ... the filter for the TablePositions we want to count
     *   }
     * })
    **/
    count<T extends TablePositionCountArgs>(
      args?: Subset<T, TablePositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TablePositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TablePosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TablePositionAggregateArgs>(args: Subset<T, TablePositionAggregateArgs>): Prisma.PrismaPromise<GetTablePositionAggregateType<T>>

    /**
     * Group by TablePosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TablePositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TablePositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TablePositionGroupByArgs['orderBy'] }
        : { orderBy?: TablePositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TablePositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTablePositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TablePosition model
   */
  readonly fields: TablePositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TablePosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TablePositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    dishCategories<T extends TablePosition$dishCategoriesArgs<ExtArgs> = {}>(args?: Subset<T, TablePosition$dishCategoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DishCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tables<T extends TablePosition$tablesArgs<ExtArgs> = {}>(args?: Subset<T, TablePosition$tablesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TablePosition model
   */
  interface TablePositionFieldRefs {
    readonly shopId: FieldRef<"TablePosition", 'String'>
    readonly name: FieldRef<"TablePosition", 'String'>
    readonly dishCategoryIds: FieldRef<"TablePosition", 'String[]'>
    readonly tableIds: FieldRef<"TablePosition", 'String[]'>
    readonly status: FieldRef<"TablePosition", 'Status'>
    readonly createdAt: FieldRef<"TablePosition", 'DateTime'>
    readonly updatedAt: FieldRef<"TablePosition", 'DateTime'>
    readonly id: FieldRef<"TablePosition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TablePosition findUnique
   */
  export type TablePositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * Filter, which TablePosition to fetch.
     */
    where: TablePositionWhereUniqueInput
  }

  /**
   * TablePosition findUniqueOrThrow
   */
  export type TablePositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * Filter, which TablePosition to fetch.
     */
    where: TablePositionWhereUniqueInput
  }

  /**
   * TablePosition findFirst
   */
  export type TablePositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * Filter, which TablePosition to fetch.
     */
    where?: TablePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TablePositions to fetch.
     */
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TablePositions.
     */
    cursor?: TablePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TablePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TablePositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TablePositions.
     */
    distinct?: TablePositionScalarFieldEnum | TablePositionScalarFieldEnum[]
  }

  /**
   * TablePosition findFirstOrThrow
   */
  export type TablePositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * Filter, which TablePosition to fetch.
     */
    where?: TablePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TablePositions to fetch.
     */
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TablePositions.
     */
    cursor?: TablePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TablePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TablePositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TablePositions.
     */
    distinct?: TablePositionScalarFieldEnum | TablePositionScalarFieldEnum[]
  }

  /**
   * TablePosition findMany
   */
  export type TablePositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * Filter, which TablePositions to fetch.
     */
    where?: TablePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TablePositions to fetch.
     */
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TablePositions.
     */
    cursor?: TablePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TablePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TablePositions.
     */
    skip?: number
    distinct?: TablePositionScalarFieldEnum | TablePositionScalarFieldEnum[]
  }

  /**
   * TablePosition create
   */
  export type TablePositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * The data needed to create a TablePosition.
     */
    data: XOR<TablePositionCreateInput, TablePositionUncheckedCreateInput>
  }

  /**
   * TablePosition createMany
   */
  export type TablePositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TablePositions.
     */
    data: TablePositionCreateManyInput | TablePositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TablePosition createManyAndReturn
   */
  export type TablePositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * The data used to create many TablePositions.
     */
    data: TablePositionCreateManyInput | TablePositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TablePosition update
   */
  export type TablePositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * The data needed to update a TablePosition.
     */
    data: XOR<TablePositionUpdateInput, TablePositionUncheckedUpdateInput>
    /**
     * Choose, which TablePosition to update.
     */
    where: TablePositionWhereUniqueInput
  }

  /**
   * TablePosition updateMany
   */
  export type TablePositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TablePositions.
     */
    data: XOR<TablePositionUpdateManyMutationInput, TablePositionUncheckedUpdateManyInput>
    /**
     * Filter which TablePositions to update
     */
    where?: TablePositionWhereInput
    /**
     * Limit how many TablePositions to update.
     */
    limit?: number
  }

  /**
   * TablePosition updateManyAndReturn
   */
  export type TablePositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * The data used to update TablePositions.
     */
    data: XOR<TablePositionUpdateManyMutationInput, TablePositionUncheckedUpdateManyInput>
    /**
     * Filter which TablePositions to update
     */
    where?: TablePositionWhereInput
    /**
     * Limit how many TablePositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TablePosition upsert
   */
  export type TablePositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * The filter to search for the TablePosition to update in case it exists.
     */
    where: TablePositionWhereUniqueInput
    /**
     * In case the TablePosition found by the `where` argument doesn't exist, create a new TablePosition with this data.
     */
    create: XOR<TablePositionCreateInput, TablePositionUncheckedCreateInput>
    /**
     * In case the TablePosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TablePositionUpdateInput, TablePositionUncheckedUpdateInput>
  }

  /**
   * TablePosition delete
   */
  export type TablePositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    /**
     * Filter which TablePosition to delete.
     */
    where: TablePositionWhereUniqueInput
  }

  /**
   * TablePosition deleteMany
   */
  export type TablePositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TablePositions to delete
     */
    where?: TablePositionWhereInput
    /**
     * Limit how many TablePositions to delete.
     */
    limit?: number
  }

  /**
   * TablePosition.dishCategories
   */
  export type TablePosition$dishCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DishCategory
     */
    select?: DishCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the DishCategory
     */
    omit?: DishCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DishCategoryInclude<ExtArgs> | null
    where?: DishCategoryWhereInput
    orderBy?: DishCategoryOrderByWithRelationInput | DishCategoryOrderByWithRelationInput[]
    cursor?: DishCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DishCategoryScalarFieldEnum | DishCategoryScalarFieldEnum[]
  }

  /**
   * TablePosition.tables
   */
  export type TablePosition$tablesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    where?: TableWhereInput
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    cursor?: TableWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * TablePosition without action
   */
  export type TablePositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
  }


  /**
   * Model Table
   */

  export type AggregateTable = {
    _count: TableCountAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  export type TableMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    positionId: string | null
    status: $Enums.Status | null
    allowMultipleOrderSession: boolean | null
    needApprovalWhenCustomerOrder: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    kitchenId: string | null
  }

  export type TableMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    positionId: string | null
    status: $Enums.Status | null
    allowMultipleOrderSession: boolean | null
    needApprovalWhenCustomerOrder: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
    kitchenId: string | null
  }

  export type TableCountAggregateOutputType = {
    shopId: number
    name: number
    positionId: number
    status: number
    allowMultipleOrderSession: number
    needApprovalWhenCustomerOrder: number
    createdAt: number
    updatedAt: number
    id: number
    kitchenId: number
    _all: number
  }


  export type TableMinAggregateInputType = {
    shopId?: true
    name?: true
    positionId?: true
    status?: true
    allowMultipleOrderSession?: true
    needApprovalWhenCustomerOrder?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    kitchenId?: true
  }

  export type TableMaxAggregateInputType = {
    shopId?: true
    name?: true
    positionId?: true
    status?: true
    allowMultipleOrderSession?: true
    needApprovalWhenCustomerOrder?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    kitchenId?: true
  }

  export type TableCountAggregateInputType = {
    shopId?: true
    name?: true
    positionId?: true
    status?: true
    allowMultipleOrderSession?: true
    needApprovalWhenCustomerOrder?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    kitchenId?: true
    _all?: true
  }

  export type TableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Table to aggregate.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tables
    **/
    _count?: true | TableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TableMaxAggregateInputType
  }

  export type GetTableAggregateType<T extends TableAggregateArgs> = {
        [P in keyof T & keyof AggregateTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTable[P]>
      : GetScalarType<T[P], AggregateTable[P]>
  }




  export type TableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TableWhereInput
    orderBy?: TableOrderByWithAggregationInput | TableOrderByWithAggregationInput[]
    by: TableScalarFieldEnum[] | TableScalarFieldEnum
    having?: TableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TableCountAggregateInputType | true
    _min?: TableMinAggregateInputType
    _max?: TableMaxAggregateInputType
  }

  export type TableGroupByOutputType = {
    shopId: string
    name: string | null
    positionId: string | null
    status: $Enums.Status
    allowMultipleOrderSession: boolean | null
    needApprovalWhenCustomerOrder: boolean | null
    createdAt: Date
    updatedAt: Date
    id: string
    kitchenId: string | null
    _count: TableCountAggregateOutputType | null
    _min: TableMinAggregateOutputType | null
    _max: TableMaxAggregateOutputType | null
  }

  type GetTableGroupByPayload<T extends TableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TableGroupByOutputType[P]>
            : GetScalarType<T[P], TableGroupByOutputType[P]>
        }
      >
    >


  export type TableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    positionId?: boolean
    status?: boolean
    allowMultipleOrderSession?: boolean
    needApprovalWhenCustomerOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    kitchenId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    position?: boolean | Table$positionArgs<ExtArgs>
    Kitchen?: boolean | Table$KitchenArgs<ExtArgs>
    Order?: boolean | Table$OrderArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    positionId?: boolean
    status?: boolean
    allowMultipleOrderSession?: boolean
    needApprovalWhenCustomerOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    kitchenId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    Kitchen?: boolean | Table$KitchenArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    positionId?: boolean
    status?: boolean
    allowMultipleOrderSession?: boolean
    needApprovalWhenCustomerOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    kitchenId?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    Kitchen?: boolean | Table$KitchenArgs<ExtArgs>
  }, ExtArgs["result"]["table"]>

  export type TableSelectScalar = {
    shopId?: boolean
    name?: boolean
    positionId?: boolean
    status?: boolean
    allowMultipleOrderSession?: boolean
    needApprovalWhenCustomerOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    kitchenId?: boolean
  }

  export type TableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "positionId" | "status" | "allowMultipleOrderSession" | "needApprovalWhenCustomerOrder" | "createdAt" | "updatedAt" | "id" | "kitchenId", ExtArgs["result"]["table"]>
  export type TableInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    position?: boolean | Table$positionArgs<ExtArgs>
    Kitchen?: boolean | Table$KitchenArgs<ExtArgs>
    Order?: boolean | Table$OrderArgs<ExtArgs>
    _count?: boolean | TableCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TableIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    Kitchen?: boolean | Table$KitchenArgs<ExtArgs>
  }
  export type TableIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    Kitchen?: boolean | Table$KitchenArgs<ExtArgs>
  }

  export type $TablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Table"
    objects: {
      shop: Prisma.$ShopPayload<ExtArgs>
      position: Prisma.$TablePositionPayload<ExtArgs>[]
      Kitchen: Prisma.$KitchenPayload<ExtArgs> | null
      Order: Prisma.$OrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      name: string | null
      positionId: string | null
      status: $Enums.Status
      allowMultipleOrderSession: boolean | null
      needApprovalWhenCustomerOrder: boolean | null
      createdAt: Date
      updatedAt: Date
      id: string
      kitchenId: string | null
    }, ExtArgs["result"]["table"]>
    composites: {}
  }

  type TableGetPayload<S extends boolean | null | undefined | TableDefaultArgs> = $Result.GetResult<Prisma.$TablePayload, S>

  type TableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TableCountAggregateInputType | true
    }

  export interface TableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Table'], meta: { name: 'Table' } }
    /**
     * Find zero or one Table that matches the filter.
     * @param {TableFindUniqueArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TableFindUniqueArgs>(args: SelectSubset<T, TableFindUniqueArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TableFindUniqueOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TableFindUniqueOrThrowArgs>(args: SelectSubset<T, TableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TableFindFirstArgs>(args?: SelectSubset<T, TableFindFirstArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindFirstOrThrowArgs} args - Arguments to find a Table
     * @example
     * // Get one Table
     * const table = await prisma.table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TableFindFirstOrThrowArgs>(args?: SelectSubset<T, TableFindFirstOrThrowArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tables
     * const tables = await prisma.table.findMany()
     * 
     * // Get first 10 Tables
     * const tables = await prisma.table.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const tableWithShopIdOnly = await prisma.table.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends TableFindManyArgs>(args?: SelectSubset<T, TableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Table.
     * @param {TableCreateArgs} args - Arguments to create a Table.
     * @example
     * // Create one Table
     * const Table = await prisma.table.create({
     *   data: {
     *     // ... data to create a Table
     *   }
     * })
     * 
     */
    create<T extends TableCreateArgs>(args: SelectSubset<T, TableCreateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tables.
     * @param {TableCreateManyArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TableCreateManyArgs>(args?: SelectSubset<T, TableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tables and returns the data saved in the database.
     * @param {TableCreateManyAndReturnArgs} args - Arguments to create many Tables.
     * @example
     * // Create many Tables
     * const table = await prisma.table.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tables and only return the `shopId`
     * const tableWithShopIdOnly = await prisma.table.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TableCreateManyAndReturnArgs>(args?: SelectSubset<T, TableCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Table.
     * @param {TableDeleteArgs} args - Arguments to delete one Table.
     * @example
     * // Delete one Table
     * const Table = await prisma.table.delete({
     *   where: {
     *     // ... filter to delete one Table
     *   }
     * })
     * 
     */
    delete<T extends TableDeleteArgs>(args: SelectSubset<T, TableDeleteArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Table.
     * @param {TableUpdateArgs} args - Arguments to update one Table.
     * @example
     * // Update one Table
     * const table = await prisma.table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TableUpdateArgs>(args: SelectSubset<T, TableUpdateArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tables.
     * @param {TableDeleteManyArgs} args - Arguments to filter Tables to delete.
     * @example
     * // Delete a few Tables
     * const { count } = await prisma.table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TableDeleteManyArgs>(args?: SelectSubset<T, TableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TableUpdateManyArgs>(args: SelectSubset<T, TableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tables and returns the data updated in the database.
     * @param {TableUpdateManyAndReturnArgs} args - Arguments to update many Tables.
     * @example
     * // Update many Tables
     * const table = await prisma.table.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tables and only return the `shopId`
     * const tableWithShopIdOnly = await prisma.table.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TableUpdateManyAndReturnArgs>(args: SelectSubset<T, TableUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Table.
     * @param {TableUpsertArgs} args - Arguments to update or create a Table.
     * @example
     * // Update or create a Table
     * const table = await prisma.table.upsert({
     *   create: {
     *     // ... data to create a Table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Table we want to update
     *   }
     * })
     */
    upsert<T extends TableUpsertArgs>(args: SelectSubset<T, TableUpsertArgs<ExtArgs>>): Prisma__TableClient<$Result.GetResult<Prisma.$TablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableCountArgs} args - Arguments to filter Tables to count.
     * @example
     * // Count the number of Tables
     * const count = await prisma.table.count({
     *   where: {
     *     // ... the filter for the Tables we want to count
     *   }
     * })
    **/
    count<T extends TableCountArgs>(
      args?: Subset<T, TableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TableAggregateArgs>(args: Subset<T, TableAggregateArgs>): Prisma.PrismaPromise<GetTableAggregateType<T>>

    /**
     * Group by Table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TableGroupByArgs['orderBy'] }
        : { orderBy?: TableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Table model
   */
  readonly fields: TableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    position<T extends Table$positionArgs<ExtArgs> = {}>(args?: Subset<T, Table$positionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TablePositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Kitchen<T extends Table$KitchenArgs<ExtArgs> = {}>(args?: Subset<T, Table$KitchenArgs<ExtArgs>>): Prisma__KitchenClient<$Result.GetResult<Prisma.$KitchenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Order<T extends Table$OrderArgs<ExtArgs> = {}>(args?: Subset<T, Table$OrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Table model
   */
  interface TableFieldRefs {
    readonly shopId: FieldRef<"Table", 'String'>
    readonly name: FieldRef<"Table", 'String'>
    readonly positionId: FieldRef<"Table", 'String'>
    readonly status: FieldRef<"Table", 'Status'>
    readonly allowMultipleOrderSession: FieldRef<"Table", 'Boolean'>
    readonly needApprovalWhenCustomerOrder: FieldRef<"Table", 'Boolean'>
    readonly createdAt: FieldRef<"Table", 'DateTime'>
    readonly updatedAt: FieldRef<"Table", 'DateTime'>
    readonly id: FieldRef<"Table", 'String'>
    readonly kitchenId: FieldRef<"Table", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Table findUnique
   */
  export type TableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findUniqueOrThrow
   */
  export type TableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table findFirst
   */
  export type TableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findFirstOrThrow
   */
  export type TableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Table to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tables.
     */
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table findMany
   */
  export type TableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter, which Tables to fetch.
     */
    where?: TableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tables to fetch.
     */
    orderBy?: TableOrderByWithRelationInput | TableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tables.
     */
    cursor?: TableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tables.
     */
    skip?: number
    distinct?: TableScalarFieldEnum | TableScalarFieldEnum[]
  }

  /**
   * Table create
   */
  export type TableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to create a Table.
     */
    data: XOR<TableCreateInput, TableUncheckedCreateInput>
  }

  /**
   * Table createMany
   */
  export type TableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Table createManyAndReturn
   */
  export type TableCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * The data used to create many Tables.
     */
    data: TableCreateManyInput | TableCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table update
   */
  export type TableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The data needed to update a Table.
     */
    data: XOR<TableUpdateInput, TableUncheckedUpdateInput>
    /**
     * Choose, which Table to update.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table updateMany
   */
  export type TableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
  }

  /**
   * Table updateManyAndReturn
   */
  export type TableUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * The data used to update Tables.
     */
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyInput>
    /**
     * Filter which Tables to update
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Table upsert
   */
  export type TableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * The filter to search for the Table to update in case it exists.
     */
    where: TableWhereUniqueInput
    /**
     * In case the Table found by the `where` argument doesn't exist, create a new Table with this data.
     */
    create: XOR<TableCreateInput, TableUncheckedCreateInput>
    /**
     * In case the Table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TableUpdateInput, TableUncheckedUpdateInput>
  }

  /**
   * Table delete
   */
  export type TableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
    /**
     * Filter which Table to delete.
     */
    where: TableWhereUniqueInput
  }

  /**
   * Table deleteMany
   */
  export type TableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tables to delete
     */
    where?: TableWhereInput
    /**
     * Limit how many Tables to delete.
     */
    limit?: number
  }

  /**
   * Table.position
   */
  export type Table$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TablePosition
     */
    select?: TablePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TablePosition
     */
    omit?: TablePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TablePositionInclude<ExtArgs> | null
    where?: TablePositionWhereInput
    orderBy?: TablePositionOrderByWithRelationInput | TablePositionOrderByWithRelationInput[]
    cursor?: TablePositionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TablePositionScalarFieldEnum | TablePositionScalarFieldEnum[]
  }

  /**
   * Table.Kitchen
   */
  export type Table$KitchenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Kitchen
     */
    select?: KitchenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Kitchen
     */
    omit?: KitchenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: KitchenInclude<ExtArgs> | null
    where?: KitchenWhereInput
  }

  /**
   * Table.Order
   */
  export type Table$OrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Order
     */
    select?: OrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Order
     */
    omit?: OrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderInclude<ExtArgs> | null
    where?: OrderWhereInput
    orderBy?: OrderOrderByWithRelationInput | OrderOrderByWithRelationInput[]
    cursor?: OrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderScalarFieldEnum | OrderScalarFieldEnum[]
  }

  /**
   * Table without action
   */
  export type TableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Table
     */
    select?: TableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Table
     */
    omit?: TableOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TableInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeDepartment
   */

  export type AggregateEmployeeDepartment = {
    _count: EmployeeDepartmentCountAggregateOutputType | null
    _min: EmployeeDepartmentMinAggregateOutputType | null
    _max: EmployeeDepartmentMaxAggregateOutputType | null
  }

  export type EmployeeDepartmentMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type EmployeeDepartmentMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type EmployeeDepartmentCountAggregateOutputType = {
    shopId: number
    name: number
    permissions: number
    status: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type EmployeeDepartmentMinAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type EmployeeDepartmentMaxAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type EmployeeDepartmentCountAggregateInputType = {
    shopId?: true
    name?: true
    permissions?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type EmployeeDepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeDepartment to aggregate.
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDepartments to fetch.
     */
    orderBy?: EmployeeDepartmentOrderByWithRelationInput | EmployeeDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeDepartments
    **/
    _count?: true | EmployeeDepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeDepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeDepartmentMaxAggregateInputType
  }

  export type GetEmployeeDepartmentAggregateType<T extends EmployeeDepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeDepartment[P]>
      : GetScalarType<T[P], AggregateEmployeeDepartment[P]>
  }




  export type EmployeeDepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeDepartmentWhereInput
    orderBy?: EmployeeDepartmentOrderByWithAggregationInput | EmployeeDepartmentOrderByWithAggregationInput[]
    by: EmployeeDepartmentScalarFieldEnum[] | EmployeeDepartmentScalarFieldEnum
    having?: EmployeeDepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeDepartmentCountAggregateInputType | true
    _min?: EmployeeDepartmentMinAggregateInputType
    _max?: EmployeeDepartmentMaxAggregateInputType
  }

  export type EmployeeDepartmentGroupByOutputType = {
    shopId: string
    name: string | null
    permissions: string[]
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    id: string
    _count: EmployeeDepartmentCountAggregateOutputType | null
    _min: EmployeeDepartmentMinAggregateOutputType | null
    _max: EmployeeDepartmentMaxAggregateOutputType | null
  }

  type GetEmployeeDepartmentGroupByPayload<T extends EmployeeDepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeDepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeDepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeDepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeDepartmentGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeDepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    permissions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    employees?: boolean | EmployeeDepartment$employeesArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDepartment"]>

  export type EmployeeDepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    permissions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDepartment"]>

  export type EmployeeDepartmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    permissions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeDepartment"]>

  export type EmployeeDepartmentSelectScalar = {
    shopId?: boolean
    name?: boolean
    permissions?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type EmployeeDepartmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "permissions" | "status" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["employeeDepartment"]>
  export type EmployeeDepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeeDepartment$employeesArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | EmployeeDepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeDepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type EmployeeDepartmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $EmployeeDepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeDepartment"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      name: string | null
      permissions: string[]
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["employeeDepartment"]>
    composites: {}
  }

  type EmployeeDepartmentGetPayload<S extends boolean | null | undefined | EmployeeDepartmentDefaultArgs> = $Result.GetResult<Prisma.$EmployeeDepartmentPayload, S>

  type EmployeeDepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeDepartmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeDepartmentCountAggregateInputType | true
    }

  export interface EmployeeDepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeDepartment'], meta: { name: 'EmployeeDepartment' } }
    /**
     * Find zero or one EmployeeDepartment that matches the filter.
     * @param {EmployeeDepartmentFindUniqueArgs} args - Arguments to find a EmployeeDepartment
     * @example
     * // Get one EmployeeDepartment
     * const employeeDepartment = await prisma.employeeDepartment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeDepartmentFindUniqueArgs>(args: SelectSubset<T, EmployeeDepartmentFindUniqueArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeDepartment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeDepartmentFindUniqueOrThrowArgs} args - Arguments to find a EmployeeDepartment
     * @example
     * // Get one EmployeeDepartment
     * const employeeDepartment = await prisma.employeeDepartment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeDepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeDepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeDepartment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentFindFirstArgs} args - Arguments to find a EmployeeDepartment
     * @example
     * // Get one EmployeeDepartment
     * const employeeDepartment = await prisma.employeeDepartment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeDepartmentFindFirstArgs>(args?: SelectSubset<T, EmployeeDepartmentFindFirstArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeDepartment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentFindFirstOrThrowArgs} args - Arguments to find a EmployeeDepartment
     * @example
     * // Get one EmployeeDepartment
     * const employeeDepartment = await prisma.employeeDepartment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeDepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeDepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeDepartments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeDepartments
     * const employeeDepartments = await prisma.employeeDepartment.findMany()
     * 
     * // Get first 10 EmployeeDepartments
     * const employeeDepartments = await prisma.employeeDepartment.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const employeeDepartmentWithShopIdOnly = await prisma.employeeDepartment.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends EmployeeDepartmentFindManyArgs>(args?: SelectSubset<T, EmployeeDepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeDepartment.
     * @param {EmployeeDepartmentCreateArgs} args - Arguments to create a EmployeeDepartment.
     * @example
     * // Create one EmployeeDepartment
     * const EmployeeDepartment = await prisma.employeeDepartment.create({
     *   data: {
     *     // ... data to create a EmployeeDepartment
     *   }
     * })
     * 
     */
    create<T extends EmployeeDepartmentCreateArgs>(args: SelectSubset<T, EmployeeDepartmentCreateArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeDepartments.
     * @param {EmployeeDepartmentCreateManyArgs} args - Arguments to create many EmployeeDepartments.
     * @example
     * // Create many EmployeeDepartments
     * const employeeDepartment = await prisma.employeeDepartment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeDepartmentCreateManyArgs>(args?: SelectSubset<T, EmployeeDepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeDepartments and returns the data saved in the database.
     * @param {EmployeeDepartmentCreateManyAndReturnArgs} args - Arguments to create many EmployeeDepartments.
     * @example
     * // Create many EmployeeDepartments
     * const employeeDepartment = await prisma.employeeDepartment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeDepartments and only return the `shopId`
     * const employeeDepartmentWithShopIdOnly = await prisma.employeeDepartment.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeDepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeDepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeDepartment.
     * @param {EmployeeDepartmentDeleteArgs} args - Arguments to delete one EmployeeDepartment.
     * @example
     * // Delete one EmployeeDepartment
     * const EmployeeDepartment = await prisma.employeeDepartment.delete({
     *   where: {
     *     // ... filter to delete one EmployeeDepartment
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDepartmentDeleteArgs>(args: SelectSubset<T, EmployeeDepartmentDeleteArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeDepartment.
     * @param {EmployeeDepartmentUpdateArgs} args - Arguments to update one EmployeeDepartment.
     * @example
     * // Update one EmployeeDepartment
     * const employeeDepartment = await prisma.employeeDepartment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeDepartmentUpdateArgs>(args: SelectSubset<T, EmployeeDepartmentUpdateArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeDepartments.
     * @param {EmployeeDepartmentDeleteManyArgs} args - Arguments to filter EmployeeDepartments to delete.
     * @example
     * // Delete a few EmployeeDepartments
     * const { count } = await prisma.employeeDepartment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDepartmentDeleteManyArgs>(args?: SelectSubset<T, EmployeeDepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeDepartments
     * const employeeDepartment = await prisma.employeeDepartment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeDepartmentUpdateManyArgs>(args: SelectSubset<T, EmployeeDepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeDepartments and returns the data updated in the database.
     * @param {EmployeeDepartmentUpdateManyAndReturnArgs} args - Arguments to update many EmployeeDepartments.
     * @example
     * // Update many EmployeeDepartments
     * const employeeDepartment = await prisma.employeeDepartment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeDepartments and only return the `shopId`
     * const employeeDepartmentWithShopIdOnly = await prisma.employeeDepartment.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeDepartmentUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeDepartmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeDepartment.
     * @param {EmployeeDepartmentUpsertArgs} args - Arguments to update or create a EmployeeDepartment.
     * @example
     * // Update or create a EmployeeDepartment
     * const employeeDepartment = await prisma.employeeDepartment.upsert({
     *   create: {
     *     // ... data to create a EmployeeDepartment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeDepartment we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeDepartmentUpsertArgs>(args: SelectSubset<T, EmployeeDepartmentUpsertArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeDepartments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentCountArgs} args - Arguments to filter EmployeeDepartments to count.
     * @example
     * // Count the number of EmployeeDepartments
     * const count = await prisma.employeeDepartment.count({
     *   where: {
     *     // ... the filter for the EmployeeDepartments we want to count
     *   }
     * })
    **/
    count<T extends EmployeeDepartmentCountArgs>(
      args?: Subset<T, EmployeeDepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeDepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeDepartmentAggregateArgs>(args: Subset<T, EmployeeDepartmentAggregateArgs>): Prisma.PrismaPromise<GetEmployeeDepartmentAggregateType<T>>

    /**
     * Group by EmployeeDepartment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeDepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeDepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeDepartmentGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeDepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeDepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeDepartment model
   */
  readonly fields: EmployeeDepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeDepartment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeDepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends EmployeeDepartment$employeesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDepartment$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeDepartment model
   */
  interface EmployeeDepartmentFieldRefs {
    readonly shopId: FieldRef<"EmployeeDepartment", 'String'>
    readonly name: FieldRef<"EmployeeDepartment", 'String'>
    readonly permissions: FieldRef<"EmployeeDepartment", 'String[]'>
    readonly status: FieldRef<"EmployeeDepartment", 'Status'>
    readonly createdAt: FieldRef<"EmployeeDepartment", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeDepartment", 'DateTime'>
    readonly id: FieldRef<"EmployeeDepartment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeDepartment findUnique
   */
  export type EmployeeDepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDepartment to fetch.
     */
    where: EmployeeDepartmentWhereUniqueInput
  }

  /**
   * EmployeeDepartment findUniqueOrThrow
   */
  export type EmployeeDepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDepartment to fetch.
     */
    where: EmployeeDepartmentWhereUniqueInput
  }

  /**
   * EmployeeDepartment findFirst
   */
  export type EmployeeDepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDepartment to fetch.
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDepartments to fetch.
     */
    orderBy?: EmployeeDepartmentOrderByWithRelationInput | EmployeeDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeDepartments.
     */
    cursor?: EmployeeDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeDepartments.
     */
    distinct?: EmployeeDepartmentScalarFieldEnum | EmployeeDepartmentScalarFieldEnum[]
  }

  /**
   * EmployeeDepartment findFirstOrThrow
   */
  export type EmployeeDepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDepartment to fetch.
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDepartments to fetch.
     */
    orderBy?: EmployeeDepartmentOrderByWithRelationInput | EmployeeDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeDepartments.
     */
    cursor?: EmployeeDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDepartments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeDepartments.
     */
    distinct?: EmployeeDepartmentScalarFieldEnum | EmployeeDepartmentScalarFieldEnum[]
  }

  /**
   * EmployeeDepartment findMany
   */
  export type EmployeeDepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeDepartments to fetch.
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeDepartments to fetch.
     */
    orderBy?: EmployeeDepartmentOrderByWithRelationInput | EmployeeDepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeDepartments.
     */
    cursor?: EmployeeDepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeDepartments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeDepartments.
     */
    skip?: number
    distinct?: EmployeeDepartmentScalarFieldEnum | EmployeeDepartmentScalarFieldEnum[]
  }

  /**
   * EmployeeDepartment create
   */
  export type EmployeeDepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeDepartment.
     */
    data: XOR<EmployeeDepartmentCreateInput, EmployeeDepartmentUncheckedCreateInput>
  }

  /**
   * EmployeeDepartment createMany
   */
  export type EmployeeDepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeDepartments.
     */
    data: EmployeeDepartmentCreateManyInput | EmployeeDepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeDepartment createManyAndReturn
   */
  export type EmployeeDepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeDepartments.
     */
    data: EmployeeDepartmentCreateManyInput | EmployeeDepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeDepartment update
   */
  export type EmployeeDepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeDepartment.
     */
    data: XOR<EmployeeDepartmentUpdateInput, EmployeeDepartmentUncheckedUpdateInput>
    /**
     * Choose, which EmployeeDepartment to update.
     */
    where: EmployeeDepartmentWhereUniqueInput
  }

  /**
   * EmployeeDepartment updateMany
   */
  export type EmployeeDepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeDepartments.
     */
    data: XOR<EmployeeDepartmentUpdateManyMutationInput, EmployeeDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeDepartments to update
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * Limit how many EmployeeDepartments to update.
     */
    limit?: number
  }

  /**
   * EmployeeDepartment updateManyAndReturn
   */
  export type EmployeeDepartmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeDepartments.
     */
    data: XOR<EmployeeDepartmentUpdateManyMutationInput, EmployeeDepartmentUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeDepartments to update
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * Limit how many EmployeeDepartments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeDepartment upsert
   */
  export type EmployeeDepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeDepartment to update in case it exists.
     */
    where: EmployeeDepartmentWhereUniqueInput
    /**
     * In case the EmployeeDepartment found by the `where` argument doesn't exist, create a new EmployeeDepartment with this data.
     */
    create: XOR<EmployeeDepartmentCreateInput, EmployeeDepartmentUncheckedCreateInput>
    /**
     * In case the EmployeeDepartment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeDepartmentUpdateInput, EmployeeDepartmentUncheckedUpdateInput>
  }

  /**
   * EmployeeDepartment delete
   */
  export type EmployeeDepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    /**
     * Filter which EmployeeDepartment to delete.
     */
    where: EmployeeDepartmentWhereUniqueInput
  }

  /**
   * EmployeeDepartment deleteMany
   */
  export type EmployeeDepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeDepartments to delete
     */
    where?: EmployeeDepartmentWhereInput
    /**
     * Limit how many EmployeeDepartments to delete.
     */
    limit?: number
  }

  /**
   * EmployeeDepartment.employees
   */
  export type EmployeeDepartment$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * EmployeeDepartment without action
   */
  export type EmployeeDepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
  }


  /**
   * Model EmployeePosition
   */

  export type AggregateEmployeePosition = {
    _count: EmployeePositionCountAggregateOutputType | null
    _min: EmployeePositionMinAggregateOutputType | null
    _max: EmployeePositionMaxAggregateOutputType | null
  }

  export type EmployeePositionMinAggregateOutputType = {
    shopId: string | null
    name: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type EmployeePositionMaxAggregateOutputType = {
    shopId: string | null
    name: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type EmployeePositionCountAggregateOutputType = {
    shopId: number
    name: number
    status: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type EmployeePositionMinAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type EmployeePositionMaxAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type EmployeePositionCountAggregateInputType = {
    shopId?: true
    name?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type EmployeePositionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeePosition to aggregate.
     */
    where?: EmployeePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePositions to fetch.
     */
    orderBy?: EmployeePositionOrderByWithRelationInput | EmployeePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeePositions
    **/
    _count?: true | EmployeePositionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeePositionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeePositionMaxAggregateInputType
  }

  export type GetEmployeePositionAggregateType<T extends EmployeePositionAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeePosition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeePosition[P]>
      : GetScalarType<T[P], AggregateEmployeePosition[P]>
  }




  export type EmployeePositionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeePositionWhereInput
    orderBy?: EmployeePositionOrderByWithAggregationInput | EmployeePositionOrderByWithAggregationInput[]
    by: EmployeePositionScalarFieldEnum[] | EmployeePositionScalarFieldEnum
    having?: EmployeePositionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeePositionCountAggregateInputType | true
    _min?: EmployeePositionMinAggregateInputType
    _max?: EmployeePositionMaxAggregateInputType
  }

  export type EmployeePositionGroupByOutputType = {
    shopId: string
    name: string | null
    status: $Enums.Status
    createdAt: Date
    updatedAt: Date
    id: string
    _count: EmployeePositionCountAggregateOutputType | null
    _min: EmployeePositionMinAggregateOutputType | null
    _max: EmployeePositionMaxAggregateOutputType | null
  }

  type GetEmployeePositionGroupByPayload<T extends EmployeePositionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeePositionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeePositionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeePositionGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeePositionGroupByOutputType[P]>
        }
      >
    >


  export type EmployeePositionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    employees?: boolean | EmployeePosition$employeesArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | EmployeePositionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeePosition"]>

  export type EmployeePositionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeePosition"]>

  export type EmployeePositionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeePosition"]>

  export type EmployeePositionSelectScalar = {
    shopId?: boolean
    name?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type EmployeePositionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "name" | "status" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["employeePosition"]>
  export type EmployeePositionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | EmployeePosition$employeesArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    _count?: boolean | EmployeePositionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeePositionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }
  export type EmployeePositionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shop?: boolean | ShopDefaultArgs<ExtArgs>
  }

  export type $EmployeePositionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeePosition"
    objects: {
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      shop: Prisma.$ShopPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      name: string | null
      status: $Enums.Status
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["employeePosition"]>
    composites: {}
  }

  type EmployeePositionGetPayload<S extends boolean | null | undefined | EmployeePositionDefaultArgs> = $Result.GetResult<Prisma.$EmployeePositionPayload, S>

  type EmployeePositionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeePositionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeePositionCountAggregateInputType | true
    }

  export interface EmployeePositionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeePosition'], meta: { name: 'EmployeePosition' } }
    /**
     * Find zero or one EmployeePosition that matches the filter.
     * @param {EmployeePositionFindUniqueArgs} args - Arguments to find a EmployeePosition
     * @example
     * // Get one EmployeePosition
     * const employeePosition = await prisma.employeePosition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeePositionFindUniqueArgs>(args: SelectSubset<T, EmployeePositionFindUniqueArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeePosition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeePositionFindUniqueOrThrowArgs} args - Arguments to find a EmployeePosition
     * @example
     * // Get one EmployeePosition
     * const employeePosition = await prisma.employeePosition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeePositionFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeePositionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeePosition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionFindFirstArgs} args - Arguments to find a EmployeePosition
     * @example
     * // Get one EmployeePosition
     * const employeePosition = await prisma.employeePosition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeePositionFindFirstArgs>(args?: SelectSubset<T, EmployeePositionFindFirstArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeePosition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionFindFirstOrThrowArgs} args - Arguments to find a EmployeePosition
     * @example
     * // Get one EmployeePosition
     * const employeePosition = await prisma.employeePosition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeePositionFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeePositionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeePositions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeePositions
     * const employeePositions = await prisma.employeePosition.findMany()
     * 
     * // Get first 10 EmployeePositions
     * const employeePositions = await prisma.employeePosition.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const employeePositionWithShopIdOnly = await prisma.employeePosition.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends EmployeePositionFindManyArgs>(args?: SelectSubset<T, EmployeePositionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeePosition.
     * @param {EmployeePositionCreateArgs} args - Arguments to create a EmployeePosition.
     * @example
     * // Create one EmployeePosition
     * const EmployeePosition = await prisma.employeePosition.create({
     *   data: {
     *     // ... data to create a EmployeePosition
     *   }
     * })
     * 
     */
    create<T extends EmployeePositionCreateArgs>(args: SelectSubset<T, EmployeePositionCreateArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeePositions.
     * @param {EmployeePositionCreateManyArgs} args - Arguments to create many EmployeePositions.
     * @example
     * // Create many EmployeePositions
     * const employeePosition = await prisma.employeePosition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeePositionCreateManyArgs>(args?: SelectSubset<T, EmployeePositionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeePositions and returns the data saved in the database.
     * @param {EmployeePositionCreateManyAndReturnArgs} args - Arguments to create many EmployeePositions.
     * @example
     * // Create many EmployeePositions
     * const employeePosition = await prisma.employeePosition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeePositions and only return the `shopId`
     * const employeePositionWithShopIdOnly = await prisma.employeePosition.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeePositionCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeePositionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeePosition.
     * @param {EmployeePositionDeleteArgs} args - Arguments to delete one EmployeePosition.
     * @example
     * // Delete one EmployeePosition
     * const EmployeePosition = await prisma.employeePosition.delete({
     *   where: {
     *     // ... filter to delete one EmployeePosition
     *   }
     * })
     * 
     */
    delete<T extends EmployeePositionDeleteArgs>(args: SelectSubset<T, EmployeePositionDeleteArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeePosition.
     * @param {EmployeePositionUpdateArgs} args - Arguments to update one EmployeePosition.
     * @example
     * // Update one EmployeePosition
     * const employeePosition = await prisma.employeePosition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeePositionUpdateArgs>(args: SelectSubset<T, EmployeePositionUpdateArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeePositions.
     * @param {EmployeePositionDeleteManyArgs} args - Arguments to filter EmployeePositions to delete.
     * @example
     * // Delete a few EmployeePositions
     * const { count } = await prisma.employeePosition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeePositionDeleteManyArgs>(args?: SelectSubset<T, EmployeePositionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeePositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeePositions
     * const employeePosition = await prisma.employeePosition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeePositionUpdateManyArgs>(args: SelectSubset<T, EmployeePositionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeePositions and returns the data updated in the database.
     * @param {EmployeePositionUpdateManyAndReturnArgs} args - Arguments to update many EmployeePositions.
     * @example
     * // Update many EmployeePositions
     * const employeePosition = await prisma.employeePosition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeePositions and only return the `shopId`
     * const employeePositionWithShopIdOnly = await prisma.employeePosition.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeePositionUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeePositionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeePosition.
     * @param {EmployeePositionUpsertArgs} args - Arguments to update or create a EmployeePosition.
     * @example
     * // Update or create a EmployeePosition
     * const employeePosition = await prisma.employeePosition.upsert({
     *   create: {
     *     // ... data to create a EmployeePosition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeePosition we want to update
     *   }
     * })
     */
    upsert<T extends EmployeePositionUpsertArgs>(args: SelectSubset<T, EmployeePositionUpsertArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeePositions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionCountArgs} args - Arguments to filter EmployeePositions to count.
     * @example
     * // Count the number of EmployeePositions
     * const count = await prisma.employeePosition.count({
     *   where: {
     *     // ... the filter for the EmployeePositions we want to count
     *   }
     * })
    **/
    count<T extends EmployeePositionCountArgs>(
      args?: Subset<T, EmployeePositionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeePositionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeePosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeePositionAggregateArgs>(args: Subset<T, EmployeePositionAggregateArgs>): Prisma.PrismaPromise<GetEmployeePositionAggregateType<T>>

    /**
     * Group by EmployeePosition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeePositionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeePositionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeePositionGroupByArgs['orderBy'] }
        : { orderBy?: EmployeePositionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeePositionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeePositionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeePosition model
   */
  readonly fields: EmployeePositionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeePosition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeePositionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employees<T extends EmployeePosition$employeesArgs<ExtArgs> = {}>(args?: Subset<T, EmployeePosition$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeePosition model
   */
  interface EmployeePositionFieldRefs {
    readonly shopId: FieldRef<"EmployeePosition", 'String'>
    readonly name: FieldRef<"EmployeePosition", 'String'>
    readonly status: FieldRef<"EmployeePosition", 'Status'>
    readonly createdAt: FieldRef<"EmployeePosition", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeePosition", 'DateTime'>
    readonly id: FieldRef<"EmployeePosition", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EmployeePosition findUnique
   */
  export type EmployeePositionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePosition to fetch.
     */
    where: EmployeePositionWhereUniqueInput
  }

  /**
   * EmployeePosition findUniqueOrThrow
   */
  export type EmployeePositionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePosition to fetch.
     */
    where: EmployeePositionWhereUniqueInput
  }

  /**
   * EmployeePosition findFirst
   */
  export type EmployeePositionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePosition to fetch.
     */
    where?: EmployeePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePositions to fetch.
     */
    orderBy?: EmployeePositionOrderByWithRelationInput | EmployeePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeePositions.
     */
    cursor?: EmployeePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeePositions.
     */
    distinct?: EmployeePositionScalarFieldEnum | EmployeePositionScalarFieldEnum[]
  }

  /**
   * EmployeePosition findFirstOrThrow
   */
  export type EmployeePositionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePosition to fetch.
     */
    where?: EmployeePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePositions to fetch.
     */
    orderBy?: EmployeePositionOrderByWithRelationInput | EmployeePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeePositions.
     */
    cursor?: EmployeePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePositions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeePositions.
     */
    distinct?: EmployeePositionScalarFieldEnum | EmployeePositionScalarFieldEnum[]
  }

  /**
   * EmployeePosition findMany
   */
  export type EmployeePositionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * Filter, which EmployeePositions to fetch.
     */
    where?: EmployeePositionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeePositions to fetch.
     */
    orderBy?: EmployeePositionOrderByWithRelationInput | EmployeePositionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeePositions.
     */
    cursor?: EmployeePositionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeePositions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeePositions.
     */
    skip?: number
    distinct?: EmployeePositionScalarFieldEnum | EmployeePositionScalarFieldEnum[]
  }

  /**
   * EmployeePosition create
   */
  export type EmployeePositionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeePosition.
     */
    data: XOR<EmployeePositionCreateInput, EmployeePositionUncheckedCreateInput>
  }

  /**
   * EmployeePosition createMany
   */
  export type EmployeePositionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeePositions.
     */
    data: EmployeePositionCreateManyInput | EmployeePositionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeePosition createManyAndReturn
   */
  export type EmployeePositionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeePositions.
     */
    data: EmployeePositionCreateManyInput | EmployeePositionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeePosition update
   */
  export type EmployeePositionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeePosition.
     */
    data: XOR<EmployeePositionUpdateInput, EmployeePositionUncheckedUpdateInput>
    /**
     * Choose, which EmployeePosition to update.
     */
    where: EmployeePositionWhereUniqueInput
  }

  /**
   * EmployeePosition updateMany
   */
  export type EmployeePositionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeePositions.
     */
    data: XOR<EmployeePositionUpdateManyMutationInput, EmployeePositionUncheckedUpdateManyInput>
    /**
     * Filter which EmployeePositions to update
     */
    where?: EmployeePositionWhereInput
    /**
     * Limit how many EmployeePositions to update.
     */
    limit?: number
  }

  /**
   * EmployeePosition updateManyAndReturn
   */
  export type EmployeePositionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * The data used to update EmployeePositions.
     */
    data: XOR<EmployeePositionUpdateManyMutationInput, EmployeePositionUncheckedUpdateManyInput>
    /**
     * Filter which EmployeePositions to update
     */
    where?: EmployeePositionWhereInput
    /**
     * Limit how many EmployeePositions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeePosition upsert
   */
  export type EmployeePositionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeePosition to update in case it exists.
     */
    where: EmployeePositionWhereUniqueInput
    /**
     * In case the EmployeePosition found by the `where` argument doesn't exist, create a new EmployeePosition with this data.
     */
    create: XOR<EmployeePositionCreateInput, EmployeePositionUncheckedCreateInput>
    /**
     * In case the EmployeePosition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeePositionUpdateInput, EmployeePositionUncheckedUpdateInput>
  }

  /**
   * EmployeePosition delete
   */
  export type EmployeePositionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    /**
     * Filter which EmployeePosition to delete.
     */
    where: EmployeePositionWhereUniqueInput
  }

  /**
   * EmployeePosition deleteMany
   */
  export type EmployeePositionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeePositions to delete
     */
    where?: EmployeePositionWhereInput
    /**
     * Limit how many EmployeePositions to delete.
     */
    limit?: number
  }

  /**
   * EmployeePosition.employees
   */
  export type EmployeePosition$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * EmployeePosition without action
   */
  export type EmployeePositionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    shopId: string | null
    userId: string | null
    name: string | null
    positionId: string | null
    departmentId: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type EmployeeMaxAggregateOutputType = {
    shopId: string | null
    userId: string | null
    name: string | null
    positionId: string | null
    departmentId: string | null
    status: $Enums.Status | null
    createdAt: Date | null
    updatedAt: Date | null
    id: string | null
  }

  export type EmployeeCountAggregateOutputType = {
    shopId: number
    userId: number
    name: number
    positionId: number
    departmentId: number
    status: number
    permissions: number
    createdAt: number
    updatedAt: number
    id: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    shopId?: true
    userId?: true
    name?: true
    positionId?: true
    departmentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type EmployeeMaxAggregateInputType = {
    shopId?: true
    userId?: true
    name?: true
    positionId?: true
    departmentId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    id?: true
  }

  export type EmployeeCountAggregateInputType = {
    shopId?: true
    userId?: true
    name?: true
    positionId?: true
    departmentId?: true
    status?: true
    permissions?: true
    createdAt?: true
    updatedAt?: true
    id?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    shopId: string
    userId: string
    name: string | null
    positionId: string | null
    departmentId: string | null
    status: $Enums.Status
    permissions: string[]
    createdAt: Date
    updatedAt: Date
    id: string
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    userId?: boolean
    name?: boolean
    positionId?: boolean
    departmentId?: boolean
    status?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    userId?: boolean
    name?: boolean
    positionId?: boolean
    departmentId?: boolean
    status?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    shopId?: boolean
    userId?: boolean
    name?: boolean
    positionId?: boolean
    departmentId?: boolean
    status?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    shopId?: boolean
    userId?: boolean
    name?: boolean
    positionId?: boolean
    departmentId?: boolean
    status?: boolean
    permissions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    id?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"shopId" | "userId" | "name" | "positionId" | "departmentId" | "status" | "permissions" | "createdAt" | "updatedAt" | "id", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    position?: boolean | Employee$positionArgs<ExtArgs>
    shop?: boolean | ShopDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      department: Prisma.$EmployeeDepartmentPayload<ExtArgs> | null
      position: Prisma.$EmployeePositionPayload<ExtArgs> | null
      shop: Prisma.$ShopPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      shopId: string
      userId: string
      name: string | null
      positionId: string | null
      departmentId: string | null
      status: $Enums.Status
      permissions: string[]
      createdAt: Date
      updatedAt: Date
      id: string
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `shopId`
     * const employeeWithShopIdOnly = await prisma.employee.findMany({ select: { shopId: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `shopId`
     * const employeeWithShopIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { shopId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `shopId`
     * const employeeWithShopIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { shopId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__EmployeeDepartmentClient<$Result.GetResult<Prisma.$EmployeeDepartmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    position<T extends Employee$positionArgs<ExtArgs> = {}>(args?: Subset<T, Employee$positionArgs<ExtArgs>>): Prisma__EmployeePositionClient<$Result.GetResult<Prisma.$EmployeePositionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shop<T extends ShopDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShopDefaultArgs<ExtArgs>>): Prisma__ShopClient<$Result.GetResult<Prisma.$ShopPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly shopId: FieldRef<"Employee", 'String'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly positionId: FieldRef<"Employee", 'String'>
    readonly departmentId: FieldRef<"Employee", 'String'>
    readonly status: FieldRef<"Employee", 'Status'>
    readonly permissions: FieldRef<"Employee", 'String[]'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
    readonly id: FieldRef<"Employee", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeDepartment
     */
    select?: EmployeeDepartmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeDepartment
     */
    omit?: EmployeeDepartmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeDepartmentInclude<ExtArgs> | null
    where?: EmployeeDepartmentWhereInput
  }

  /**
   * Employee.position
   */
  export type Employee$positionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeePosition
     */
    select?: EmployeePositionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeePosition
     */
    omit?: EmployeePositionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeePositionInclude<ExtArgs> | null
    where?: EmployeePositionWhereInput
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    name: 'name',
    email: 'email',
    phone: 'phone',
    password: 'password',
    role: 'role',
    isEmailVerified: 'isEmailVerified',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    password: 'password',
    address: 'address',
    anonymous: 'anonymous',
    totalOrderTimes: 'totalOrderTimes',
    totalOrderValue: 'totalOrderValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    type: 'type',
    expires: 'expires',
    blacklisted: 'blacklisted',
    isCustomer: 'isCustomer',
    userId: 'userId',
    customerId: 'customerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const KitchenScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KitchenScalarFieldEnum = (typeof KitchenScalarFieldEnum)[keyof typeof KitchenScalarFieldEnum]


  export const KitchenLogScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    userId: 'userId',
    orderId: 'orderId',
    dishOrderId: 'dishOrderId',
    dishName: 'dishName',
    dishQuantity: 'dishQuantity',
    status: 'status',
    action: 'action',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KitchenLogScalarFieldEnum = (typeof KitchenLogScalarFieldEnum)[keyof typeof KitchenLogScalarFieldEnum]


  export const DishOrderScalarFieldEnum: {
    id: 'id',
    dishOrderNo: 'dishOrderNo',
    dishId: 'dishId',
    name: 'name',
    unit: 'unit',
    price: 'price',
    isTaxIncludedPrice: 'isTaxIncludedPrice',
    taxIncludedPrice: 'taxIncludedPrice',
    quantity: 'quantity',
    beforeTaxTotalPrice: 'beforeTaxTotalPrice',
    afterTaxTotalPrice: 'afterTaxTotalPrice',
    taxRate: 'taxRate',
    taxAmount: 'taxAmount',
    beforeTaxTotalDiscountAmount: 'beforeTaxTotalDiscountAmount',
    afterTaxTotalDiscountAmount: 'afterTaxTotalDiscountAmount',
    taxTotalDiscountAmount: 'taxTotalDiscountAmount',
    paymentAmount: 'paymentAmount',
    status: 'status',
    returnedAt: 'returnedAt',
    note: 'note',
    orderId: 'orderId',
    returnedOrderId: 'returnedOrderId'
  };

  export type DishOrderScalarFieldEnum = (typeof DishOrderScalarFieldEnum)[keyof typeof DishOrderScalarFieldEnum]


  export const OrderScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    tableId: 'tableId',
    orderSessionId: 'orderSessionId',
    orderNo: 'orderNo',
    customerId: 'customerId',
    totalQuantity: 'totalQuantity',
    totalBeforeTaxAmount: 'totalBeforeTaxAmount',
    totalAfterTaxAmount: 'totalAfterTaxAmount',
    approvedById: 'approvedById',
    cancelledById: 'cancelledById',
    status: 'status',
    orderSessionStatus: 'orderSessionStatus',
    numberOfCustomer: 'numberOfCustomer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderScalarFieldEnum = (typeof OrderScalarFieldEnum)[keyof typeof OrderScalarFieldEnum]


  export const DiscountProductScalarFieldEnum: {
    id: 'id',
    dishOrderId: 'dishOrderId',
    dishId: 'dishId',
    dishName: 'dishName',
    discountRate: 'discountRate',
    discountValue: 'discountValue',
    discountValueType: 'discountValueType',
    beforeTaxDiscountPrice: 'beforeTaxDiscountPrice',
    afterTaxDiscountPrice: 'afterTaxDiscountPrice',
    taxDiscountPrice: 'taxDiscountPrice',
    discountId: 'discountId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountProductScalarFieldEnum = (typeof DiscountProductScalarFieldEnum)[keyof typeof DiscountProductScalarFieldEnum]


  export const DiscountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    discountType: 'discountType',
    discountValue: 'discountValue',
    discountValueType: 'discountValueType',
    beforeTaxTotalDiscountAmount: 'beforeTaxTotalDiscountAmount',
    afterTaxTotalDiscountAmount: 'afterTaxTotalDiscountAmount',
    taxTotalDiscountAmount: 'taxTotalDiscountAmount',
    orderSessionId: 'orderSessionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DiscountScalarFieldEnum = (typeof DiscountScalarFieldEnum)[keyof typeof DiscountScalarFieldEnum]


  export const TaxDetailScalarFieldEnum: {
    id: 'id',
    taxAmount: 'taxAmount',
    taxRate: 'taxRate',
    orderSessionId: 'orderSessionId'
  };

  export type TaxDetailScalarFieldEnum = (typeof TaxDetailScalarFieldEnum)[keyof typeof TaxDetailScalarFieldEnum]


  export const PaymentDetailScalarFieldEnum: {
    id: 'id',
    paymentMethod: 'paymentMethod',
    paymentAmount: 'paymentAmount',
    orderSessionId: 'orderSessionId'
  };

  export type PaymentDetailScalarFieldEnum = (typeof PaymentDetailScalarFieldEnum)[keyof typeof PaymentDetailScalarFieldEnum]


  export const OrderSessionScalarFieldEnum: {
    id: 'id',
    shopId: 'shopId',
    tableIds: 'tableIds',
    tableNames: 'tableNames',
    orderSessionNo: 'orderSessionNo',
    taxRate: 'taxRate',
    totalTaxAmount: 'totalTaxAmount',
    endedAt: 'endedAt',
    auditedAt: 'auditedAt',
    status: 'status',
    pretaxPaymentAmount: 'pretaxPaymentAmount',
    paymentAmount: 'paymentAmount',
    paidByEmployeeId: 'paidByEmployeeId',
    paidByEmployeeName: 'paidByEmployeeName',
    cancelledByEmployeeId: 'cancelledByEmployeeId',
    cancelledByEmployeeName: 'cancelledByEmployeeName',
    cancellationReason: 'cancellationReason',
    customerId: 'customerId',
    customerName: 'customerName',
    customerPhone: 'customerPhone',
    customerAddress: 'customerAddress',
    numberOfCustomer: 'numberOfCustomer',
    totalDiscountAmountBeforeTax: 'totalDiscountAmountBeforeTax',
    totalDiscountAmountAfterTax: 'totalDiscountAmountAfterTax',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type OrderSessionScalarFieldEnum = (typeof OrderSessionScalarFieldEnum)[keyof typeof OrderSessionScalarFieldEnum]


  export const ShopScalarFieldEnum: {
    status: 'status',
    name: 'name',
    phone: 'phone',
    email: 'email',
    ownerId: 'ownerId',
    taxRate: 'taxRate',
    location: 'location',
    dishPriceRoundingType: 'dishPriceRoundingType',
    discountRoundingType: 'discountRoundingType',
    taxRoundingType: 'taxRoundingType',
    calculateTaxDirectly: 'calculateTaxDirectly',
    countryName: 'countryName',
    countryCurrency: 'countryCurrency',
    utcOffset: 'utcOffset',
    timezone: 'timezone',
    reportTime: 'reportTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type ShopScalarFieldEnum = (typeof ShopScalarFieldEnum)[keyof typeof ShopScalarFieldEnum]


  export const ImageScalarFieldEnum: {
    url: 'url',
    shopId: 'shopId',
    dishId: 'dishId',
    id: 'id'
  };

  export type ImageScalarFieldEnum = (typeof ImageScalarFieldEnum)[keyof typeof ImageScalarFieldEnum]


  export const DishCategoryScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    code: 'code',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type DishCategoryScalarFieldEnum = (typeof DishCategoryScalarFieldEnum)[keyof typeof DishCategoryScalarFieldEnum]


  export const DishScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    code: 'code',
    unitId: 'unitId',
    price: 'price',
    taxIncludedPrice: 'taxIncludedPrice',
    isTaxIncludedPrice: 'isTaxIncludedPrice',
    categoryId: 'categoryId',
    type: 'type',
    taxRate: 'taxRate',
    status: 'status',
    isNewlyCreated: 'isNewlyCreated',
    isBestSeller: 'isBestSeller',
    stockQuantity: 'stockQuantity',
    hideForCustomers: 'hideForCustomers',
    hideForEmployees: 'hideForEmployees',
    outOfStockNotification: 'outOfStockNotification',
    description: 'description',
    soldCount: 'soldCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type DishScalarFieldEnum = (typeof DishScalarFieldEnum)[keyof typeof DishScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    code: 'code',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const TablePositionScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    dishCategoryIds: 'dishCategoryIds',
    tableIds: 'tableIds',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type TablePositionScalarFieldEnum = (typeof TablePositionScalarFieldEnum)[keyof typeof TablePositionScalarFieldEnum]


  export const TableScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    positionId: 'positionId',
    status: 'status',
    allowMultipleOrderSession: 'allowMultipleOrderSession',
    needApprovalWhenCustomerOrder: 'needApprovalWhenCustomerOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id',
    kitchenId: 'kitchenId'
  };

  export type TableScalarFieldEnum = (typeof TableScalarFieldEnum)[keyof typeof TableScalarFieldEnum]


  export const EmployeeDepartmentScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    permissions: 'permissions',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type EmployeeDepartmentScalarFieldEnum = (typeof EmployeeDepartmentScalarFieldEnum)[keyof typeof EmployeeDepartmentScalarFieldEnum]


  export const EmployeePositionScalarFieldEnum: {
    shopId: 'shopId',
    name: 'name',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type EmployeePositionScalarFieldEnum = (typeof EmployeePositionScalarFieldEnum)[keyof typeof EmployeePositionScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    shopId: 'shopId',
    userId: 'userId',
    name: 'name',
    positionId: 'positionId',
    departmentId: 'departmentId',
    status: 'status',
    permissions: 'permissions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    id: 'id'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TokenType'
   */
  export type EnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType'>
    


  /**
   * Reference to a field of type 'TokenType[]'
   */
  export type ListEnumTokenTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TokenType[]'>
    


  /**
   * Reference to a field of type 'Switchabletatus'
   */
  export type EnumSwitchabletatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Switchabletatus'>
    


  /**
   * Reference to a field of type 'Switchabletatus[]'
   */
  export type ListEnumSwitchabletatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Switchabletatus[]'>
    


  /**
   * Reference to a field of type 'KitchenActionEnum'
   */
  export type EnumKitchenActionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KitchenActionEnum'>
    


  /**
   * Reference to a field of type 'KitchenActionEnum[]'
   */
  export type ListEnumKitchenActionEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KitchenActionEnum[]'>
    


  /**
   * Reference to a field of type 'DishOrderStatus'
   */
  export type EnumDishOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DishOrderStatus'>
    


  /**
   * Reference to a field of type 'DishOrderStatus[]'
   */
  export type ListEnumDishOrderStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DishOrderStatus[]'>
    


  /**
   * Reference to a field of type 'OrderSessionStatus'
   */
  export type EnumOrderSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderSessionStatus'>
    


  /**
   * Reference to a field of type 'OrderSessionStatus[]'
   */
  export type ListEnumOrderSessionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OrderSessionStatus[]'>
    


  /**
   * Reference to a field of type 'DiscountValueType'
   */
  export type EnumDiscountValueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountValueType'>
    


  /**
   * Reference to a field of type 'DiscountValueType[]'
   */
  export type ListEnumDiscountValueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountValueType[]'>
    


  /**
   * Reference to a field of type 'DiscountType'
   */
  export type EnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType'>
    


  /**
   * Reference to a field of type 'DiscountType[]'
   */
  export type ListEnumDiscountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DiscountType[]'>
    


  /**
   * Reference to a field of type 'PaymentMethodEnum'
   */
  export type EnumPaymentMethodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodEnum'>
    


  /**
   * Reference to a field of type 'PaymentMethodEnum[]'
   */
  export type ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethodEnum[]'>
    


  /**
   * Reference to a field of type 'RoundingPaymentType'
   */
  export type EnumRoundingPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoundingPaymentType'>
    


  /**
   * Reference to a field of type 'RoundingPaymentType[]'
   */
  export type ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoundingPaymentType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isEmailVerified?: BoolFilter<"User"> | boolean
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    id?: StringFilter<"User"> | string
    employee?: EmployeeListRelationFilter
    shop?: ShopListRelationFilter
    token?: TokenListRelationFilter
    kitchenLog?: KitchenLogListRelationFilter
    approveOrder?: OrderListRelationFilter
    cancelledOrder?: OrderListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    employee?: EmployeeOrderByRelationAggregateInput
    shop?: ShopOrderByRelationAggregateInput
    token?: TokenOrderByRelationAggregateInput
    kitchenLog?: KitchenLogOrderByRelationAggregateInput
    approveOrder?: OrderOrderByRelationAggregateInput
    cancelledOrder?: OrderOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    phone?: string
    id?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    isEmailVerified?: BoolFilter<"User"> | boolean
    status?: EnumStatusFilter<"User"> | $Enums.Status
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    employee?: EmployeeListRelationFilter
    shop?: ShopListRelationFilter
    token?: TokenListRelationFilter
    kitchenLog?: KitchenLogListRelationFilter
    approveOrder?: OrderListRelationFilter
    cancelledOrder?: OrderListRelationFilter
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    status?: EnumStatusWithAggregatesFilter<"User"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    id?: StringWithAggregatesFilter<"User"> | string
  }

  export type CustomerWhereInput = {
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    id?: StringFilter<"Customer"> | string
    name?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    password?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    anonymous?: BoolNullableFilter<"Customer"> | boolean | null
    totalOrderTimes?: IntNullableFilter<"Customer"> | number | null
    totalOrderValue?: FloatNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    tokens?: TokenListRelationFilter
    Order?: OrderListRelationFilter
  }

  export type CustomerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    anonymous?: SortOrderInput | SortOrder
    totalOrderTimes?: SortOrderInput | SortOrder
    totalOrderValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tokens?: TokenOrderByRelationAggregateInput
    Order?: OrderOrderByRelationAggregateInput
  }

  export type CustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CustomerWhereInput | CustomerWhereInput[]
    OR?: CustomerWhereInput[]
    NOT?: CustomerWhereInput | CustomerWhereInput[]
    name?: StringNullableFilter<"Customer"> | string | null
    phone?: StringNullableFilter<"Customer"> | string | null
    email?: StringNullableFilter<"Customer"> | string | null
    password?: StringNullableFilter<"Customer"> | string | null
    address?: StringNullableFilter<"Customer"> | string | null
    anonymous?: BoolNullableFilter<"Customer"> | boolean | null
    totalOrderTimes?: IntNullableFilter<"Customer"> | number | null
    totalOrderValue?: FloatNullableFilter<"Customer"> | number | null
    createdAt?: DateTimeFilter<"Customer"> | Date | string
    updatedAt?: DateTimeFilter<"Customer"> | Date | string
    tokens?: TokenListRelationFilter
    Order?: OrderListRelationFilter
  }, "id">

  export type CustomerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    anonymous?: SortOrderInput | SortOrder
    totalOrderTimes?: SortOrderInput | SortOrder
    totalOrderValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CustomerCountOrderByAggregateInput
    _avg?: CustomerAvgOrderByAggregateInput
    _max?: CustomerMaxOrderByAggregateInput
    _min?: CustomerMinOrderByAggregateInput
    _sum?: CustomerSumOrderByAggregateInput
  }

  export type CustomerScalarWhereWithAggregatesInput = {
    AND?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    OR?: CustomerScalarWhereWithAggregatesInput[]
    NOT?: CustomerScalarWhereWithAggregatesInput | CustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Customer"> | string
    name?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    email?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    password?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    address?: StringNullableWithAggregatesFilter<"Customer"> | string | null
    anonymous?: BoolNullableWithAggregatesFilter<"Customer"> | boolean | null
    totalOrderTimes?: IntNullableWithAggregatesFilter<"Customer"> | number | null
    totalOrderValue?: FloatNullableWithAggregatesFilter<"Customer"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Customer"> | Date | string
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: StringFilter<"Token"> | string
    token?: StringFilter<"Token"> | string
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    expires?: DateTimeFilter<"Token"> | Date | string
    blacklisted?: BoolFilter<"Token"> | boolean
    isCustomer?: BoolFilter<"Token"> | boolean
    userId?: StringNullableFilter<"Token"> | string | null
    customerId?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    isCustomer?: SortOrder
    userId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    expires?: DateTimeFilter<"Token"> | Date | string
    blacklisted?: BoolFilter<"Token"> | boolean
    isCustomer?: BoolFilter<"Token"> | boolean
    userId?: StringNullableFilter<"Token"> | string | null
    customerId?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
  }, "id" | "token">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    isCustomer?: SortOrder
    userId?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Token"> | string
    token?: StringWithAggregatesFilter<"Token"> | string
    type?: EnumTokenTypeWithAggregatesFilter<"Token"> | $Enums.TokenType
    expires?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    blacklisted?: BoolWithAggregatesFilter<"Token"> | boolean
    isCustomer?: BoolWithAggregatesFilter<"Token"> | boolean
    userId?: StringNullableWithAggregatesFilter<"Token"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"Token"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type KitchenWhereInput = {
    AND?: KitchenWhereInput | KitchenWhereInput[]
    OR?: KitchenWhereInput[]
    NOT?: KitchenWhereInput | KitchenWhereInput[]
    id?: StringFilter<"Kitchen"> | string
    shopId?: StringFilter<"Kitchen"> | string
    name?: StringFilter<"Kitchen"> | string
    status?: EnumSwitchabletatusFilter<"Kitchen"> | $Enums.Switchabletatus
    createdAt?: DateTimeFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeFilter<"Kitchen"> | Date | string
    dishCategories?: DishCategoryListRelationFilter
    tables?: TableListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }

  export type KitchenOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dishCategories?: DishCategoryOrderByRelationAggregateInput
    tables?: TableOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
  }

  export type KitchenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KitchenWhereInput | KitchenWhereInput[]
    OR?: KitchenWhereInput[]
    NOT?: KitchenWhereInput | KitchenWhereInput[]
    shopId?: StringFilter<"Kitchen"> | string
    name?: StringFilter<"Kitchen"> | string
    status?: EnumSwitchabletatusFilter<"Kitchen"> | $Enums.Switchabletatus
    createdAt?: DateTimeFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeFilter<"Kitchen"> | Date | string
    dishCategories?: DishCategoryListRelationFilter
    tables?: TableListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }, "id">

  export type KitchenOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KitchenCountOrderByAggregateInput
    _max?: KitchenMaxOrderByAggregateInput
    _min?: KitchenMinOrderByAggregateInput
  }

  export type KitchenScalarWhereWithAggregatesInput = {
    AND?: KitchenScalarWhereWithAggregatesInput | KitchenScalarWhereWithAggregatesInput[]
    OR?: KitchenScalarWhereWithAggregatesInput[]
    NOT?: KitchenScalarWhereWithAggregatesInput | KitchenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Kitchen"> | string
    shopId?: StringWithAggregatesFilter<"Kitchen"> | string
    name?: StringWithAggregatesFilter<"Kitchen"> | string
    status?: EnumSwitchabletatusWithAggregatesFilter<"Kitchen"> | $Enums.Switchabletatus
    createdAt?: DateTimeWithAggregatesFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Kitchen"> | Date | string
  }

  export type KitchenLogWhereInput = {
    AND?: KitchenLogWhereInput | KitchenLogWhereInput[]
    OR?: KitchenLogWhereInput[]
    NOT?: KitchenLogWhereInput | KitchenLogWhereInput[]
    id?: StringFilter<"KitchenLog"> | string
    shopId?: StringFilter<"KitchenLog"> | string
    userId?: StringFilter<"KitchenLog"> | string
    orderId?: StringFilter<"KitchenLog"> | string
    dishOrderId?: StringFilter<"KitchenLog"> | string
    dishName?: StringFilter<"KitchenLog"> | string
    dishQuantity?: IntFilter<"KitchenLog"> | number
    status?: EnumStatusFilter<"KitchenLog"> | $Enums.Status
    action?: EnumKitchenActionEnumFilter<"KitchenLog"> | $Enums.KitchenActionEnum
    createdAt?: DateTimeFilter<"KitchenLog"> | Date | string
    updatedAt?: DateTimeFilter<"KitchenLog"> | Date | string
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }

  export type KitchenLogOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    dishOrderId?: SortOrder
    dishName?: SortOrder
    dishQuantity?: SortOrder
    status?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    shop?: ShopOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    order?: OrderOrderByWithRelationInput
  }

  export type KitchenLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KitchenLogWhereInput | KitchenLogWhereInput[]
    OR?: KitchenLogWhereInput[]
    NOT?: KitchenLogWhereInput | KitchenLogWhereInput[]
    shopId?: StringFilter<"KitchenLog"> | string
    userId?: StringFilter<"KitchenLog"> | string
    orderId?: StringFilter<"KitchenLog"> | string
    dishOrderId?: StringFilter<"KitchenLog"> | string
    dishName?: StringFilter<"KitchenLog"> | string
    dishQuantity?: IntFilter<"KitchenLog"> | number
    status?: EnumStatusFilter<"KitchenLog"> | $Enums.Status
    action?: EnumKitchenActionEnumFilter<"KitchenLog"> | $Enums.KitchenActionEnum
    createdAt?: DateTimeFilter<"KitchenLog"> | Date | string
    updatedAt?: DateTimeFilter<"KitchenLog"> | Date | string
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    order?: XOR<OrderScalarRelationFilter, OrderWhereInput>
  }, "id">

  export type KitchenLogOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    dishOrderId?: SortOrder
    dishName?: SortOrder
    dishQuantity?: SortOrder
    status?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KitchenLogCountOrderByAggregateInput
    _avg?: KitchenLogAvgOrderByAggregateInput
    _max?: KitchenLogMaxOrderByAggregateInput
    _min?: KitchenLogMinOrderByAggregateInput
    _sum?: KitchenLogSumOrderByAggregateInput
  }

  export type KitchenLogScalarWhereWithAggregatesInput = {
    AND?: KitchenLogScalarWhereWithAggregatesInput | KitchenLogScalarWhereWithAggregatesInput[]
    OR?: KitchenLogScalarWhereWithAggregatesInput[]
    NOT?: KitchenLogScalarWhereWithAggregatesInput | KitchenLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KitchenLog"> | string
    shopId?: StringWithAggregatesFilter<"KitchenLog"> | string
    userId?: StringWithAggregatesFilter<"KitchenLog"> | string
    orderId?: StringWithAggregatesFilter<"KitchenLog"> | string
    dishOrderId?: StringWithAggregatesFilter<"KitchenLog"> | string
    dishName?: StringWithAggregatesFilter<"KitchenLog"> | string
    dishQuantity?: IntWithAggregatesFilter<"KitchenLog"> | number
    status?: EnumStatusWithAggregatesFilter<"KitchenLog"> | $Enums.Status
    action?: EnumKitchenActionEnumWithAggregatesFilter<"KitchenLog"> | $Enums.KitchenActionEnum
    createdAt?: DateTimeWithAggregatesFilter<"KitchenLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KitchenLog"> | Date | string
  }

  export type DishOrderWhereInput = {
    AND?: DishOrderWhereInput | DishOrderWhereInput[]
    OR?: DishOrderWhereInput[]
    NOT?: DishOrderWhereInput | DishOrderWhereInput[]
    id?: StringFilter<"DishOrder"> | string
    dishOrderNo?: IntNullableFilter<"DishOrder"> | number | null
    dishId?: StringFilter<"DishOrder"> | string
    name?: StringFilter<"DishOrder"> | string
    unit?: StringFilter<"DishOrder"> | string
    price?: FloatFilter<"DishOrder"> | number
    isTaxIncludedPrice?: BoolFilter<"DishOrder"> | boolean
    taxIncludedPrice?: FloatNullableFilter<"DishOrder"> | number | null
    quantity?: IntFilter<"DishOrder"> | number
    beforeTaxTotalPrice?: FloatFilter<"DishOrder"> | number
    afterTaxTotalPrice?: FloatFilter<"DishOrder"> | number
    taxRate?: FloatFilter<"DishOrder"> | number
    taxAmount?: FloatFilter<"DishOrder"> | number
    beforeTaxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    afterTaxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    taxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    paymentAmount?: FloatFilter<"DishOrder"> | number
    status?: EnumDishOrderStatusFilter<"DishOrder"> | $Enums.DishOrderStatus
    returnedAt?: DateTimeNullableFilter<"DishOrder"> | Date | string | null
    note?: StringNullableFilter<"DishOrder"> | string | null
    orderId?: StringNullableFilter<"DishOrder"> | string | null
    returnedOrderId?: StringNullableFilter<"DishOrder"> | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    returnedOrder?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }

  export type DishOrderOrderByWithRelationInput = {
    id?: SortOrder
    dishOrderNo?: SortOrderInput | SortOrder
    dishId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    isTaxIncludedPrice?: SortOrder
    taxIncludedPrice?: SortOrderInput | SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
    status?: SortOrder
    returnedAt?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    returnedOrderId?: SortOrderInput | SortOrder
    order?: OrderOrderByWithRelationInput
    returnedOrder?: OrderOrderByWithRelationInput
  }

  export type DishOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DishOrderWhereInput | DishOrderWhereInput[]
    OR?: DishOrderWhereInput[]
    NOT?: DishOrderWhereInput | DishOrderWhereInput[]
    dishOrderNo?: IntNullableFilter<"DishOrder"> | number | null
    dishId?: StringFilter<"DishOrder"> | string
    name?: StringFilter<"DishOrder"> | string
    unit?: StringFilter<"DishOrder"> | string
    price?: FloatFilter<"DishOrder"> | number
    isTaxIncludedPrice?: BoolFilter<"DishOrder"> | boolean
    taxIncludedPrice?: FloatNullableFilter<"DishOrder"> | number | null
    quantity?: IntFilter<"DishOrder"> | number
    beforeTaxTotalPrice?: FloatFilter<"DishOrder"> | number
    afterTaxTotalPrice?: FloatFilter<"DishOrder"> | number
    taxRate?: FloatFilter<"DishOrder"> | number
    taxAmount?: FloatFilter<"DishOrder"> | number
    beforeTaxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    afterTaxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    taxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    paymentAmount?: FloatFilter<"DishOrder"> | number
    status?: EnumDishOrderStatusFilter<"DishOrder"> | $Enums.DishOrderStatus
    returnedAt?: DateTimeNullableFilter<"DishOrder"> | Date | string | null
    note?: StringNullableFilter<"DishOrder"> | string | null
    orderId?: StringNullableFilter<"DishOrder"> | string | null
    returnedOrderId?: StringNullableFilter<"DishOrder"> | string | null
    order?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
    returnedOrder?: XOR<OrderNullableScalarRelationFilter, OrderWhereInput> | null
  }, "id">

  export type DishOrderOrderByWithAggregationInput = {
    id?: SortOrder
    dishOrderNo?: SortOrderInput | SortOrder
    dishId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    isTaxIncludedPrice?: SortOrder
    taxIncludedPrice?: SortOrderInput | SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
    status?: SortOrder
    returnedAt?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    orderId?: SortOrderInput | SortOrder
    returnedOrderId?: SortOrderInput | SortOrder
    _count?: DishOrderCountOrderByAggregateInput
    _avg?: DishOrderAvgOrderByAggregateInput
    _max?: DishOrderMaxOrderByAggregateInput
    _min?: DishOrderMinOrderByAggregateInput
    _sum?: DishOrderSumOrderByAggregateInput
  }

  export type DishOrderScalarWhereWithAggregatesInput = {
    AND?: DishOrderScalarWhereWithAggregatesInput | DishOrderScalarWhereWithAggregatesInput[]
    OR?: DishOrderScalarWhereWithAggregatesInput[]
    NOT?: DishOrderScalarWhereWithAggregatesInput | DishOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DishOrder"> | string
    dishOrderNo?: IntNullableWithAggregatesFilter<"DishOrder"> | number | null
    dishId?: StringWithAggregatesFilter<"DishOrder"> | string
    name?: StringWithAggregatesFilter<"DishOrder"> | string
    unit?: StringWithAggregatesFilter<"DishOrder"> | string
    price?: FloatWithAggregatesFilter<"DishOrder"> | number
    isTaxIncludedPrice?: BoolWithAggregatesFilter<"DishOrder"> | boolean
    taxIncludedPrice?: FloatNullableWithAggregatesFilter<"DishOrder"> | number | null
    quantity?: IntWithAggregatesFilter<"DishOrder"> | number
    beforeTaxTotalPrice?: FloatWithAggregatesFilter<"DishOrder"> | number
    afterTaxTotalPrice?: FloatWithAggregatesFilter<"DishOrder"> | number
    taxRate?: FloatWithAggregatesFilter<"DishOrder"> | number
    taxAmount?: FloatWithAggregatesFilter<"DishOrder"> | number
    beforeTaxTotalDiscountAmount?: FloatWithAggregatesFilter<"DishOrder"> | number
    afterTaxTotalDiscountAmount?: FloatWithAggregatesFilter<"DishOrder"> | number
    taxTotalDiscountAmount?: FloatWithAggregatesFilter<"DishOrder"> | number
    paymentAmount?: FloatWithAggregatesFilter<"DishOrder"> | number
    status?: EnumDishOrderStatusWithAggregatesFilter<"DishOrder"> | $Enums.DishOrderStatus
    returnedAt?: DateTimeNullableWithAggregatesFilter<"DishOrder"> | Date | string | null
    note?: StringNullableWithAggregatesFilter<"DishOrder"> | string | null
    orderId?: StringNullableWithAggregatesFilter<"DishOrder"> | string | null
    returnedOrderId?: StringNullableWithAggregatesFilter<"DishOrder"> | string | null
  }

  export type OrderWhereInput = {
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    id?: StringFilter<"Order"> | string
    shopId?: StringFilter<"Order"> | string
    tableId?: StringFilter<"Order"> | string
    orderSessionId?: StringFilter<"Order"> | string
    orderNo?: IntFilter<"Order"> | number
    customerId?: StringNullableFilter<"Order"> | string | null
    totalQuantity?: IntFilter<"Order"> | number
    totalBeforeTaxAmount?: FloatFilter<"Order"> | number
    totalAfterTaxAmount?: FloatFilter<"Order"> | number
    approvedById?: StringNullableFilter<"Order"> | string | null
    cancelledById?: StringNullableFilter<"Order"> | string | null
    status?: EnumStatusFilter<"Order"> | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFilter<"Order"> | $Enums.OrderSessionStatus
    numberOfCustomer?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    dishOrders?: DishOrderListRelationFilter
    returnedDishOrders?: DishOrderListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    table?: XOR<TableScalarRelationFilter, TableWhereInput>
    orderSession?: XOR<OrderSessionScalarRelationFilter, OrderSessionWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    cancelledBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    KitchenLog?: KitchenLogListRelationFilter
  }

  export type OrderOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableId?: SortOrder
    orderSessionId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrderInput | SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    cancelledById?: SortOrderInput | SortOrder
    status?: SortOrder
    orderSessionStatus?: SortOrder
    numberOfCustomer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    dishOrders?: DishOrderOrderByRelationAggregateInput
    returnedDishOrders?: DishOrderOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
    table?: TableOrderByWithRelationInput
    orderSession?: OrderSessionOrderByWithRelationInput
    customer?: CustomerOrderByWithRelationInput
    approvedBy?: UserOrderByWithRelationInput
    cancelledBy?: UserOrderByWithRelationInput
    KitchenLog?: KitchenLogOrderByRelationAggregateInput
  }

  export type OrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderWhereInput | OrderWhereInput[]
    OR?: OrderWhereInput[]
    NOT?: OrderWhereInput | OrderWhereInput[]
    shopId?: StringFilter<"Order"> | string
    tableId?: StringFilter<"Order"> | string
    orderSessionId?: StringFilter<"Order"> | string
    orderNo?: IntFilter<"Order"> | number
    customerId?: StringNullableFilter<"Order"> | string | null
    totalQuantity?: IntFilter<"Order"> | number
    totalBeforeTaxAmount?: FloatFilter<"Order"> | number
    totalAfterTaxAmount?: FloatFilter<"Order"> | number
    approvedById?: StringNullableFilter<"Order"> | string | null
    cancelledById?: StringNullableFilter<"Order"> | string | null
    status?: EnumStatusFilter<"Order"> | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFilter<"Order"> | $Enums.OrderSessionStatus
    numberOfCustomer?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
    dishOrders?: DishOrderListRelationFilter
    returnedDishOrders?: DishOrderListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    table?: XOR<TableScalarRelationFilter, TableWhereInput>
    orderSession?: XOR<OrderSessionScalarRelationFilter, OrderSessionWhereInput>
    customer?: XOR<CustomerNullableScalarRelationFilter, CustomerWhereInput> | null
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    cancelledBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    KitchenLog?: KitchenLogListRelationFilter
  }, "id">

  export type OrderOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableId?: SortOrder
    orderSessionId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrderInput | SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    cancelledById?: SortOrderInput | SortOrder
    status?: SortOrder
    orderSessionStatus?: SortOrder
    numberOfCustomer?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderCountOrderByAggregateInput
    _avg?: OrderAvgOrderByAggregateInput
    _max?: OrderMaxOrderByAggregateInput
    _min?: OrderMinOrderByAggregateInput
    _sum?: OrderSumOrderByAggregateInput
  }

  export type OrderScalarWhereWithAggregatesInput = {
    AND?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    OR?: OrderScalarWhereWithAggregatesInput[]
    NOT?: OrderScalarWhereWithAggregatesInput | OrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Order"> | string
    shopId?: StringWithAggregatesFilter<"Order"> | string
    tableId?: StringWithAggregatesFilter<"Order"> | string
    orderSessionId?: StringWithAggregatesFilter<"Order"> | string
    orderNo?: IntWithAggregatesFilter<"Order"> | number
    customerId?: StringNullableWithAggregatesFilter<"Order"> | string | null
    totalQuantity?: IntWithAggregatesFilter<"Order"> | number
    totalBeforeTaxAmount?: FloatWithAggregatesFilter<"Order"> | number
    totalAfterTaxAmount?: FloatWithAggregatesFilter<"Order"> | number
    approvedById?: StringNullableWithAggregatesFilter<"Order"> | string | null
    cancelledById?: StringNullableWithAggregatesFilter<"Order"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Order"> | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusWithAggregatesFilter<"Order"> | $Enums.OrderSessionStatus
    numberOfCustomer?: IntNullableWithAggregatesFilter<"Order"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Order"> | Date | string
  }

  export type DiscountProductWhereInput = {
    AND?: DiscountProductWhereInput | DiscountProductWhereInput[]
    OR?: DiscountProductWhereInput[]
    NOT?: DiscountProductWhereInput | DiscountProductWhereInput[]
    id?: StringFilter<"DiscountProduct"> | string
    dishOrderId?: StringFilter<"DiscountProduct"> | string
    dishId?: StringFilter<"DiscountProduct"> | string
    dishName?: StringFilter<"DiscountProduct"> | string
    discountRate?: FloatFilter<"DiscountProduct"> | number
    discountValue?: FloatFilter<"DiscountProduct"> | number
    discountValueType?: EnumDiscountValueTypeFilter<"DiscountProduct"> | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    afterTaxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    taxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    discountId?: StringFilter<"DiscountProduct"> | string
    createdAt?: DateTimeFilter<"DiscountProduct"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountProduct"> | Date | string
    discount?: XOR<DiscountScalarRelationFilter, DiscountWhereInput>
  }

  export type DiscountProductOrderByWithRelationInput = {
    id?: SortOrder
    dishOrderId?: SortOrder
    dishId?: SortOrder
    dishName?: SortOrder
    discountRate?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
    discountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discount?: DiscountOrderByWithRelationInput
  }

  export type DiscountProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscountProductWhereInput | DiscountProductWhereInput[]
    OR?: DiscountProductWhereInput[]
    NOT?: DiscountProductWhereInput | DiscountProductWhereInput[]
    dishOrderId?: StringFilter<"DiscountProduct"> | string
    dishId?: StringFilter<"DiscountProduct"> | string
    dishName?: StringFilter<"DiscountProduct"> | string
    discountRate?: FloatFilter<"DiscountProduct"> | number
    discountValue?: FloatFilter<"DiscountProduct"> | number
    discountValueType?: EnumDiscountValueTypeFilter<"DiscountProduct"> | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    afterTaxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    taxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    discountId?: StringFilter<"DiscountProduct"> | string
    createdAt?: DateTimeFilter<"DiscountProduct"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountProduct"> | Date | string
    discount?: XOR<DiscountScalarRelationFilter, DiscountWhereInput>
  }, "id">

  export type DiscountProductOrderByWithAggregationInput = {
    id?: SortOrder
    dishOrderId?: SortOrder
    dishId?: SortOrder
    dishName?: SortOrder
    discountRate?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
    discountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountProductCountOrderByAggregateInput
    _avg?: DiscountProductAvgOrderByAggregateInput
    _max?: DiscountProductMaxOrderByAggregateInput
    _min?: DiscountProductMinOrderByAggregateInput
    _sum?: DiscountProductSumOrderByAggregateInput
  }

  export type DiscountProductScalarWhereWithAggregatesInput = {
    AND?: DiscountProductScalarWhereWithAggregatesInput | DiscountProductScalarWhereWithAggregatesInput[]
    OR?: DiscountProductScalarWhereWithAggregatesInput[]
    NOT?: DiscountProductScalarWhereWithAggregatesInput | DiscountProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DiscountProduct"> | string
    dishOrderId?: StringWithAggregatesFilter<"DiscountProduct"> | string
    dishId?: StringWithAggregatesFilter<"DiscountProduct"> | string
    dishName?: StringWithAggregatesFilter<"DiscountProduct"> | string
    discountRate?: FloatWithAggregatesFilter<"DiscountProduct"> | number
    discountValue?: FloatWithAggregatesFilter<"DiscountProduct"> | number
    discountValueType?: EnumDiscountValueTypeWithAggregatesFilter<"DiscountProduct"> | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatWithAggregatesFilter<"DiscountProduct"> | number
    afterTaxDiscountPrice?: FloatWithAggregatesFilter<"DiscountProduct"> | number
    taxDiscountPrice?: FloatWithAggregatesFilter<"DiscountProduct"> | number
    discountId?: StringWithAggregatesFilter<"DiscountProduct"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DiscountProduct"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscountProduct"> | Date | string
  }

  export type DiscountWhereInput = {
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    id?: StringFilter<"Discount"> | string
    name?: StringFilter<"Discount"> | string
    discountType?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Discount"> | number
    discountValueType?: EnumDiscountValueTypeFilter<"Discount"> | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    afterTaxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    taxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    orderSessionId?: StringNullableFilter<"Discount"> | string | null
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    discountProducts?: DiscountProductListRelationFilter
    orderSession?: XOR<OrderSessionNullableScalarRelationFilter, OrderSessionWhereInput> | null
  }

  export type DiscountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    orderSessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    discountProducts?: DiscountProductOrderByRelationAggregateInput
    orderSession?: OrderSessionOrderByWithRelationInput
  }

  export type DiscountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DiscountWhereInput | DiscountWhereInput[]
    OR?: DiscountWhereInput[]
    NOT?: DiscountWhereInput | DiscountWhereInput[]
    name?: StringFilter<"Discount"> | string
    discountType?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Discount"> | number
    discountValueType?: EnumDiscountValueTypeFilter<"Discount"> | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    afterTaxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    taxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    orderSessionId?: StringNullableFilter<"Discount"> | string | null
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
    discountProducts?: DiscountProductListRelationFilter
    orderSession?: XOR<OrderSessionNullableScalarRelationFilter, OrderSessionWhereInput> | null
  }, "id">

  export type DiscountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    orderSessionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DiscountCountOrderByAggregateInput
    _avg?: DiscountAvgOrderByAggregateInput
    _max?: DiscountMaxOrderByAggregateInput
    _min?: DiscountMinOrderByAggregateInput
    _sum?: DiscountSumOrderByAggregateInput
  }

  export type DiscountScalarWhereWithAggregatesInput = {
    AND?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    OR?: DiscountScalarWhereWithAggregatesInput[]
    NOT?: DiscountScalarWhereWithAggregatesInput | DiscountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Discount"> | string
    name?: StringWithAggregatesFilter<"Discount"> | string
    discountType?: EnumDiscountTypeWithAggregatesFilter<"Discount"> | $Enums.DiscountType
    discountValue?: FloatWithAggregatesFilter<"Discount"> | number
    discountValueType?: EnumDiscountValueTypeWithAggregatesFilter<"Discount"> | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatWithAggregatesFilter<"Discount"> | number
    afterTaxTotalDiscountAmount?: FloatWithAggregatesFilter<"Discount"> | number
    taxTotalDiscountAmount?: FloatWithAggregatesFilter<"Discount"> | number
    orderSessionId?: StringNullableWithAggregatesFilter<"Discount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Discount"> | Date | string
  }

  export type TaxDetailWhereInput = {
    AND?: TaxDetailWhereInput | TaxDetailWhereInput[]
    OR?: TaxDetailWhereInput[]
    NOT?: TaxDetailWhereInput | TaxDetailWhereInput[]
    id?: StringFilter<"TaxDetail"> | string
    taxAmount?: FloatFilter<"TaxDetail"> | number
    taxRate?: FloatFilter<"TaxDetail"> | number
    orderSessionId?: StringFilter<"TaxDetail"> | string
    orderSession?: XOR<OrderSessionScalarRelationFilter, OrderSessionWhereInput>
  }

  export type TaxDetailOrderByWithRelationInput = {
    id?: SortOrder
    taxAmount?: SortOrder
    taxRate?: SortOrder
    orderSessionId?: SortOrder
    orderSession?: OrderSessionOrderByWithRelationInput
  }

  export type TaxDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaxDetailWhereInput | TaxDetailWhereInput[]
    OR?: TaxDetailWhereInput[]
    NOT?: TaxDetailWhereInput | TaxDetailWhereInput[]
    taxAmount?: FloatFilter<"TaxDetail"> | number
    taxRate?: FloatFilter<"TaxDetail"> | number
    orderSessionId?: StringFilter<"TaxDetail"> | string
    orderSession?: XOR<OrderSessionScalarRelationFilter, OrderSessionWhereInput>
  }, "id">

  export type TaxDetailOrderByWithAggregationInput = {
    id?: SortOrder
    taxAmount?: SortOrder
    taxRate?: SortOrder
    orderSessionId?: SortOrder
    _count?: TaxDetailCountOrderByAggregateInput
    _avg?: TaxDetailAvgOrderByAggregateInput
    _max?: TaxDetailMaxOrderByAggregateInput
    _min?: TaxDetailMinOrderByAggregateInput
    _sum?: TaxDetailSumOrderByAggregateInput
  }

  export type TaxDetailScalarWhereWithAggregatesInput = {
    AND?: TaxDetailScalarWhereWithAggregatesInput | TaxDetailScalarWhereWithAggregatesInput[]
    OR?: TaxDetailScalarWhereWithAggregatesInput[]
    NOT?: TaxDetailScalarWhereWithAggregatesInput | TaxDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TaxDetail"> | string
    taxAmount?: FloatWithAggregatesFilter<"TaxDetail"> | number
    taxRate?: FloatWithAggregatesFilter<"TaxDetail"> | number
    orderSessionId?: StringWithAggregatesFilter<"TaxDetail"> | string
  }

  export type PaymentDetailWhereInput = {
    AND?: PaymentDetailWhereInput | PaymentDetailWhereInput[]
    OR?: PaymentDetailWhereInput[]
    NOT?: PaymentDetailWhereInput | PaymentDetailWhereInput[]
    id?: StringFilter<"PaymentDetail"> | string
    paymentMethod?: EnumPaymentMethodEnumFilter<"PaymentDetail"> | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFilter<"PaymentDetail"> | number
    orderSessionId?: StringFilter<"PaymentDetail"> | string
    orderSession?: XOR<OrderSessionScalarRelationFilter, OrderSessionWhereInput>
  }

  export type PaymentDetailOrderByWithRelationInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    paymentAmount?: SortOrder
    orderSessionId?: SortOrder
    orderSession?: OrderSessionOrderByWithRelationInput
  }

  export type PaymentDetailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentDetailWhereInput | PaymentDetailWhereInput[]
    OR?: PaymentDetailWhereInput[]
    NOT?: PaymentDetailWhereInput | PaymentDetailWhereInput[]
    paymentMethod?: EnumPaymentMethodEnumFilter<"PaymentDetail"> | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFilter<"PaymentDetail"> | number
    orderSessionId?: StringFilter<"PaymentDetail"> | string
    orderSession?: XOR<OrderSessionScalarRelationFilter, OrderSessionWhereInput>
  }, "id">

  export type PaymentDetailOrderByWithAggregationInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    paymentAmount?: SortOrder
    orderSessionId?: SortOrder
    _count?: PaymentDetailCountOrderByAggregateInput
    _avg?: PaymentDetailAvgOrderByAggregateInput
    _max?: PaymentDetailMaxOrderByAggregateInput
    _min?: PaymentDetailMinOrderByAggregateInput
    _sum?: PaymentDetailSumOrderByAggregateInput
  }

  export type PaymentDetailScalarWhereWithAggregatesInput = {
    AND?: PaymentDetailScalarWhereWithAggregatesInput | PaymentDetailScalarWhereWithAggregatesInput[]
    OR?: PaymentDetailScalarWhereWithAggregatesInput[]
    NOT?: PaymentDetailScalarWhereWithAggregatesInput | PaymentDetailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentDetail"> | string
    paymentMethod?: EnumPaymentMethodEnumWithAggregatesFilter<"PaymentDetail"> | $Enums.PaymentMethodEnum
    paymentAmount?: FloatWithAggregatesFilter<"PaymentDetail"> | number
    orderSessionId?: StringWithAggregatesFilter<"PaymentDetail"> | string
  }

  export type OrderSessionWhereInput = {
    AND?: OrderSessionWhereInput | OrderSessionWhereInput[]
    OR?: OrderSessionWhereInput[]
    NOT?: OrderSessionWhereInput | OrderSessionWhereInput[]
    id?: StringFilter<"OrderSession"> | string
    shopId?: StringFilter<"OrderSession"> | string
    tableIds?: StringNullableListFilter<"OrderSession">
    tableNames?: StringNullableListFilter<"OrderSession">
    orderSessionNo?: IntFilter<"OrderSession"> | number
    taxRate?: FloatFilter<"OrderSession"> | number
    totalTaxAmount?: FloatFilter<"OrderSession"> | number
    endedAt?: DateTimeNullableFilter<"OrderSession"> | Date | string | null
    auditedAt?: DateTimeNullableFilter<"OrderSession"> | Date | string | null
    status?: EnumOrderSessionStatusFilter<"OrderSession"> | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFilter<"OrderSession"> | number
    paymentAmount?: FloatFilter<"OrderSession"> | number
    paidByEmployeeId?: StringNullableFilter<"OrderSession"> | string | null
    paidByEmployeeName?: StringNullableFilter<"OrderSession"> | string | null
    cancelledByEmployeeId?: StringNullableFilter<"OrderSession"> | string | null
    cancelledByEmployeeName?: StringNullableFilter<"OrderSession"> | string | null
    cancellationReason?: StringNullableFilter<"OrderSession"> | string | null
    customerId?: StringNullableFilter<"OrderSession"> | string | null
    customerName?: StringNullableFilter<"OrderSession"> | string | null
    customerPhone?: StringNullableFilter<"OrderSession"> | string | null
    customerAddress?: StringNullableFilter<"OrderSession"> | string | null
    numberOfCustomer?: IntNullableFilter<"OrderSession"> | number | null
    totalDiscountAmountBeforeTax?: FloatFilter<"OrderSession"> | number
    totalDiscountAmountAfterTax?: FloatFilter<"OrderSession"> | number
    createdAt?: DateTimeFilter<"OrderSession"> | Date | string
    updatedAt?: DateTimeFilter<"OrderSession"> | Date | string
    orders?: OrderListRelationFilter
    discounts?: DiscountListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    taxDetails?: TaxDetailListRelationFilter
    paymentDetails?: PaymentDetailListRelationFilter
  }

  export type OrderSessionOrderByWithRelationInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableIds?: SortOrder
    tableNames?: SortOrder
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    auditedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    paidByEmployeeId?: SortOrderInput | SortOrder
    paidByEmployeeName?: SortOrderInput | SortOrder
    cancelledByEmployeeId?: SortOrderInput | SortOrder
    cancelledByEmployeeName?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerAddress?: SortOrderInput | SortOrder
    numberOfCustomer?: SortOrderInput | SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    orders?: OrderOrderByRelationAggregateInput
    discounts?: DiscountOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
    taxDetails?: TaxDetailOrderByRelationAggregateInput
    paymentDetails?: PaymentDetailOrderByRelationAggregateInput
  }

  export type OrderSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OrderSessionWhereInput | OrderSessionWhereInput[]
    OR?: OrderSessionWhereInput[]
    NOT?: OrderSessionWhereInput | OrderSessionWhereInput[]
    shopId?: StringFilter<"OrderSession"> | string
    tableIds?: StringNullableListFilter<"OrderSession">
    tableNames?: StringNullableListFilter<"OrderSession">
    orderSessionNo?: IntFilter<"OrderSession"> | number
    taxRate?: FloatFilter<"OrderSession"> | number
    totalTaxAmount?: FloatFilter<"OrderSession"> | number
    endedAt?: DateTimeNullableFilter<"OrderSession"> | Date | string | null
    auditedAt?: DateTimeNullableFilter<"OrderSession"> | Date | string | null
    status?: EnumOrderSessionStatusFilter<"OrderSession"> | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFilter<"OrderSession"> | number
    paymentAmount?: FloatFilter<"OrderSession"> | number
    paidByEmployeeId?: StringNullableFilter<"OrderSession"> | string | null
    paidByEmployeeName?: StringNullableFilter<"OrderSession"> | string | null
    cancelledByEmployeeId?: StringNullableFilter<"OrderSession"> | string | null
    cancelledByEmployeeName?: StringNullableFilter<"OrderSession"> | string | null
    cancellationReason?: StringNullableFilter<"OrderSession"> | string | null
    customerId?: StringNullableFilter<"OrderSession"> | string | null
    customerName?: StringNullableFilter<"OrderSession"> | string | null
    customerPhone?: StringNullableFilter<"OrderSession"> | string | null
    customerAddress?: StringNullableFilter<"OrderSession"> | string | null
    numberOfCustomer?: IntNullableFilter<"OrderSession"> | number | null
    totalDiscountAmountBeforeTax?: FloatFilter<"OrderSession"> | number
    totalDiscountAmountAfterTax?: FloatFilter<"OrderSession"> | number
    createdAt?: DateTimeFilter<"OrderSession"> | Date | string
    updatedAt?: DateTimeFilter<"OrderSession"> | Date | string
    orders?: OrderListRelationFilter
    discounts?: DiscountListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    taxDetails?: TaxDetailListRelationFilter
    paymentDetails?: PaymentDetailListRelationFilter
  }, "id">

  export type OrderSessionOrderByWithAggregationInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableIds?: SortOrder
    tableNames?: SortOrder
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    endedAt?: SortOrderInput | SortOrder
    auditedAt?: SortOrderInput | SortOrder
    status?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    paidByEmployeeId?: SortOrderInput | SortOrder
    paidByEmployeeName?: SortOrderInput | SortOrder
    cancelledByEmployeeId?: SortOrderInput | SortOrder
    cancelledByEmployeeName?: SortOrderInput | SortOrder
    cancellationReason?: SortOrderInput | SortOrder
    customerId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    customerPhone?: SortOrderInput | SortOrder
    customerAddress?: SortOrderInput | SortOrder
    numberOfCustomer?: SortOrderInput | SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: OrderSessionCountOrderByAggregateInput
    _avg?: OrderSessionAvgOrderByAggregateInput
    _max?: OrderSessionMaxOrderByAggregateInput
    _min?: OrderSessionMinOrderByAggregateInput
    _sum?: OrderSessionSumOrderByAggregateInput
  }

  export type OrderSessionScalarWhereWithAggregatesInput = {
    AND?: OrderSessionScalarWhereWithAggregatesInput | OrderSessionScalarWhereWithAggregatesInput[]
    OR?: OrderSessionScalarWhereWithAggregatesInput[]
    NOT?: OrderSessionScalarWhereWithAggregatesInput | OrderSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"OrderSession"> | string
    shopId?: StringWithAggregatesFilter<"OrderSession"> | string
    tableIds?: StringNullableListFilter<"OrderSession">
    tableNames?: StringNullableListFilter<"OrderSession">
    orderSessionNo?: IntWithAggregatesFilter<"OrderSession"> | number
    taxRate?: FloatWithAggregatesFilter<"OrderSession"> | number
    totalTaxAmount?: FloatWithAggregatesFilter<"OrderSession"> | number
    endedAt?: DateTimeNullableWithAggregatesFilter<"OrderSession"> | Date | string | null
    auditedAt?: DateTimeNullableWithAggregatesFilter<"OrderSession"> | Date | string | null
    status?: EnumOrderSessionStatusWithAggregatesFilter<"OrderSession"> | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatWithAggregatesFilter<"OrderSession"> | number
    paymentAmount?: FloatWithAggregatesFilter<"OrderSession"> | number
    paidByEmployeeId?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    paidByEmployeeName?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    cancelledByEmployeeId?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    cancelledByEmployeeName?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    cancellationReason?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    customerId?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    customerPhone?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    customerAddress?: StringNullableWithAggregatesFilter<"OrderSession"> | string | null
    numberOfCustomer?: IntNullableWithAggregatesFilter<"OrderSession"> | number | null
    totalDiscountAmountBeforeTax?: FloatWithAggregatesFilter<"OrderSession"> | number
    totalDiscountAmountAfterTax?: FloatWithAggregatesFilter<"OrderSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"OrderSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"OrderSession"> | Date | string
  }

  export type ShopWhereInput = {
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    status?: EnumStatusFilter<"Shop"> | $Enums.Status
    name?: StringNullableFilter<"Shop"> | string | null
    phone?: StringNullableFilter<"Shop"> | string | null
    email?: StringNullableFilter<"Shop"> | string | null
    ownerId?: StringNullableFilter<"Shop"> | string | null
    taxRate?: FloatNullableFilter<"Shop"> | number | null
    location?: StringNullableFilter<"Shop"> | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    calculateTaxDirectly?: BoolNullableFilter<"Shop"> | boolean | null
    countryName?: StringNullableFilter<"Shop"> | string | null
    countryCurrency?: StringNullableFilter<"Shop"> | string | null
    utcOffset?: IntFilter<"Shop"> | number
    timezone?: StringFilter<"Shop"> | string
    reportTime?: IntFilter<"Shop"> | number
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    id?: StringFilter<"Shop"> | string
    dish?: DishListRelationFilter
    dishCategory?: DishCategoryListRelationFilter
    employees?: EmployeeListRelationFilter
    employeeDepartments?: EmployeeDepartmentListRelationFilter
    employeePositions?: EmployeePositionListRelationFilter
    imageUrls?: ImageListRelationFilter
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    table?: TableListRelationFilter
    tablePosition?: TablePositionListRelationFilter
    unit?: UnitListRelationFilter
    Kitchen?: KitchenListRelationFilter
    KitchenLog?: KitchenLogListRelationFilter
    Order?: OrderListRelationFilter
    OrderSession?: OrderSessionListRelationFilter
  }

  export type ShopOrderByWithRelationInput = {
    status?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    dishPriceRoundingType?: SortOrder
    discountRoundingType?: SortOrder
    taxRoundingType?: SortOrder
    calculateTaxDirectly?: SortOrderInput | SortOrder
    countryName?: SortOrderInput | SortOrder
    countryCurrency?: SortOrderInput | SortOrder
    utcOffset?: SortOrder
    timezone?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    dish?: DishOrderByRelationAggregateInput
    dishCategory?: DishCategoryOrderByRelationAggregateInput
    employees?: EmployeeOrderByRelationAggregateInput
    employeeDepartments?: EmployeeDepartmentOrderByRelationAggregateInput
    employeePositions?: EmployeePositionOrderByRelationAggregateInput
    imageUrls?: ImageOrderByRelationAggregateInput
    owner?: UserOrderByWithRelationInput
    table?: TableOrderByRelationAggregateInput
    tablePosition?: TablePositionOrderByRelationAggregateInput
    unit?: UnitOrderByRelationAggregateInput
    Kitchen?: KitchenOrderByRelationAggregateInput
    KitchenLog?: KitchenLogOrderByRelationAggregateInput
    Order?: OrderOrderByRelationAggregateInput
    OrderSession?: OrderSessionOrderByRelationAggregateInput
  }

  export type ShopWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShopWhereInput | ShopWhereInput[]
    OR?: ShopWhereInput[]
    NOT?: ShopWhereInput | ShopWhereInput[]
    status?: EnumStatusFilter<"Shop"> | $Enums.Status
    name?: StringNullableFilter<"Shop"> | string | null
    phone?: StringNullableFilter<"Shop"> | string | null
    email?: StringNullableFilter<"Shop"> | string | null
    ownerId?: StringNullableFilter<"Shop"> | string | null
    taxRate?: FloatNullableFilter<"Shop"> | number | null
    location?: StringNullableFilter<"Shop"> | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    calculateTaxDirectly?: BoolNullableFilter<"Shop"> | boolean | null
    countryName?: StringNullableFilter<"Shop"> | string | null
    countryCurrency?: StringNullableFilter<"Shop"> | string | null
    utcOffset?: IntFilter<"Shop"> | number
    timezone?: StringFilter<"Shop"> | string
    reportTime?: IntFilter<"Shop"> | number
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    dish?: DishListRelationFilter
    dishCategory?: DishCategoryListRelationFilter
    employees?: EmployeeListRelationFilter
    employeeDepartments?: EmployeeDepartmentListRelationFilter
    employeePositions?: EmployeePositionListRelationFilter
    imageUrls?: ImageListRelationFilter
    owner?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    table?: TableListRelationFilter
    tablePosition?: TablePositionListRelationFilter
    unit?: UnitListRelationFilter
    Kitchen?: KitchenListRelationFilter
    KitchenLog?: KitchenLogListRelationFilter
    Order?: OrderListRelationFilter
    OrderSession?: OrderSessionListRelationFilter
  }, "id">

  export type ShopOrderByWithAggregationInput = {
    status?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    ownerId?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    dishPriceRoundingType?: SortOrder
    discountRoundingType?: SortOrder
    taxRoundingType?: SortOrder
    calculateTaxDirectly?: SortOrderInput | SortOrder
    countryName?: SortOrderInput | SortOrder
    countryCurrency?: SortOrderInput | SortOrder
    utcOffset?: SortOrder
    timezone?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: ShopCountOrderByAggregateInput
    _avg?: ShopAvgOrderByAggregateInput
    _max?: ShopMaxOrderByAggregateInput
    _min?: ShopMinOrderByAggregateInput
    _sum?: ShopSumOrderByAggregateInput
  }

  export type ShopScalarWhereWithAggregatesInput = {
    AND?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    OR?: ShopScalarWhereWithAggregatesInput[]
    NOT?: ShopScalarWhereWithAggregatesInput | ShopScalarWhereWithAggregatesInput[]
    status?: EnumStatusWithAggregatesFilter<"Shop"> | $Enums.Status
    name?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    email?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    ownerId?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    taxRate?: FloatNullableWithAggregatesFilter<"Shop"> | number | null
    location?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeWithAggregatesFilter<"Shop"> | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeWithAggregatesFilter<"Shop"> | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeWithAggregatesFilter<"Shop"> | $Enums.RoundingPaymentType
    calculateTaxDirectly?: BoolNullableWithAggregatesFilter<"Shop"> | boolean | null
    countryName?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    countryCurrency?: StringNullableWithAggregatesFilter<"Shop"> | string | null
    utcOffset?: IntWithAggregatesFilter<"Shop"> | number
    timezone?: StringWithAggregatesFilter<"Shop"> | string
    reportTime?: IntWithAggregatesFilter<"Shop"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shop"> | Date | string
    id?: StringWithAggregatesFilter<"Shop"> | string
  }

  export type ImageWhereInput = {
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    url?: StringFilter<"Image"> | string
    shopId?: StringNullableFilter<"Image"> | string | null
    dishId?: StringNullableFilter<"Image"> | string | null
    id?: StringFilter<"Image"> | string
    dish?: XOR<DishNullableScalarRelationFilter, DishWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }

  export type ImageOrderByWithRelationInput = {
    url?: SortOrder
    shopId?: SortOrderInput | SortOrder
    dishId?: SortOrderInput | SortOrder
    id?: SortOrder
    dish?: DishOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
  }

  export type ImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ImageWhereInput | ImageWhereInput[]
    OR?: ImageWhereInput[]
    NOT?: ImageWhereInput | ImageWhereInput[]
    url?: StringFilter<"Image"> | string
    shopId?: StringNullableFilter<"Image"> | string | null
    dishId?: StringNullableFilter<"Image"> | string | null
    dish?: XOR<DishNullableScalarRelationFilter, DishWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
  }, "id">

  export type ImageOrderByWithAggregationInput = {
    url?: SortOrder
    shopId?: SortOrderInput | SortOrder
    dishId?: SortOrderInput | SortOrder
    id?: SortOrder
    _count?: ImageCountOrderByAggregateInput
    _max?: ImageMaxOrderByAggregateInput
    _min?: ImageMinOrderByAggregateInput
  }

  export type ImageScalarWhereWithAggregatesInput = {
    AND?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    OR?: ImageScalarWhereWithAggregatesInput[]
    NOT?: ImageScalarWhereWithAggregatesInput | ImageScalarWhereWithAggregatesInput[]
    url?: StringWithAggregatesFilter<"Image"> | string
    shopId?: StringNullableWithAggregatesFilter<"Image"> | string | null
    dishId?: StringNullableWithAggregatesFilter<"Image"> | string | null
    id?: StringWithAggregatesFilter<"Image"> | string
  }

  export type DishCategoryWhereInput = {
    AND?: DishCategoryWhereInput | DishCategoryWhereInput[]
    OR?: DishCategoryWhereInput[]
    NOT?: DishCategoryWhereInput | DishCategoryWhereInput[]
    shopId?: StringNullableFilter<"DishCategory"> | string | null
    name?: StringNullableFilter<"DishCategory"> | string | null
    code?: StringNullableFilter<"DishCategory"> | string | null
    status?: EnumStatusFilter<"DishCategory"> | $Enums.Status
    createdAt?: DateTimeFilter<"DishCategory"> | Date | string
    updatedAt?: DateTimeFilter<"DishCategory"> | Date | string
    id?: StringFilter<"DishCategory"> | string
    dish?: DishListRelationFilter
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    tablePosition?: TablePositionListRelationFilter
    kitchen?: KitchenListRelationFilter
  }

  export type DishCategoryOrderByWithRelationInput = {
    shopId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    dish?: DishOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
    tablePosition?: TablePositionOrderByRelationAggregateInput
    kitchen?: KitchenOrderByRelationAggregateInput
  }

  export type DishCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DishCategoryWhereInput | DishCategoryWhereInput[]
    OR?: DishCategoryWhereInput[]
    NOT?: DishCategoryWhereInput | DishCategoryWhereInput[]
    shopId?: StringNullableFilter<"DishCategory"> | string | null
    name?: StringNullableFilter<"DishCategory"> | string | null
    code?: StringNullableFilter<"DishCategory"> | string | null
    status?: EnumStatusFilter<"DishCategory"> | $Enums.Status
    createdAt?: DateTimeFilter<"DishCategory"> | Date | string
    updatedAt?: DateTimeFilter<"DishCategory"> | Date | string
    dish?: DishListRelationFilter
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    tablePosition?: TablePositionListRelationFilter
    kitchen?: KitchenListRelationFilter
  }, "id">

  export type DishCategoryOrderByWithAggregationInput = {
    shopId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: DishCategoryCountOrderByAggregateInput
    _max?: DishCategoryMaxOrderByAggregateInput
    _min?: DishCategoryMinOrderByAggregateInput
  }

  export type DishCategoryScalarWhereWithAggregatesInput = {
    AND?: DishCategoryScalarWhereWithAggregatesInput | DishCategoryScalarWhereWithAggregatesInput[]
    OR?: DishCategoryScalarWhereWithAggregatesInput[]
    NOT?: DishCategoryScalarWhereWithAggregatesInput | DishCategoryScalarWhereWithAggregatesInput[]
    shopId?: StringNullableWithAggregatesFilter<"DishCategory"> | string | null
    name?: StringNullableWithAggregatesFilter<"DishCategory"> | string | null
    code?: StringNullableWithAggregatesFilter<"DishCategory"> | string | null
    status?: EnumStatusWithAggregatesFilter<"DishCategory"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"DishCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DishCategory"> | Date | string
    id?: StringWithAggregatesFilter<"DishCategory"> | string
  }

  export type DishWhereInput = {
    AND?: DishWhereInput | DishWhereInput[]
    OR?: DishWhereInput[]
    NOT?: DishWhereInput | DishWhereInput[]
    shopId?: StringNullableFilter<"Dish"> | string | null
    name?: StringNullableFilter<"Dish"> | string | null
    code?: StringNullableFilter<"Dish"> | string | null
    unitId?: StringNullableFilter<"Dish"> | string | null
    price?: FloatNullableFilter<"Dish"> | number | null
    taxIncludedPrice?: FloatNullableFilter<"Dish"> | number | null
    isTaxIncludedPrice?: BoolNullableFilter<"Dish"> | boolean | null
    categoryId?: StringNullableFilter<"Dish"> | string | null
    type?: StringNullableFilter<"Dish"> | string | null
    taxRate?: FloatNullableFilter<"Dish"> | number | null
    status?: EnumSwitchabletatusFilter<"Dish"> | $Enums.Switchabletatus
    isNewlyCreated?: BoolFilter<"Dish"> | boolean
    isBestSeller?: BoolNullableFilter<"Dish"> | boolean | null
    stockQuantity?: FloatNullableFilter<"Dish"> | number | null
    hideForCustomers?: BoolNullableFilter<"Dish"> | boolean | null
    hideForEmployees?: BoolNullableFilter<"Dish"> | boolean | null
    outOfStockNotification?: BoolNullableFilter<"Dish"> | boolean | null
    description?: StringNullableFilter<"Dish"> | string | null
    soldCount?: FloatNullableFilter<"Dish"> | number | null
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    id?: StringFilter<"Dish"> | string
    category?: XOR<DishCategoryNullableScalarRelationFilter, DishCategoryWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    imageUrls?: ImageListRelationFilter
  }

  export type DishOrderByWithRelationInput = {
    shopId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    taxIncludedPrice?: SortOrderInput | SortOrder
    isTaxIncludedPrice?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    status?: SortOrder
    isNewlyCreated?: SortOrder
    isBestSeller?: SortOrderInput | SortOrder
    stockQuantity?: SortOrderInput | SortOrder
    hideForCustomers?: SortOrderInput | SortOrder
    hideForEmployees?: SortOrderInput | SortOrder
    outOfStockNotification?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    soldCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    category?: DishCategoryOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    unit?: UnitOrderByWithRelationInput
    imageUrls?: ImageOrderByRelationAggregateInput
  }

  export type DishWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DishWhereInput | DishWhereInput[]
    OR?: DishWhereInput[]
    NOT?: DishWhereInput | DishWhereInput[]
    shopId?: StringNullableFilter<"Dish"> | string | null
    name?: StringNullableFilter<"Dish"> | string | null
    code?: StringNullableFilter<"Dish"> | string | null
    unitId?: StringNullableFilter<"Dish"> | string | null
    price?: FloatNullableFilter<"Dish"> | number | null
    taxIncludedPrice?: FloatNullableFilter<"Dish"> | number | null
    isTaxIncludedPrice?: BoolNullableFilter<"Dish"> | boolean | null
    categoryId?: StringNullableFilter<"Dish"> | string | null
    type?: StringNullableFilter<"Dish"> | string | null
    taxRate?: FloatNullableFilter<"Dish"> | number | null
    status?: EnumSwitchabletatusFilter<"Dish"> | $Enums.Switchabletatus
    isNewlyCreated?: BoolFilter<"Dish"> | boolean
    isBestSeller?: BoolNullableFilter<"Dish"> | boolean | null
    stockQuantity?: FloatNullableFilter<"Dish"> | number | null
    hideForCustomers?: BoolNullableFilter<"Dish"> | boolean | null
    hideForEmployees?: BoolNullableFilter<"Dish"> | boolean | null
    outOfStockNotification?: BoolNullableFilter<"Dish"> | boolean | null
    description?: StringNullableFilter<"Dish"> | string | null
    soldCount?: FloatNullableFilter<"Dish"> | number | null
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    category?: XOR<DishCategoryNullableScalarRelationFilter, DishCategoryWhereInput> | null
    shop?: XOR<ShopNullableScalarRelationFilter, ShopWhereInput> | null
    unit?: XOR<UnitNullableScalarRelationFilter, UnitWhereInput> | null
    imageUrls?: ImageListRelationFilter
  }, "id">

  export type DishOrderByWithAggregationInput = {
    shopId?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    unitId?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    taxIncludedPrice?: SortOrderInput | SortOrder
    isTaxIncludedPrice?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    status?: SortOrder
    isNewlyCreated?: SortOrder
    isBestSeller?: SortOrderInput | SortOrder
    stockQuantity?: SortOrderInput | SortOrder
    hideForCustomers?: SortOrderInput | SortOrder
    hideForEmployees?: SortOrderInput | SortOrder
    outOfStockNotification?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    soldCount?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: DishCountOrderByAggregateInput
    _avg?: DishAvgOrderByAggregateInput
    _max?: DishMaxOrderByAggregateInput
    _min?: DishMinOrderByAggregateInput
    _sum?: DishSumOrderByAggregateInput
  }

  export type DishScalarWhereWithAggregatesInput = {
    AND?: DishScalarWhereWithAggregatesInput | DishScalarWhereWithAggregatesInput[]
    OR?: DishScalarWhereWithAggregatesInput[]
    NOT?: DishScalarWhereWithAggregatesInput | DishScalarWhereWithAggregatesInput[]
    shopId?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    name?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    code?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    unitId?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    price?: FloatNullableWithAggregatesFilter<"Dish"> | number | null
    taxIncludedPrice?: FloatNullableWithAggregatesFilter<"Dish"> | number | null
    isTaxIncludedPrice?: BoolNullableWithAggregatesFilter<"Dish"> | boolean | null
    categoryId?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    type?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    taxRate?: FloatNullableWithAggregatesFilter<"Dish"> | number | null
    status?: EnumSwitchabletatusWithAggregatesFilter<"Dish"> | $Enums.Switchabletatus
    isNewlyCreated?: BoolWithAggregatesFilter<"Dish"> | boolean
    isBestSeller?: BoolNullableWithAggregatesFilter<"Dish"> | boolean | null
    stockQuantity?: FloatNullableWithAggregatesFilter<"Dish"> | number | null
    hideForCustomers?: BoolNullableWithAggregatesFilter<"Dish"> | boolean | null
    hideForEmployees?: BoolNullableWithAggregatesFilter<"Dish"> | boolean | null
    outOfStockNotification?: BoolNullableWithAggregatesFilter<"Dish"> | boolean | null
    description?: StringNullableWithAggregatesFilter<"Dish"> | string | null
    soldCount?: FloatNullableWithAggregatesFilter<"Dish"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Dish"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Dish"> | Date | string
    id?: StringWithAggregatesFilter<"Dish"> | string
  }

  export type UnitWhereInput = {
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    shopId?: StringFilter<"Unit"> | string
    name?: StringNullableFilter<"Unit"> | string | null
    code?: StringNullableFilter<"Unit"> | string | null
    description?: StringNullableFilter<"Unit"> | string | null
    status?: EnumSwitchabletatusFilter<"Unit"> | $Enums.Switchabletatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    id?: StringFilter<"Unit"> | string
    dish?: DishListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }

  export type UnitOrderByWithRelationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    dish?: DishOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
  }

  export type UnitWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UnitWhereInput | UnitWhereInput[]
    OR?: UnitWhereInput[]
    NOT?: UnitWhereInput | UnitWhereInput[]
    shopId?: StringFilter<"Unit"> | string
    name?: StringNullableFilter<"Unit"> | string | null
    code?: StringNullableFilter<"Unit"> | string | null
    description?: StringNullableFilter<"Unit"> | string | null
    status?: EnumSwitchabletatusFilter<"Unit"> | $Enums.Switchabletatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    dish?: DishListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }, "id">

  export type UnitOrderByWithAggregationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    OR?: UnitScalarWhereWithAggregatesInput[]
    NOT?: UnitScalarWhereWithAggregatesInput | UnitScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"Unit"> | string
    name?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    code?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    description?: StringNullableWithAggregatesFilter<"Unit"> | string | null
    status?: EnumSwitchabletatusWithAggregatesFilter<"Unit"> | $Enums.Switchabletatus
    createdAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Unit"> | Date | string
    id?: StringWithAggregatesFilter<"Unit"> | string
  }

  export type TablePositionWhereInput = {
    AND?: TablePositionWhereInput | TablePositionWhereInput[]
    OR?: TablePositionWhereInput[]
    NOT?: TablePositionWhereInput | TablePositionWhereInput[]
    shopId?: StringFilter<"TablePosition"> | string
    name?: StringNullableFilter<"TablePosition"> | string | null
    dishCategoryIds?: StringNullableListFilter<"TablePosition">
    tableIds?: StringNullableListFilter<"TablePosition">
    status?: EnumStatusFilter<"TablePosition"> | $Enums.Status
    createdAt?: DateTimeFilter<"TablePosition"> | Date | string
    updatedAt?: DateTimeFilter<"TablePosition"> | Date | string
    id?: StringFilter<"TablePosition"> | string
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    dishCategories?: DishCategoryListRelationFilter
    tables?: TableListRelationFilter
  }

  export type TablePositionOrderByWithRelationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    dishCategoryIds?: SortOrder
    tableIds?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    shop?: ShopOrderByWithRelationInput
    dishCategories?: DishCategoryOrderByRelationAggregateInput
    tables?: TableOrderByRelationAggregateInput
  }

  export type TablePositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TablePositionWhereInput | TablePositionWhereInput[]
    OR?: TablePositionWhereInput[]
    NOT?: TablePositionWhereInput | TablePositionWhereInput[]
    shopId?: StringFilter<"TablePosition"> | string
    name?: StringNullableFilter<"TablePosition"> | string | null
    dishCategoryIds?: StringNullableListFilter<"TablePosition">
    tableIds?: StringNullableListFilter<"TablePosition">
    status?: EnumStatusFilter<"TablePosition"> | $Enums.Status
    createdAt?: DateTimeFilter<"TablePosition"> | Date | string
    updatedAt?: DateTimeFilter<"TablePosition"> | Date | string
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    dishCategories?: DishCategoryListRelationFilter
    tables?: TableListRelationFilter
  }, "id">

  export type TablePositionOrderByWithAggregationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    dishCategoryIds?: SortOrder
    tableIds?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: TablePositionCountOrderByAggregateInput
    _max?: TablePositionMaxOrderByAggregateInput
    _min?: TablePositionMinOrderByAggregateInput
  }

  export type TablePositionScalarWhereWithAggregatesInput = {
    AND?: TablePositionScalarWhereWithAggregatesInput | TablePositionScalarWhereWithAggregatesInput[]
    OR?: TablePositionScalarWhereWithAggregatesInput[]
    NOT?: TablePositionScalarWhereWithAggregatesInput | TablePositionScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"TablePosition"> | string
    name?: StringNullableWithAggregatesFilter<"TablePosition"> | string | null
    dishCategoryIds?: StringNullableListFilter<"TablePosition">
    tableIds?: StringNullableListFilter<"TablePosition">
    status?: EnumStatusWithAggregatesFilter<"TablePosition"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"TablePosition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TablePosition"> | Date | string
    id?: StringWithAggregatesFilter<"TablePosition"> | string
  }

  export type TableWhereInput = {
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    shopId?: StringFilter<"Table"> | string
    name?: StringNullableFilter<"Table"> | string | null
    positionId?: StringNullableFilter<"Table"> | string | null
    status?: EnumStatusFilter<"Table"> | $Enums.Status
    allowMultipleOrderSession?: BoolNullableFilter<"Table"> | boolean | null
    needApprovalWhenCustomerOrder?: BoolNullableFilter<"Table"> | boolean | null
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    id?: StringFilter<"Table"> | string
    kitchenId?: StringNullableFilter<"Table"> | string | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    position?: TablePositionListRelationFilter
    Kitchen?: XOR<KitchenNullableScalarRelationFilter, KitchenWhereInput> | null
    Order?: OrderListRelationFilter
  }

  export type TableOrderByWithRelationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    status?: SortOrder
    allowMultipleOrderSession?: SortOrderInput | SortOrder
    needApprovalWhenCustomerOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    kitchenId?: SortOrderInput | SortOrder
    shop?: ShopOrderByWithRelationInput
    position?: TablePositionOrderByRelationAggregateInput
    Kitchen?: KitchenOrderByWithRelationInput
    Order?: OrderOrderByRelationAggregateInput
  }

  export type TableWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TableWhereInput | TableWhereInput[]
    OR?: TableWhereInput[]
    NOT?: TableWhereInput | TableWhereInput[]
    shopId?: StringFilter<"Table"> | string
    name?: StringNullableFilter<"Table"> | string | null
    positionId?: StringNullableFilter<"Table"> | string | null
    status?: EnumStatusFilter<"Table"> | $Enums.Status
    allowMultipleOrderSession?: BoolNullableFilter<"Table"> | boolean | null
    needApprovalWhenCustomerOrder?: BoolNullableFilter<"Table"> | boolean | null
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    kitchenId?: StringNullableFilter<"Table"> | string | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    position?: TablePositionListRelationFilter
    Kitchen?: XOR<KitchenNullableScalarRelationFilter, KitchenWhereInput> | null
    Order?: OrderListRelationFilter
  }, "id">

  export type TableOrderByWithAggregationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    status?: SortOrder
    allowMultipleOrderSession?: SortOrderInput | SortOrder
    needApprovalWhenCustomerOrder?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    kitchenId?: SortOrderInput | SortOrder
    _count?: TableCountOrderByAggregateInput
    _max?: TableMaxOrderByAggregateInput
    _min?: TableMinOrderByAggregateInput
  }

  export type TableScalarWhereWithAggregatesInput = {
    AND?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    OR?: TableScalarWhereWithAggregatesInput[]
    NOT?: TableScalarWhereWithAggregatesInput | TableScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"Table"> | string
    name?: StringNullableWithAggregatesFilter<"Table"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"Table"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Table"> | $Enums.Status
    allowMultipleOrderSession?: BoolNullableWithAggregatesFilter<"Table"> | boolean | null
    needApprovalWhenCustomerOrder?: BoolNullableWithAggregatesFilter<"Table"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Table"> | Date | string
    id?: StringWithAggregatesFilter<"Table"> | string
    kitchenId?: StringNullableWithAggregatesFilter<"Table"> | string | null
  }

  export type EmployeeDepartmentWhereInput = {
    AND?: EmployeeDepartmentWhereInput | EmployeeDepartmentWhereInput[]
    OR?: EmployeeDepartmentWhereInput[]
    NOT?: EmployeeDepartmentWhereInput | EmployeeDepartmentWhereInput[]
    shopId?: StringFilter<"EmployeeDepartment"> | string
    name?: StringNullableFilter<"EmployeeDepartment"> | string | null
    permissions?: StringNullableListFilter<"EmployeeDepartment">
    status?: EnumStatusFilter<"EmployeeDepartment"> | $Enums.Status
    createdAt?: DateTimeFilter<"EmployeeDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDepartment"> | Date | string
    id?: StringFilter<"EmployeeDepartment"> | string
    employees?: EmployeeListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }

  export type EmployeeDepartmentOrderByWithRelationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    permissions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
  }

  export type EmployeeDepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeDepartmentWhereInput | EmployeeDepartmentWhereInput[]
    OR?: EmployeeDepartmentWhereInput[]
    NOT?: EmployeeDepartmentWhereInput | EmployeeDepartmentWhereInput[]
    shopId?: StringFilter<"EmployeeDepartment"> | string
    name?: StringNullableFilter<"EmployeeDepartment"> | string | null
    permissions?: StringNullableListFilter<"EmployeeDepartment">
    status?: EnumStatusFilter<"EmployeeDepartment"> | $Enums.Status
    createdAt?: DateTimeFilter<"EmployeeDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDepartment"> | Date | string
    employees?: EmployeeListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }, "id">

  export type EmployeeDepartmentOrderByWithAggregationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    permissions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: EmployeeDepartmentCountOrderByAggregateInput
    _max?: EmployeeDepartmentMaxOrderByAggregateInput
    _min?: EmployeeDepartmentMinOrderByAggregateInput
  }

  export type EmployeeDepartmentScalarWhereWithAggregatesInput = {
    AND?: EmployeeDepartmentScalarWhereWithAggregatesInput | EmployeeDepartmentScalarWhereWithAggregatesInput[]
    OR?: EmployeeDepartmentScalarWhereWithAggregatesInput[]
    NOT?: EmployeeDepartmentScalarWhereWithAggregatesInput | EmployeeDepartmentScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"EmployeeDepartment"> | string
    name?: StringNullableWithAggregatesFilter<"EmployeeDepartment"> | string | null
    permissions?: StringNullableListFilter<"EmployeeDepartment">
    status?: EnumStatusWithAggregatesFilter<"EmployeeDepartment"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeDepartment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeDepartment"> | Date | string
    id?: StringWithAggregatesFilter<"EmployeeDepartment"> | string
  }

  export type EmployeePositionWhereInput = {
    AND?: EmployeePositionWhereInput | EmployeePositionWhereInput[]
    OR?: EmployeePositionWhereInput[]
    NOT?: EmployeePositionWhereInput | EmployeePositionWhereInput[]
    shopId?: StringFilter<"EmployeePosition"> | string
    name?: StringNullableFilter<"EmployeePosition"> | string | null
    status?: EnumStatusFilter<"EmployeePosition"> | $Enums.Status
    createdAt?: DateTimeFilter<"EmployeePosition"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePosition"> | Date | string
    id?: StringFilter<"EmployeePosition"> | string
    employees?: EmployeeListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }

  export type EmployeePositionOrderByWithRelationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    employees?: EmployeeOrderByRelationAggregateInput
    shop?: ShopOrderByWithRelationInput
  }

  export type EmployeePositionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeePositionWhereInput | EmployeePositionWhereInput[]
    OR?: EmployeePositionWhereInput[]
    NOT?: EmployeePositionWhereInput | EmployeePositionWhereInput[]
    shopId?: StringFilter<"EmployeePosition"> | string
    name?: StringNullableFilter<"EmployeePosition"> | string | null
    status?: EnumStatusFilter<"EmployeePosition"> | $Enums.Status
    createdAt?: DateTimeFilter<"EmployeePosition"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePosition"> | Date | string
    employees?: EmployeeListRelationFilter
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
  }, "id">

  export type EmployeePositionOrderByWithAggregationInput = {
    shopId?: SortOrder
    name?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: EmployeePositionCountOrderByAggregateInput
    _max?: EmployeePositionMaxOrderByAggregateInput
    _min?: EmployeePositionMinOrderByAggregateInput
  }

  export type EmployeePositionScalarWhereWithAggregatesInput = {
    AND?: EmployeePositionScalarWhereWithAggregatesInput | EmployeePositionScalarWhereWithAggregatesInput[]
    OR?: EmployeePositionScalarWhereWithAggregatesInput[]
    NOT?: EmployeePositionScalarWhereWithAggregatesInput | EmployeePositionScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"EmployeePosition"> | string
    name?: StringNullableWithAggregatesFilter<"EmployeePosition"> | string | null
    status?: EnumStatusWithAggregatesFilter<"EmployeePosition"> | $Enums.Status
    createdAt?: DateTimeWithAggregatesFilter<"EmployeePosition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeePosition"> | Date | string
    id?: StringWithAggregatesFilter<"EmployeePosition"> | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    shopId?: StringFilter<"Employee"> | string
    userId?: StringFilter<"Employee"> | string
    name?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    status?: EnumStatusFilter<"Employee"> | $Enums.Status
    permissions?: StringNullableListFilter<"Employee">
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    id?: StringFilter<"Employee"> | string
    department?: XOR<EmployeeDepartmentNullableScalarRelationFilter, EmployeeDepartmentWhereInput> | null
    position?: XOR<EmployeePositionNullableScalarRelationFilter, EmployeePositionWhereInput> | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmployeeOrderByWithRelationInput = {
    shopId?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    status?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    department?: EmployeeDepartmentOrderByWithRelationInput
    position?: EmployeePositionOrderByWithRelationInput
    shop?: ShopOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    shopId?: StringFilter<"Employee"> | string
    userId?: StringFilter<"Employee"> | string
    name?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    status?: EnumStatusFilter<"Employee"> | $Enums.Status
    permissions?: StringNullableListFilter<"Employee">
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    department?: XOR<EmployeeDepartmentNullableScalarRelationFilter, EmployeeDepartmentWhereInput> | null
    position?: XOR<EmployeePositionNullableScalarRelationFilter, EmployeePositionWhereInput> | null
    shop?: XOR<ShopScalarRelationFilter, ShopWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EmployeeOrderByWithAggregationInput = {
    shopId?: SortOrder
    userId?: SortOrder
    name?: SortOrderInput | SortOrder
    positionId?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    status?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    shopId?: StringWithAggregatesFilter<"Employee"> | string
    userId?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    positionId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    status?: EnumStatusWithAggregatesFilter<"Employee"> | $Enums.Status
    permissions?: StringNullableListFilter<"Employee">
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    id?: StringWithAggregatesFilter<"Employee"> | string
  }

  export type UserCreateInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeCreateNestedManyWithoutUserInput
    shop?: ShopCreateNestedManyWithoutOwnerInput
    token?: TokenCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogCreateNestedManyWithoutUserInput
    approveOrder?: OrderCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderCreateNestedManyWithoutCancelledByInput
  }

  export type UserUncheckedCreateInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    shop?: ShopUncheckedCreateNestedManyWithoutOwnerInput
    token?: TokenUncheckedCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutUserInput
    approveOrder?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderUncheckedCreateNestedManyWithoutCancelledByInput
  }

  export type UserUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    shop?: ShopUpdateManyWithoutOwnerNestedInput
    token?: TokenUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    shop?: ShopUncheckedUpdateManyWithoutOwnerNestedInput
    token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUncheckedUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUncheckedUpdateManyWithoutCancelledByNestedInput
  }

  export type UserCreateManyInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UserUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type CustomerCreateInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutCustomerInput
    Order?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutCustomerInput
    Order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutCustomerNestedInput
    Order?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutCustomerNestedInput
    Order?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerCreateManyInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTokenInput
    customer?: CustomerCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: string | null
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTokenNestedInput
    customer?: CustomerUpdateOneWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: string | null
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenCreateInput = {
    id?: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dishCategories?: DishCategoryCreateNestedManyWithoutKitchenInput
    tables?: TableCreateNestedManyWithoutKitchenInput
    shop: ShopCreateNestedOneWithoutKitchenInput
  }

  export type KitchenUncheckedCreateInput = {
    id?: string
    shopId: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dishCategories?: DishCategoryUncheckedCreateNestedManyWithoutKitchenInput
    tables?: TableUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishCategories?: DishCategoryUpdateManyWithoutKitchenNestedInput
    tables?: TableUpdateManyWithoutKitchenNestedInput
    shop?: ShopUpdateOneRequiredWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishCategories?: DishCategoryUncheckedUpdateManyWithoutKitchenNestedInput
    tables?: TableUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenCreateManyInput = {
    id?: string
    shopId: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogCreateInput = {
    id?: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutKitchenLogInput
    user: UserCreateNestedOneWithoutKitchenLogInput
    order: OrderCreateNestedOneWithoutKitchenLogInput
  }

  export type KitchenLogUncheckedCreateInput = {
    id?: string
    shopId: string
    userId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutKitchenLogNestedInput
    user?: UserUpdateOneRequiredWithoutKitchenLogNestedInput
    order?: OrderUpdateOneRequiredWithoutKitchenLogNestedInput
  }

  export type KitchenLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogCreateManyInput = {
    id?: string
    shopId: string
    userId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DishOrderCreateInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    order?: OrderCreateNestedOneWithoutDishOrdersInput
    returnedOrder?: OrderCreateNestedOneWithoutReturnedDishOrdersInput
  }

  export type DishOrderUncheckedCreateInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    orderId?: string | null
    returnedOrderId?: string | null
  }

  export type DishOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutDishOrdersNestedInput
    returnedOrder?: OrderUpdateOneWithoutReturnedDishOrdersNestedInput
  }

  export type DishOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DishOrderCreateManyInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    orderId?: string | null
    returnedOrderId?: string | null
  }

  export type DishOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DishOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
    returnedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderCreateManyInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductCreateInput = {
    id?: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discount: DiscountCreateNestedOneWithoutDiscountProductsInput
  }

  export type DiscountProductUncheckedCreateInput = {
    id?: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    discountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discount?: DiscountUpdateOneRequiredWithoutDiscountProductsNestedInput
  }

  export type DiscountProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    discountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductCreateManyInput = {
    id?: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    discountId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    discountId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountCreateInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discountProducts?: DiscountProductCreateNestedManyWithoutDiscountInput
    orderSession?: OrderSessionCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    orderSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    discountProducts?: DiscountProductUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountProducts?: DiscountProductUpdateManyWithoutDiscountNestedInput
    orderSession?: OrderSessionUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountProducts?: DiscountProductUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountCreateManyInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    orderSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxDetailCreateInput = {
    id?: string
    taxAmount: number
    taxRate: number
    orderSession: OrderSessionCreateNestedOneWithoutTaxDetailsInput
  }

  export type TaxDetailUncheckedCreateInput = {
    id?: string
    taxAmount: number
    taxRate: number
    orderSessionId: string
  }

  export type TaxDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    orderSession?: OrderSessionUpdateOneRequiredWithoutTaxDetailsNestedInput
  }

  export type TaxDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type TaxDetailCreateManyInput = {
    id?: string
    taxAmount: number
    taxRate: number
    orderSessionId: string
  }

  export type TaxDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
  }

  export type TaxDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentDetailCreateInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
    orderSession: OrderSessionCreateNestedOneWithoutPaymentDetailsInput
  }

  export type PaymentDetailUncheckedCreateInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
    orderSessionId: string
  }

  export type PaymentDetailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    orderSession?: OrderSessionUpdateOneRequiredWithoutPaymentDetailsNestedInput
  }

  export type PaymentDetailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentDetailCreateManyInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
    orderSessionId: string
  }

  export type PaymentDetailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentDetailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: StringFieldUpdateOperationsInput | string
  }

  export type OrderSessionCreateInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountCreateNestedManyWithoutOrderSessionInput
    shop: ShopCreateNestedOneWithoutOrderSessionInput
    taxDetails?: TaxDetailCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUncheckedCreateInput = {
    id?: string
    shopId: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderSessionInput
    taxDetails?: TaxDetailUncheckedCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailUncheckedCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUpdateManyWithoutOrderSessionNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionCreateManyInput = {
    id?: string
    shopId: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShopCreateInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopUpdateInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateManyInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type ShopUpdateManyMutationInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ShopUncheckedUpdateManyInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateInput = {
    url: string
    id?: string
    dish?: DishCreateNestedOneWithoutImageUrlsInput
    shop?: ShopCreateNestedOneWithoutImageUrlsInput
  }

  export type ImageUncheckedCreateInput = {
    url: string
    shopId?: string | null
    dishId?: string | null
    id?: string
  }

  export type ImageUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateOneWithoutImageUrlsNestedInput
    shop?: ShopUpdateOneWithoutImageUrlsNestedInput
  }

  export type ImageUncheckedUpdateInput = {
    url?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    dishId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageCreateManyInput = {
    url: string
    shopId?: string | null
    dishId?: string | null
    id?: string
  }

  export type ImageUpdateManyMutationInput = {
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyInput = {
    url?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    dishId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishCategoryCreateInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutCategoryInput
    shop?: ShopCreateNestedOneWithoutDishCategoryInput
    tablePosition?: TablePositionCreateNestedManyWithoutDishCategoriesInput
    kitchen?: KitchenCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryUncheckedCreateInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutCategoryInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutDishCategoriesInput
    kitchen?: KitchenUncheckedCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutCategoryNestedInput
    shop?: ShopUpdateOneWithoutDishCategoryNestedInput
    tablePosition?: TablePositionUpdateManyWithoutDishCategoriesNestedInput
    kitchen?: KitchenUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutCategoryNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutDishCategoriesNestedInput
    kitchen?: KitchenUncheckedUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryCreateManyInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishCategoryUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishCategoryUncheckedUpdateManyInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishCreateInput = {
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    category?: DishCategoryCreateNestedOneWithoutDishInput
    shop?: ShopCreateNestedOneWithoutDishInput
    unit?: UnitCreateNestedOneWithoutDishInput
    imageUrls?: ImageCreateNestedManyWithoutDishInput
  }

  export type DishUncheckedCreateInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    imageUrls?: ImageUncheckedCreateNestedManyWithoutDishInput
  }

  export type DishUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    category?: DishCategoryUpdateOneWithoutDishNestedInput
    shop?: ShopUpdateOneWithoutDishNestedInput
    unit?: UnitUpdateOneWithoutDishNestedInput
    imageUrls?: ImageUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    imageUrls?: ImageUncheckedUpdateManyWithoutDishNestedInput
  }

  export type DishCreateManyInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishUncheckedUpdateManyInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UnitCreateInput = {
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutUnitInput
    shop: ShopCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    shopId: string
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutUnitNestedInput
    shop?: ShopUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitCreateManyInput = {
    shopId: string
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UnitUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TablePositionCreateInput = {
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTablePositionInput
    dishCategories?: DishCategoryCreateNestedManyWithoutTablePositionInput
    tables?: TableCreateNestedManyWithoutPositionInput
  }

  export type TablePositionUncheckedCreateInput = {
    shopId: string
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dishCategories?: DishCategoryUncheckedCreateNestedManyWithoutTablePositionInput
    tables?: TableUncheckedCreateNestedManyWithoutPositionInput
  }

  export type TablePositionUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTablePositionNestedInput
    dishCategories?: DishCategoryUpdateManyWithoutTablePositionNestedInput
    tables?: TableUpdateManyWithoutPositionNestedInput
  }

  export type TablePositionUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dishCategories?: DishCategoryUncheckedUpdateManyWithoutTablePositionNestedInput
    tables?: TableUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type TablePositionCreateManyInput = {
    shopId: string
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type TablePositionUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TablePositionUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TableCreateInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTableInput
    position?: TablePositionCreateNestedManyWithoutTablesInput
    Kitchen?: KitchenCreateNestedOneWithoutTablesInput
    Order?: OrderCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    kitchenId?: string | null
    position?: TablePositionUncheckedCreateNestedManyWithoutTablesInput
    Order?: OrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTableNestedInput
    position?: TablePositionUpdateManyWithoutTablesNestedInput
    Kitchen?: KitchenUpdateOneWithoutTablesNestedInput
    Order?: OrderUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: TablePositionUncheckedUpdateManyWithoutTablesNestedInput
    Order?: OrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableCreateManyInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    kitchenId?: string | null
  }

  export type TableUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TableUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeDepartmentCreateInput = {
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
    shop: ShopCreateNestedOneWithoutEmployeeDepartmentsInput
  }

  export type EmployeeDepartmentUncheckedCreateInput = {
    shopId: string
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type EmployeeDepartmentUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
    shop?: ShopUpdateOneRequiredWithoutEmployeeDepartmentsNestedInput
  }

  export type EmployeeDepartmentUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type EmployeeDepartmentCreateManyInput = {
    shopId: string
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeDepartmentUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeDepartmentUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeePositionCreateInput = {
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeCreateNestedManyWithoutPositionInput
    shop: ShopCreateNestedOneWithoutEmployeePositionsInput
  }

  export type EmployeePositionUncheckedCreateInput = {
    shopId: string
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type EmployeePositionUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
    shop?: ShopUpdateOneRequiredWithoutEmployeePositionsNestedInput
  }

  export type EmployeePositionUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type EmployeePositionCreateManyInput = {
    shopId: string
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeePositionUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeePositionUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeCreateInput = {
    name?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    department?: EmployeeDepartmentCreateNestedOneWithoutEmployeesInput
    position?: EmployeePositionCreateNestedOneWithoutEmployeesInput
    shop: ShopCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    shopId: string
    userId: string
    name?: string | null
    positionId?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    department?: EmployeeDepartmentUpdateOneWithoutEmployeesNestedInput
    position?: EmployeePositionUpdateOneWithoutEmployeesNestedInput
    shop?: ShopUpdateOneRequiredWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeCreateManyInput = {
    shopId: string
    userId: string
    name?: string | null
    positionId?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type ShopListRelationFilter = {
    every?: ShopWhereInput
    some?: ShopWhereInput
    none?: ShopWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type KitchenLogListRelationFilter = {
    every?: KitchenLogWhereInput
    some?: KitchenLogWhereInput
    none?: KitchenLogWhereInput
  }

  export type OrderListRelationFilter = {
    every?: OrderWhereInput
    some?: OrderWhereInput
    none?: OrderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KitchenLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    isEmailVerified?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CustomerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    anonymous?: SortOrder
    totalOrderTimes?: SortOrder
    totalOrderValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerAvgOrderByAggregateInput = {
    totalOrderTimes?: SortOrder
    totalOrderValue?: SortOrder
  }

  export type CustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    anonymous?: SortOrder
    totalOrderTimes?: SortOrder
    totalOrderValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    password?: SortOrder
    address?: SortOrder
    anonymous?: SortOrder
    totalOrderTimes?: SortOrder
    totalOrderValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerSumOrderByAggregateInput = {
    totalOrderTimes?: SortOrder
    totalOrderValue?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: CustomerWhereInput | null
    isNot?: CustomerWhereInput | null
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    isCustomer?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    isCustomer?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    type?: SortOrder
    expires?: SortOrder
    blacklisted?: SortOrder
    isCustomer?: SortOrder
    userId?: SortOrder
    customerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type EnumSwitchabletatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Switchabletatus | EnumSwitchabletatusFieldRefInput<$PrismaModel>
    in?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwitchabletatusFilter<$PrismaModel> | $Enums.Switchabletatus
  }

  export type DishCategoryListRelationFilter = {
    every?: DishCategoryWhereInput
    some?: DishCategoryWhereInput
    none?: DishCategoryWhereInput
  }

  export type TableListRelationFilter = {
    every?: TableWhereInput
    some?: TableWhereInput
    none?: TableWhereInput
  }

  export type ShopScalarRelationFilter = {
    is?: ShopWhereInput
    isNot?: ShopWhereInput
  }

  export type DishCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TableOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KitchenCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSwitchabletatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Switchabletatus | EnumSwitchabletatusFieldRefInput<$PrismaModel>
    in?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwitchabletatusWithAggregatesFilter<$PrismaModel> | $Enums.Switchabletatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSwitchabletatusFilter<$PrismaModel>
    _max?: NestedEnumSwitchabletatusFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumKitchenActionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenActionEnum | EnumKitchenActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenActionEnumFilter<$PrismaModel> | $Enums.KitchenActionEnum
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type OrderScalarRelationFilter = {
    is?: OrderWhereInput
    isNot?: OrderWhereInput
  }

  export type KitchenLogCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    dishOrderId?: SortOrder
    dishName?: SortOrder
    dishQuantity?: SortOrder
    status?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenLogAvgOrderByAggregateInput = {
    dishQuantity?: SortOrder
  }

  export type KitchenLogMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    dishOrderId?: SortOrder
    dishName?: SortOrder
    dishQuantity?: SortOrder
    status?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenLogMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    userId?: SortOrder
    orderId?: SortOrder
    dishOrderId?: SortOrder
    dishName?: SortOrder
    dishQuantity?: SortOrder
    status?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KitchenLogSumOrderByAggregateInput = {
    dishQuantity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumKitchenActionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenActionEnum | EnumKitchenActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenActionEnumWithAggregatesFilter<$PrismaModel> | $Enums.KitchenActionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKitchenActionEnumFilter<$PrismaModel>
    _max?: NestedEnumKitchenActionEnumFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumDishOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DishOrderStatus | EnumDishOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDishOrderStatusFilter<$PrismaModel> | $Enums.DishOrderStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type OrderNullableScalarRelationFilter = {
    is?: OrderWhereInput | null
    isNot?: OrderWhereInput | null
  }

  export type DishOrderCountOrderByAggregateInput = {
    id?: SortOrder
    dishOrderNo?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    isTaxIncludedPrice?: SortOrder
    taxIncludedPrice?: SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
    status?: SortOrder
    returnedAt?: SortOrder
    note?: SortOrder
    orderId?: SortOrder
    returnedOrderId?: SortOrder
  }

  export type DishOrderAvgOrderByAggregateInput = {
    dishOrderNo?: SortOrder
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
  }

  export type DishOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    dishOrderNo?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    isTaxIncludedPrice?: SortOrder
    taxIncludedPrice?: SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
    status?: SortOrder
    returnedAt?: SortOrder
    note?: SortOrder
    orderId?: SortOrder
    returnedOrderId?: SortOrder
  }

  export type DishOrderMinOrderByAggregateInput = {
    id?: SortOrder
    dishOrderNo?: SortOrder
    dishId?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    price?: SortOrder
    isTaxIncludedPrice?: SortOrder
    taxIncludedPrice?: SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
    status?: SortOrder
    returnedAt?: SortOrder
    note?: SortOrder
    orderId?: SortOrder
    returnedOrderId?: SortOrder
  }

  export type DishOrderSumOrderByAggregateInput = {
    dishOrderNo?: SortOrder
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    quantity?: SortOrder
    beforeTaxTotalPrice?: SortOrder
    afterTaxTotalPrice?: SortOrder
    taxRate?: SortOrder
    taxAmount?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    paymentAmount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumDishOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DishOrderStatus | EnumDishOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDishOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.DishOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDishOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumDishOrderStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumOrderSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSessionStatus | EnumOrderSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSessionStatusFilter<$PrismaModel> | $Enums.OrderSessionStatus
  }

  export type DishOrderListRelationFilter = {
    every?: DishOrderWhereInput
    some?: DishOrderWhereInput
    none?: DishOrderWhereInput
  }

  export type TableScalarRelationFilter = {
    is?: TableWhereInput
    isNot?: TableWhereInput
  }

  export type OrderSessionScalarRelationFilter = {
    is?: OrderSessionWhereInput
    isNot?: OrderSessionWhereInput
  }

  export type DishOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableId?: SortOrder
    orderSessionId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    approvedById?: SortOrder
    cancelledById?: SortOrder
    status?: SortOrder
    orderSessionStatus?: SortOrder
    numberOfCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderAvgOrderByAggregateInput = {
    orderNo?: SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    numberOfCustomer?: SortOrder
  }

  export type OrderMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableId?: SortOrder
    orderSessionId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    approvedById?: SortOrder
    cancelledById?: SortOrder
    status?: SortOrder
    orderSessionStatus?: SortOrder
    numberOfCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableId?: SortOrder
    orderSessionId?: SortOrder
    orderNo?: SortOrder
    customerId?: SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    approvedById?: SortOrder
    cancelledById?: SortOrder
    status?: SortOrder
    orderSessionStatus?: SortOrder
    numberOfCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSumOrderByAggregateInput = {
    orderNo?: SortOrder
    totalQuantity?: SortOrder
    totalBeforeTaxAmount?: SortOrder
    totalAfterTaxAmount?: SortOrder
    numberOfCustomer?: SortOrder
  }

  export type EnumOrderSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSessionStatus | EnumOrderSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderSessionStatusFilter<$PrismaModel>
  }

  export type EnumDiscountValueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountValueType | EnumDiscountValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountValueTypeFilter<$PrismaModel> | $Enums.DiscountValueType
  }

  export type DiscountScalarRelationFilter = {
    is?: DiscountWhereInput
    isNot?: DiscountWhereInput
  }

  export type DiscountProductCountOrderByAggregateInput = {
    id?: SortOrder
    dishOrderId?: SortOrder
    dishId?: SortOrder
    dishName?: SortOrder
    discountRate?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
    discountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountProductAvgOrderByAggregateInput = {
    discountRate?: SortOrder
    discountValue?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
  }

  export type DiscountProductMaxOrderByAggregateInput = {
    id?: SortOrder
    dishOrderId?: SortOrder
    dishId?: SortOrder
    dishName?: SortOrder
    discountRate?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
    discountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountProductMinOrderByAggregateInput = {
    id?: SortOrder
    dishOrderId?: SortOrder
    dishId?: SortOrder
    dishName?: SortOrder
    discountRate?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
    discountId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountProductSumOrderByAggregateInput = {
    discountRate?: SortOrder
    discountValue?: SortOrder
    beforeTaxDiscountPrice?: SortOrder
    afterTaxDiscountPrice?: SortOrder
    taxDiscountPrice?: SortOrder
  }

  export type EnumDiscountValueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountValueType | EnumDiscountValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountValueTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountValueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountValueTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountValueTypeFilter<$PrismaModel>
  }

  export type EnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type DiscountProductListRelationFilter = {
    every?: DiscountProductWhereInput
    some?: DiscountProductWhereInput
    none?: DiscountProductWhereInput
  }

  export type OrderSessionNullableScalarRelationFilter = {
    is?: OrderSessionWhereInput | null
    isNot?: OrderSessionWhereInput | null
  }

  export type DiscountProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DiscountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    orderSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountAvgOrderByAggregateInput = {
    discountValue?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
  }

  export type DiscountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    orderSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    discountType?: SortOrder
    discountValue?: SortOrder
    discountValueType?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
    orderSessionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DiscountSumOrderByAggregateInput = {
    discountValue?: SortOrder
    beforeTaxTotalDiscountAmount?: SortOrder
    afterTaxTotalDiscountAmount?: SortOrder
    taxTotalDiscountAmount?: SortOrder
  }

  export type EnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type TaxDetailCountOrderByAggregateInput = {
    id?: SortOrder
    taxAmount?: SortOrder
    taxRate?: SortOrder
    orderSessionId?: SortOrder
  }

  export type TaxDetailAvgOrderByAggregateInput = {
    taxAmount?: SortOrder
    taxRate?: SortOrder
  }

  export type TaxDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    taxAmount?: SortOrder
    taxRate?: SortOrder
    orderSessionId?: SortOrder
  }

  export type TaxDetailMinOrderByAggregateInput = {
    id?: SortOrder
    taxAmount?: SortOrder
    taxRate?: SortOrder
    orderSessionId?: SortOrder
  }

  export type TaxDetailSumOrderByAggregateInput = {
    taxAmount?: SortOrder
    taxRate?: SortOrder
  }

  export type EnumPaymentMethodEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumFilter<$PrismaModel> | $Enums.PaymentMethodEnum
  }

  export type PaymentDetailCountOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    paymentAmount?: SortOrder
    orderSessionId?: SortOrder
  }

  export type PaymentDetailAvgOrderByAggregateInput = {
    paymentAmount?: SortOrder
  }

  export type PaymentDetailMaxOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    paymentAmount?: SortOrder
    orderSessionId?: SortOrder
  }

  export type PaymentDetailMinOrderByAggregateInput = {
    id?: SortOrder
    paymentMethod?: SortOrder
    paymentAmount?: SortOrder
    orderSessionId?: SortOrder
  }

  export type PaymentDetailSumOrderByAggregateInput = {
    paymentAmount?: SortOrder
  }

  export type EnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DiscountListRelationFilter = {
    every?: DiscountWhereInput
    some?: DiscountWhereInput
    none?: DiscountWhereInput
  }

  export type TaxDetailListRelationFilter = {
    every?: TaxDetailWhereInput
    some?: TaxDetailWhereInput
    none?: TaxDetailWhereInput
  }

  export type PaymentDetailListRelationFilter = {
    every?: PaymentDetailWhereInput
    some?: PaymentDetailWhereInput
    none?: PaymentDetailWhereInput
  }

  export type DiscountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TaxDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentDetailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderSessionCountOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    tableIds?: SortOrder
    tableNames?: SortOrder
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    endedAt?: SortOrder
    auditedAt?: SortOrder
    status?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    paidByEmployeeId?: SortOrder
    paidByEmployeeName?: SortOrder
    cancelledByEmployeeId?: SortOrder
    cancelledByEmployeeName?: SortOrder
    cancellationReason?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerAddress?: SortOrder
    numberOfCustomer?: SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSessionAvgOrderByAggregateInput = {
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    numberOfCustomer?: SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
  }

  export type OrderSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    endedAt?: SortOrder
    auditedAt?: SortOrder
    status?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    paidByEmployeeId?: SortOrder
    paidByEmployeeName?: SortOrder
    cancelledByEmployeeId?: SortOrder
    cancelledByEmployeeName?: SortOrder
    cancellationReason?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerAddress?: SortOrder
    numberOfCustomer?: SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSessionMinOrderByAggregateInput = {
    id?: SortOrder
    shopId?: SortOrder
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    endedAt?: SortOrder
    auditedAt?: SortOrder
    status?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    paidByEmployeeId?: SortOrder
    paidByEmployeeName?: SortOrder
    cancelledByEmployeeId?: SortOrder
    cancelledByEmployeeName?: SortOrder
    cancellationReason?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    customerPhone?: SortOrder
    customerAddress?: SortOrder
    numberOfCustomer?: SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type OrderSessionSumOrderByAggregateInput = {
    orderSessionNo?: SortOrder
    taxRate?: SortOrder
    totalTaxAmount?: SortOrder
    pretaxPaymentAmount?: SortOrder
    paymentAmount?: SortOrder
    numberOfCustomer?: SortOrder
    totalDiscountAmountBeforeTax?: SortOrder
    totalDiscountAmountAfterTax?: SortOrder
  }

  export type EnumRoundingPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoundingPaymentType | EnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoundingPaymentTypeFilter<$PrismaModel> | $Enums.RoundingPaymentType
  }

  export type DishListRelationFilter = {
    every?: DishWhereInput
    some?: DishWhereInput
    none?: DishWhereInput
  }

  export type EmployeeDepartmentListRelationFilter = {
    every?: EmployeeDepartmentWhereInput
    some?: EmployeeDepartmentWhereInput
    none?: EmployeeDepartmentWhereInput
  }

  export type EmployeePositionListRelationFilter = {
    every?: EmployeePositionWhereInput
    some?: EmployeePositionWhereInput
    none?: EmployeePositionWhereInput
  }

  export type ImageListRelationFilter = {
    every?: ImageWhereInput
    some?: ImageWhereInput
    none?: ImageWhereInput
  }

  export type TablePositionListRelationFilter = {
    every?: TablePositionWhereInput
    some?: TablePositionWhereInput
    none?: TablePositionWhereInput
  }

  export type UnitListRelationFilter = {
    every?: UnitWhereInput
    some?: UnitWhereInput
    none?: UnitWhereInput
  }

  export type KitchenListRelationFilter = {
    every?: KitchenWhereInput
    some?: KitchenWhereInput
    none?: KitchenWhereInput
  }

  export type OrderSessionListRelationFilter = {
    every?: OrderSessionWhereInput
    some?: OrderSessionWhereInput
    none?: OrderSessionWhereInput
  }

  export type DishOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeDepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeePositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TablePositionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UnitOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type KitchenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OrderSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShopCountOrderByAggregateInput = {
    status?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    ownerId?: SortOrder
    taxRate?: SortOrder
    location?: SortOrder
    dishPriceRoundingType?: SortOrder
    discountRoundingType?: SortOrder
    taxRoundingType?: SortOrder
    calculateTaxDirectly?: SortOrder
    countryName?: SortOrder
    countryCurrency?: SortOrder
    utcOffset?: SortOrder
    timezone?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type ShopAvgOrderByAggregateInput = {
    taxRate?: SortOrder
    utcOffset?: SortOrder
    reportTime?: SortOrder
  }

  export type ShopMaxOrderByAggregateInput = {
    status?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    ownerId?: SortOrder
    taxRate?: SortOrder
    location?: SortOrder
    dishPriceRoundingType?: SortOrder
    discountRoundingType?: SortOrder
    taxRoundingType?: SortOrder
    calculateTaxDirectly?: SortOrder
    countryName?: SortOrder
    countryCurrency?: SortOrder
    utcOffset?: SortOrder
    timezone?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type ShopMinOrderByAggregateInput = {
    status?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    ownerId?: SortOrder
    taxRate?: SortOrder
    location?: SortOrder
    dishPriceRoundingType?: SortOrder
    discountRoundingType?: SortOrder
    taxRoundingType?: SortOrder
    calculateTaxDirectly?: SortOrder
    countryName?: SortOrder
    countryCurrency?: SortOrder
    utcOffset?: SortOrder
    timezone?: SortOrder
    reportTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type ShopSumOrderByAggregateInput = {
    taxRate?: SortOrder
    utcOffset?: SortOrder
    reportTime?: SortOrder
  }

  export type EnumRoundingPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoundingPaymentType | EnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoundingPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoundingPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoundingPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumRoundingPaymentTypeFilter<$PrismaModel>
  }

  export type DishNullableScalarRelationFilter = {
    is?: DishWhereInput | null
    isNot?: DishWhereInput | null
  }

  export type ShopNullableScalarRelationFilter = {
    is?: ShopWhereInput | null
    isNot?: ShopWhereInput | null
  }

  export type ImageCountOrderByAggregateInput = {
    url?: SortOrder
    shopId?: SortOrder
    dishId?: SortOrder
    id?: SortOrder
  }

  export type ImageMaxOrderByAggregateInput = {
    url?: SortOrder
    shopId?: SortOrder
    dishId?: SortOrder
    id?: SortOrder
  }

  export type ImageMinOrderByAggregateInput = {
    url?: SortOrder
    shopId?: SortOrder
    dishId?: SortOrder
    id?: SortOrder
  }

  export type DishCategoryCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type DishCategoryMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type DishCategoryMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type DishCategoryNullableScalarRelationFilter = {
    is?: DishCategoryWhereInput | null
    isNot?: DishCategoryWhereInput | null
  }

  export type UnitNullableScalarRelationFilter = {
    is?: UnitWhereInput | null
    isNot?: UnitWhereInput | null
  }

  export type DishCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    isTaxIncludedPrice?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    taxRate?: SortOrder
    status?: SortOrder
    isNewlyCreated?: SortOrder
    isBestSeller?: SortOrder
    stockQuantity?: SortOrder
    hideForCustomers?: SortOrder
    hideForEmployees?: SortOrder
    outOfStockNotification?: SortOrder
    description?: SortOrder
    soldCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type DishAvgOrderByAggregateInput = {
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    taxRate?: SortOrder
    stockQuantity?: SortOrder
    soldCount?: SortOrder
  }

  export type DishMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    isTaxIncludedPrice?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    taxRate?: SortOrder
    status?: SortOrder
    isNewlyCreated?: SortOrder
    isBestSeller?: SortOrder
    stockQuantity?: SortOrder
    hideForCustomers?: SortOrder
    hideForEmployees?: SortOrder
    outOfStockNotification?: SortOrder
    description?: SortOrder
    soldCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type DishMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    unitId?: SortOrder
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    isTaxIncludedPrice?: SortOrder
    categoryId?: SortOrder
    type?: SortOrder
    taxRate?: SortOrder
    status?: SortOrder
    isNewlyCreated?: SortOrder
    isBestSeller?: SortOrder
    stockQuantity?: SortOrder
    hideForCustomers?: SortOrder
    hideForEmployees?: SortOrder
    outOfStockNotification?: SortOrder
    description?: SortOrder
    soldCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type DishSumOrderByAggregateInput = {
    price?: SortOrder
    taxIncludedPrice?: SortOrder
    taxRate?: SortOrder
    stockQuantity?: SortOrder
    soldCount?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type TablePositionCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    dishCategoryIds?: SortOrder
    tableIds?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type TablePositionMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type TablePositionMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type KitchenNullableScalarRelationFilter = {
    is?: KitchenWhereInput | null
    isNot?: KitchenWhereInput | null
  }

  export type TableCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    positionId?: SortOrder
    status?: SortOrder
    allowMultipleOrderSession?: SortOrder
    needApprovalWhenCustomerOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    kitchenId?: SortOrder
  }

  export type TableMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    positionId?: SortOrder
    status?: SortOrder
    allowMultipleOrderSession?: SortOrder
    needApprovalWhenCustomerOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    kitchenId?: SortOrder
  }

  export type TableMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    positionId?: SortOrder
    status?: SortOrder
    allowMultipleOrderSession?: SortOrder
    needApprovalWhenCustomerOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
    kitchenId?: SortOrder
  }

  export type EmployeeDepartmentCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    permissions?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeeDepartmentMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeeDepartmentMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeePositionCountOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeePositionMaxOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeePositionMinOrderByAggregateInput = {
    shopId?: SortOrder
    name?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeeDepartmentNullableScalarRelationFilter = {
    is?: EmployeeDepartmentWhereInput | null
    isNot?: EmployeeDepartmentWhereInput | null
  }

  export type EmployeePositionNullableScalarRelationFilter = {
    is?: EmployeePositionWhereInput | null
    isNot?: EmployeePositionWhereInput | null
  }

  export type EmployeeCountOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    positionId?: SortOrder
    departmentId?: SortOrder
    status?: SortOrder
    permissions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    positionId?: SortOrder
    departmentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    shopId?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    positionId?: SortOrder
    departmentId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    id?: SortOrder
  }

  export type EmployeeCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShopCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ShopCreateWithoutOwnerInput, ShopUncheckedCreateWithoutOwnerInput> | ShopCreateWithoutOwnerInput[] | ShopUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutOwnerInput | ShopCreateOrConnectWithoutOwnerInput[]
    createMany?: ShopCreateManyOwnerInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type KitchenLogCreateNestedManyWithoutUserInput = {
    create?: XOR<KitchenLogCreateWithoutUserInput, KitchenLogUncheckedCreateWithoutUserInput> | KitchenLogCreateWithoutUserInput[] | KitchenLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutUserInput | KitchenLogCreateOrConnectWithoutUserInput[]
    createMany?: KitchenLogCreateManyUserInputEnvelope
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCancelledByInput = {
    create?: XOR<OrderCreateWithoutCancelledByInput, OrderUncheckedCreateWithoutCancelledByInput> | OrderCreateWithoutCancelledByInput[] | OrderUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCancelledByInput | OrderCreateOrConnectWithoutCancelledByInput[]
    createMany?: OrderCreateManyCancelledByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShopUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<ShopCreateWithoutOwnerInput, ShopUncheckedCreateWithoutOwnerInput> | ShopCreateWithoutOwnerInput[] | ShopUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutOwnerInput | ShopCreateOrConnectWithoutOwnerInput[]
    createMany?: ShopCreateManyOwnerInputEnvelope
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type KitchenLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<KitchenLogCreateWithoutUserInput, KitchenLogUncheckedCreateWithoutUserInput> | KitchenLogCreateWithoutUserInput[] | KitchenLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutUserInput | KitchenLogCreateOrConnectWithoutUserInput[]
    createMany?: KitchenLogCreateManyUserInputEnvelope
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCancelledByInput = {
    create?: XOR<OrderCreateWithoutCancelledByInput, OrderUncheckedCreateWithoutCancelledByInput> | OrderCreateWithoutCancelledByInput[] | OrderUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCancelledByInput | OrderCreateOrConnectWithoutCancelledByInput[]
    createMany?: OrderCreateManyCancelledByInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EmployeeUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutUserInput | EmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutUserInput | EmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutUserInput | EmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShopUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ShopCreateWithoutOwnerInput, ShopUncheckedCreateWithoutOwnerInput> | ShopCreateWithoutOwnerInput[] | ShopUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutOwnerInput | ShopCreateOrConnectWithoutOwnerInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutOwnerInput | ShopUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ShopCreateManyOwnerInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutOwnerInput | ShopUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutOwnerInput | ShopUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type KitchenLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<KitchenLogCreateWithoutUserInput, KitchenLogUncheckedCreateWithoutUserInput> | KitchenLogCreateWithoutUserInput[] | KitchenLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutUserInput | KitchenLogCreateOrConnectWithoutUserInput[]
    upsert?: KitchenLogUpsertWithWhereUniqueWithoutUserInput | KitchenLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KitchenLogCreateManyUserInputEnvelope
    set?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    disconnect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    delete?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    update?: KitchenLogUpdateWithWhereUniqueWithoutUserInput | KitchenLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KitchenLogUpdateManyWithWhereWithoutUserInput | KitchenLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutApprovedByInput | OrderUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutApprovedByInput | OrderUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutApprovedByInput | OrderUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCancelledByNestedInput = {
    create?: XOR<OrderCreateWithoutCancelledByInput, OrderUncheckedCreateWithoutCancelledByInput> | OrderCreateWithoutCancelledByInput[] | OrderUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCancelledByInput | OrderCreateOrConnectWithoutCancelledByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCancelledByInput | OrderUpsertWithWhereUniqueWithoutCancelledByInput[]
    createMany?: OrderCreateManyCancelledByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCancelledByInput | OrderUpdateWithWhereUniqueWithoutCancelledByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCancelledByInput | OrderUpdateManyWithWhereWithoutCancelledByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput> | EmployeeCreateWithoutUserInput[] | EmployeeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput | EmployeeCreateOrConnectWithoutUserInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutUserInput | EmployeeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmployeeCreateManyUserInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutUserInput | EmployeeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutUserInput | EmployeeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShopUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<ShopCreateWithoutOwnerInput, ShopUncheckedCreateWithoutOwnerInput> | ShopCreateWithoutOwnerInput[] | ShopUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: ShopCreateOrConnectWithoutOwnerInput | ShopCreateOrConnectWithoutOwnerInput[]
    upsert?: ShopUpsertWithWhereUniqueWithoutOwnerInput | ShopUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: ShopCreateManyOwnerInputEnvelope
    set?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    disconnect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    delete?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    connect?: ShopWhereUniqueInput | ShopWhereUniqueInput[]
    update?: ShopUpdateWithWhereUniqueWithoutOwnerInput | ShopUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: ShopUpdateManyWithWhereWithoutOwnerInput | ShopUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: ShopScalarWhereInput | ShopScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type KitchenLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<KitchenLogCreateWithoutUserInput, KitchenLogUncheckedCreateWithoutUserInput> | KitchenLogCreateWithoutUserInput[] | KitchenLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutUserInput | KitchenLogCreateOrConnectWithoutUserInput[]
    upsert?: KitchenLogUpsertWithWhereUniqueWithoutUserInput | KitchenLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: KitchenLogCreateManyUserInputEnvelope
    set?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    disconnect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    delete?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    update?: KitchenLogUpdateWithWhereUniqueWithoutUserInput | KitchenLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: KitchenLogUpdateManyWithWhereWithoutUserInput | KitchenLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput> | OrderCreateWithoutApprovedByInput[] | OrderUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutApprovedByInput | OrderCreateOrConnectWithoutApprovedByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutApprovedByInput | OrderUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: OrderCreateManyApprovedByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutApprovedByInput | OrderUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutApprovedByInput | OrderUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCancelledByNestedInput = {
    create?: XOR<OrderCreateWithoutCancelledByInput, OrderUncheckedCreateWithoutCancelledByInput> | OrderCreateWithoutCancelledByInput[] | OrderUncheckedCreateWithoutCancelledByInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCancelledByInput | OrderCreateOrConnectWithoutCancelledByInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCancelledByInput | OrderUpsertWithWhereUniqueWithoutCancelledByInput[]
    createMany?: OrderCreateManyCancelledByInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCancelledByInput | OrderUpdateWithWhereUniqueWithoutCancelledByInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCancelledByInput | OrderUpdateManyWithWhereWithoutCancelledByInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TokenCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TokenCreateWithoutCustomerInput, TokenUncheckedCreateWithoutCustomerInput> | TokenCreateWithoutCustomerInput[] | TokenUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCustomerInput | TokenCreateOrConnectWithoutCustomerInput[]
    createMany?: TokenCreateManyCustomerInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<TokenCreateWithoutCustomerInput, TokenUncheckedCreateWithoutCustomerInput> | TokenCreateWithoutCustomerInput[] | TokenUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCustomerInput | TokenCreateOrConnectWithoutCustomerInput[]
    createMany?: TokenCreateManyCustomerInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TokenUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TokenCreateWithoutCustomerInput, TokenUncheckedCreateWithoutCustomerInput> | TokenCreateWithoutCustomerInput[] | TokenUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCustomerInput | TokenCreateOrConnectWithoutCustomerInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutCustomerInput | TokenUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TokenCreateManyCustomerInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutCustomerInput | TokenUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutCustomerInput | TokenUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<TokenCreateWithoutCustomerInput, TokenUncheckedCreateWithoutCustomerInput> | TokenCreateWithoutCustomerInput[] | TokenUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutCustomerInput | TokenCreateOrConnectWithoutCustomerInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutCustomerInput | TokenUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: TokenCreateManyCustomerInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutCustomerInput | TokenUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutCustomerInput | TokenUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput> | OrderCreateWithoutCustomerInput[] | OrderUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutCustomerInput | OrderCreateOrConnectWithoutCustomerInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutCustomerInput | OrderUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: OrderCreateManyCustomerInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutCustomerInput | OrderUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutCustomerInput | OrderUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTokenInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    connect?: UserWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutTokensInput = {
    create?: XOR<CustomerCreateWithoutTokensInput, CustomerUncheckedCreateWithoutTokensInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTokensInput
    connect?: CustomerWhereUniqueInput
  }

  export type EnumTokenTypeFieldUpdateOperationsInput = {
    set?: $Enums.TokenType
  }

  export type UserUpdateOneWithoutTokenNestedInput = {
    create?: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    connectOrCreate?: UserCreateOrConnectWithoutTokenInput
    upsert?: UserUpsertWithoutTokenInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTokenInput, UserUpdateWithoutTokenInput>, UserUncheckedUpdateWithoutTokenInput>
  }

  export type CustomerUpdateOneWithoutTokensNestedInput = {
    create?: XOR<CustomerCreateWithoutTokensInput, CustomerUncheckedCreateWithoutTokensInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutTokensInput
    upsert?: CustomerUpsertWithoutTokensInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutTokensInput, CustomerUpdateWithoutTokensInput>, CustomerUncheckedUpdateWithoutTokensInput>
  }

  export type DishCategoryCreateNestedManyWithoutKitchenInput = {
    create?: XOR<DishCategoryCreateWithoutKitchenInput, DishCategoryUncheckedCreateWithoutKitchenInput> | DishCategoryCreateWithoutKitchenInput[] | DishCategoryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutKitchenInput | DishCategoryCreateOrConnectWithoutKitchenInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
  }

  export type TableCreateNestedManyWithoutKitchenInput = {
    create?: XOR<TableCreateWithoutKitchenInput, TableUncheckedCreateWithoutKitchenInput> | TableCreateWithoutKitchenInput[] | TableUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: TableCreateOrConnectWithoutKitchenInput | TableCreateOrConnectWithoutKitchenInput[]
    createMany?: TableCreateManyKitchenInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutKitchenInput = {
    create?: XOR<ShopCreateWithoutKitchenInput, ShopUncheckedCreateWithoutKitchenInput>
    connectOrCreate?: ShopCreateOrConnectWithoutKitchenInput
    connect?: ShopWhereUniqueInput
  }

  export type DishCategoryUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<DishCategoryCreateWithoutKitchenInput, DishCategoryUncheckedCreateWithoutKitchenInput> | DishCategoryCreateWithoutKitchenInput[] | DishCategoryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutKitchenInput | DishCategoryCreateOrConnectWithoutKitchenInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutKitchenInput = {
    create?: XOR<TableCreateWithoutKitchenInput, TableUncheckedCreateWithoutKitchenInput> | TableCreateWithoutKitchenInput[] | TableUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: TableCreateOrConnectWithoutKitchenInput | TableCreateOrConnectWithoutKitchenInput[]
    createMany?: TableCreateManyKitchenInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type EnumSwitchabletatusFieldUpdateOperationsInput = {
    set?: $Enums.Switchabletatus
  }

  export type DishCategoryUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<DishCategoryCreateWithoutKitchenInput, DishCategoryUncheckedCreateWithoutKitchenInput> | DishCategoryCreateWithoutKitchenInput[] | DishCategoryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutKitchenInput | DishCategoryCreateOrConnectWithoutKitchenInput[]
    upsert?: DishCategoryUpsertWithWhereUniqueWithoutKitchenInput | DishCategoryUpsertWithWhereUniqueWithoutKitchenInput[]
    set?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    disconnect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    delete?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    update?: DishCategoryUpdateWithWhereUniqueWithoutKitchenInput | DishCategoryUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: DishCategoryUpdateManyWithWhereWithoutKitchenInput | DishCategoryUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
  }

  export type TableUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<TableCreateWithoutKitchenInput, TableUncheckedCreateWithoutKitchenInput> | TableCreateWithoutKitchenInput[] | TableUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: TableCreateOrConnectWithoutKitchenInput | TableCreateOrConnectWithoutKitchenInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutKitchenInput | TableUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: TableCreateManyKitchenInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutKitchenInput | TableUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: TableUpdateManyWithWhereWithoutKitchenInput | TableUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type ShopUpdateOneRequiredWithoutKitchenNestedInput = {
    create?: XOR<ShopCreateWithoutKitchenInput, ShopUncheckedCreateWithoutKitchenInput>
    connectOrCreate?: ShopCreateOrConnectWithoutKitchenInput
    upsert?: ShopUpsertWithoutKitchenInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutKitchenInput, ShopUpdateWithoutKitchenInput>, ShopUncheckedUpdateWithoutKitchenInput>
  }

  export type DishCategoryUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<DishCategoryCreateWithoutKitchenInput, DishCategoryUncheckedCreateWithoutKitchenInput> | DishCategoryCreateWithoutKitchenInput[] | DishCategoryUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutKitchenInput | DishCategoryCreateOrConnectWithoutKitchenInput[]
    upsert?: DishCategoryUpsertWithWhereUniqueWithoutKitchenInput | DishCategoryUpsertWithWhereUniqueWithoutKitchenInput[]
    set?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    disconnect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    delete?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    update?: DishCategoryUpdateWithWhereUniqueWithoutKitchenInput | DishCategoryUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: DishCategoryUpdateManyWithWhereWithoutKitchenInput | DishCategoryUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutKitchenNestedInput = {
    create?: XOR<TableCreateWithoutKitchenInput, TableUncheckedCreateWithoutKitchenInput> | TableCreateWithoutKitchenInput[] | TableUncheckedCreateWithoutKitchenInput[]
    connectOrCreate?: TableCreateOrConnectWithoutKitchenInput | TableCreateOrConnectWithoutKitchenInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutKitchenInput | TableUpsertWithWhereUniqueWithoutKitchenInput[]
    createMany?: TableCreateManyKitchenInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutKitchenInput | TableUpdateWithWhereUniqueWithoutKitchenInput[]
    updateMany?: TableUpdateManyWithWhereWithoutKitchenInput | TableUpdateManyWithWhereWithoutKitchenInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutKitchenLogInput = {
    create?: XOR<ShopCreateWithoutKitchenLogInput, ShopUncheckedCreateWithoutKitchenLogInput>
    connectOrCreate?: ShopCreateOrConnectWithoutKitchenLogInput
    connect?: ShopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutKitchenLogInput = {
    create?: XOR<UserCreateWithoutKitchenLogInput, UserUncheckedCreateWithoutKitchenLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutKitchenLogInput
    connect?: UserWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutKitchenLogInput = {
    create?: XOR<OrderCreateWithoutKitchenLogInput, OrderUncheckedCreateWithoutKitchenLogInput>
    connectOrCreate?: OrderCreateOrConnectWithoutKitchenLogInput
    connect?: OrderWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumKitchenActionEnumFieldUpdateOperationsInput = {
    set?: $Enums.KitchenActionEnum
  }

  export type ShopUpdateOneRequiredWithoutKitchenLogNestedInput = {
    create?: XOR<ShopCreateWithoutKitchenLogInput, ShopUncheckedCreateWithoutKitchenLogInput>
    connectOrCreate?: ShopCreateOrConnectWithoutKitchenLogInput
    upsert?: ShopUpsertWithoutKitchenLogInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutKitchenLogInput, ShopUpdateWithoutKitchenLogInput>, ShopUncheckedUpdateWithoutKitchenLogInput>
  }

  export type UserUpdateOneRequiredWithoutKitchenLogNestedInput = {
    create?: XOR<UserCreateWithoutKitchenLogInput, UserUncheckedCreateWithoutKitchenLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutKitchenLogInput
    upsert?: UserUpsertWithoutKitchenLogInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutKitchenLogInput, UserUpdateWithoutKitchenLogInput>, UserUncheckedUpdateWithoutKitchenLogInput>
  }

  export type OrderUpdateOneRequiredWithoutKitchenLogNestedInput = {
    create?: XOR<OrderCreateWithoutKitchenLogInput, OrderUncheckedCreateWithoutKitchenLogInput>
    connectOrCreate?: OrderCreateOrConnectWithoutKitchenLogInput
    upsert?: OrderUpsertWithoutKitchenLogInput
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutKitchenLogInput, OrderUpdateWithoutKitchenLogInput>, OrderUncheckedUpdateWithoutKitchenLogInput>
  }

  export type OrderCreateNestedOneWithoutDishOrdersInput = {
    create?: XOR<OrderCreateWithoutDishOrdersInput, OrderUncheckedCreateWithoutDishOrdersInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDishOrdersInput
    connect?: OrderWhereUniqueInput
  }

  export type OrderCreateNestedOneWithoutReturnedDishOrdersInput = {
    create?: XOR<OrderCreateWithoutReturnedDishOrdersInput, OrderUncheckedCreateWithoutReturnedDishOrdersInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReturnedDishOrdersInput
    connect?: OrderWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumDishOrderStatusFieldUpdateOperationsInput = {
    set?: $Enums.DishOrderStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type OrderUpdateOneWithoutDishOrdersNestedInput = {
    create?: XOR<OrderCreateWithoutDishOrdersInput, OrderUncheckedCreateWithoutDishOrdersInput>
    connectOrCreate?: OrderCreateOrConnectWithoutDishOrdersInput
    upsert?: OrderUpsertWithoutDishOrdersInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutDishOrdersInput, OrderUpdateWithoutDishOrdersInput>, OrderUncheckedUpdateWithoutDishOrdersInput>
  }

  export type OrderUpdateOneWithoutReturnedDishOrdersNestedInput = {
    create?: XOR<OrderCreateWithoutReturnedDishOrdersInput, OrderUncheckedCreateWithoutReturnedDishOrdersInput>
    connectOrCreate?: OrderCreateOrConnectWithoutReturnedDishOrdersInput
    upsert?: OrderUpsertWithoutReturnedDishOrdersInput
    disconnect?: OrderWhereInput | boolean
    delete?: OrderWhereInput | boolean
    connect?: OrderWhereUniqueInput
    update?: XOR<XOR<OrderUpdateToOneWithWhereWithoutReturnedDishOrdersInput, OrderUpdateWithoutReturnedDishOrdersInput>, OrderUncheckedUpdateWithoutReturnedDishOrdersInput>
  }

  export type DishOrderCreateNestedManyWithoutOrderInput = {
    create?: XOR<DishOrderCreateWithoutOrderInput, DishOrderUncheckedCreateWithoutOrderInput> | DishOrderCreateWithoutOrderInput[] | DishOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutOrderInput | DishOrderCreateOrConnectWithoutOrderInput[]
    createMany?: DishOrderCreateManyOrderInputEnvelope
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
  }

  export type DishOrderCreateNestedManyWithoutReturnedOrderInput = {
    create?: XOR<DishOrderCreateWithoutReturnedOrderInput, DishOrderUncheckedCreateWithoutReturnedOrderInput> | DishOrderCreateWithoutReturnedOrderInput[] | DishOrderUncheckedCreateWithoutReturnedOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutReturnedOrderInput | DishOrderCreateOrConnectWithoutReturnedOrderInput[]
    createMany?: DishOrderCreateManyReturnedOrderInputEnvelope
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutOrderInput = {
    create?: XOR<ShopCreateWithoutOrderInput, ShopUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrderInput
    connect?: ShopWhereUniqueInput
  }

  export type TableCreateNestedOneWithoutOrderInput = {
    create?: XOR<TableCreateWithoutOrderInput, TableUncheckedCreateWithoutOrderInput>
    connectOrCreate?: TableCreateOrConnectWithoutOrderInput
    connect?: TableWhereUniqueInput
  }

  export type OrderSessionCreateNestedOneWithoutOrdersInput = {
    create?: XOR<OrderSessionCreateWithoutOrdersInput, OrderSessionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutOrdersInput
    connect?: OrderSessionWhereUniqueInput
  }

  export type CustomerCreateNestedOneWithoutOrderInput = {
    create?: XOR<CustomerCreateWithoutOrderInput, CustomerUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrderInput
    connect?: CustomerWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutApproveOrderInput = {
    create?: XOR<UserCreateWithoutApproveOrderInput, UserUncheckedCreateWithoutApproveOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproveOrderInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCancelledOrderInput = {
    create?: XOR<UserCreateWithoutCancelledOrderInput, UserUncheckedCreateWithoutCancelledOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancelledOrderInput
    connect?: UserWhereUniqueInput
  }

  export type KitchenLogCreateNestedManyWithoutOrderInput = {
    create?: XOR<KitchenLogCreateWithoutOrderInput, KitchenLogUncheckedCreateWithoutOrderInput> | KitchenLogCreateWithoutOrderInput[] | KitchenLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutOrderInput | KitchenLogCreateOrConnectWithoutOrderInput[]
    createMany?: KitchenLogCreateManyOrderInputEnvelope
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
  }

  export type DishOrderUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<DishOrderCreateWithoutOrderInput, DishOrderUncheckedCreateWithoutOrderInput> | DishOrderCreateWithoutOrderInput[] | DishOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutOrderInput | DishOrderCreateOrConnectWithoutOrderInput[]
    createMany?: DishOrderCreateManyOrderInputEnvelope
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
  }

  export type DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput = {
    create?: XOR<DishOrderCreateWithoutReturnedOrderInput, DishOrderUncheckedCreateWithoutReturnedOrderInput> | DishOrderCreateWithoutReturnedOrderInput[] | DishOrderUncheckedCreateWithoutReturnedOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutReturnedOrderInput | DishOrderCreateOrConnectWithoutReturnedOrderInput[]
    createMany?: DishOrderCreateManyReturnedOrderInputEnvelope
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
  }

  export type KitchenLogUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<KitchenLogCreateWithoutOrderInput, KitchenLogUncheckedCreateWithoutOrderInput> | KitchenLogCreateWithoutOrderInput[] | KitchenLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutOrderInput | KitchenLogCreateOrConnectWithoutOrderInput[]
    createMany?: KitchenLogCreateManyOrderInputEnvelope
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
  }

  export type EnumOrderSessionStatusFieldUpdateOperationsInput = {
    set?: $Enums.OrderSessionStatus
  }

  export type DishOrderUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DishOrderCreateWithoutOrderInput, DishOrderUncheckedCreateWithoutOrderInput> | DishOrderCreateWithoutOrderInput[] | DishOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutOrderInput | DishOrderCreateOrConnectWithoutOrderInput[]
    upsert?: DishOrderUpsertWithWhereUniqueWithoutOrderInput | DishOrderUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DishOrderCreateManyOrderInputEnvelope
    set?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    disconnect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    delete?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    update?: DishOrderUpdateWithWhereUniqueWithoutOrderInput | DishOrderUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DishOrderUpdateManyWithWhereWithoutOrderInput | DishOrderUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DishOrderScalarWhereInput | DishOrderScalarWhereInput[]
  }

  export type DishOrderUpdateManyWithoutReturnedOrderNestedInput = {
    create?: XOR<DishOrderCreateWithoutReturnedOrderInput, DishOrderUncheckedCreateWithoutReturnedOrderInput> | DishOrderCreateWithoutReturnedOrderInput[] | DishOrderUncheckedCreateWithoutReturnedOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutReturnedOrderInput | DishOrderCreateOrConnectWithoutReturnedOrderInput[]
    upsert?: DishOrderUpsertWithWhereUniqueWithoutReturnedOrderInput | DishOrderUpsertWithWhereUniqueWithoutReturnedOrderInput[]
    createMany?: DishOrderCreateManyReturnedOrderInputEnvelope
    set?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    disconnect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    delete?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    update?: DishOrderUpdateWithWhereUniqueWithoutReturnedOrderInput | DishOrderUpdateWithWhereUniqueWithoutReturnedOrderInput[]
    updateMany?: DishOrderUpdateManyWithWhereWithoutReturnedOrderInput | DishOrderUpdateManyWithWhereWithoutReturnedOrderInput[]
    deleteMany?: DishOrderScalarWhereInput | DishOrderScalarWhereInput[]
  }

  export type ShopUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<ShopCreateWithoutOrderInput, ShopUncheckedCreateWithoutOrderInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrderInput
    upsert?: ShopUpsertWithoutOrderInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutOrderInput, ShopUpdateWithoutOrderInput>, ShopUncheckedUpdateWithoutOrderInput>
  }

  export type TableUpdateOneRequiredWithoutOrderNestedInput = {
    create?: XOR<TableCreateWithoutOrderInput, TableUncheckedCreateWithoutOrderInput>
    connectOrCreate?: TableCreateOrConnectWithoutOrderInput
    upsert?: TableUpsertWithoutOrderInput
    connect?: TableWhereUniqueInput
    update?: XOR<XOR<TableUpdateToOneWithWhereWithoutOrderInput, TableUpdateWithoutOrderInput>, TableUncheckedUpdateWithoutOrderInput>
  }

  export type OrderSessionUpdateOneRequiredWithoutOrdersNestedInput = {
    create?: XOR<OrderSessionCreateWithoutOrdersInput, OrderSessionUncheckedCreateWithoutOrdersInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutOrdersInput
    upsert?: OrderSessionUpsertWithoutOrdersInput
    connect?: OrderSessionWhereUniqueInput
    update?: XOR<XOR<OrderSessionUpdateToOneWithWhereWithoutOrdersInput, OrderSessionUpdateWithoutOrdersInput>, OrderSessionUncheckedUpdateWithoutOrdersInput>
  }

  export type CustomerUpdateOneWithoutOrderNestedInput = {
    create?: XOR<CustomerCreateWithoutOrderInput, CustomerUncheckedCreateWithoutOrderInput>
    connectOrCreate?: CustomerCreateOrConnectWithoutOrderInput
    upsert?: CustomerUpsertWithoutOrderInput
    disconnect?: CustomerWhereInput | boolean
    delete?: CustomerWhereInput | boolean
    connect?: CustomerWhereUniqueInput
    update?: XOR<XOR<CustomerUpdateToOneWithWhereWithoutOrderInput, CustomerUpdateWithoutOrderInput>, CustomerUncheckedUpdateWithoutOrderInput>
  }

  export type UserUpdateOneWithoutApproveOrderNestedInput = {
    create?: XOR<UserCreateWithoutApproveOrderInput, UserUncheckedCreateWithoutApproveOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutApproveOrderInput
    upsert?: UserUpsertWithoutApproveOrderInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutApproveOrderInput, UserUpdateWithoutApproveOrderInput>, UserUncheckedUpdateWithoutApproveOrderInput>
  }

  export type UserUpdateOneWithoutCancelledOrderNestedInput = {
    create?: XOR<UserCreateWithoutCancelledOrderInput, UserUncheckedCreateWithoutCancelledOrderInput>
    connectOrCreate?: UserCreateOrConnectWithoutCancelledOrderInput
    upsert?: UserUpsertWithoutCancelledOrderInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCancelledOrderInput, UserUpdateWithoutCancelledOrderInput>, UserUncheckedUpdateWithoutCancelledOrderInput>
  }

  export type KitchenLogUpdateManyWithoutOrderNestedInput = {
    create?: XOR<KitchenLogCreateWithoutOrderInput, KitchenLogUncheckedCreateWithoutOrderInput> | KitchenLogCreateWithoutOrderInput[] | KitchenLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutOrderInput | KitchenLogCreateOrConnectWithoutOrderInput[]
    upsert?: KitchenLogUpsertWithWhereUniqueWithoutOrderInput | KitchenLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: KitchenLogCreateManyOrderInputEnvelope
    set?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    disconnect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    delete?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    update?: KitchenLogUpdateWithWhereUniqueWithoutOrderInput | KitchenLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: KitchenLogUpdateManyWithWhereWithoutOrderInput | KitchenLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
  }

  export type DishOrderUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<DishOrderCreateWithoutOrderInput, DishOrderUncheckedCreateWithoutOrderInput> | DishOrderCreateWithoutOrderInput[] | DishOrderUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutOrderInput | DishOrderCreateOrConnectWithoutOrderInput[]
    upsert?: DishOrderUpsertWithWhereUniqueWithoutOrderInput | DishOrderUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: DishOrderCreateManyOrderInputEnvelope
    set?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    disconnect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    delete?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    update?: DishOrderUpdateWithWhereUniqueWithoutOrderInput | DishOrderUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: DishOrderUpdateManyWithWhereWithoutOrderInput | DishOrderUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: DishOrderScalarWhereInput | DishOrderScalarWhereInput[]
  }

  export type DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput = {
    create?: XOR<DishOrderCreateWithoutReturnedOrderInput, DishOrderUncheckedCreateWithoutReturnedOrderInput> | DishOrderCreateWithoutReturnedOrderInput[] | DishOrderUncheckedCreateWithoutReturnedOrderInput[]
    connectOrCreate?: DishOrderCreateOrConnectWithoutReturnedOrderInput | DishOrderCreateOrConnectWithoutReturnedOrderInput[]
    upsert?: DishOrderUpsertWithWhereUniqueWithoutReturnedOrderInput | DishOrderUpsertWithWhereUniqueWithoutReturnedOrderInput[]
    createMany?: DishOrderCreateManyReturnedOrderInputEnvelope
    set?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    disconnect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    delete?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    connect?: DishOrderWhereUniqueInput | DishOrderWhereUniqueInput[]
    update?: DishOrderUpdateWithWhereUniqueWithoutReturnedOrderInput | DishOrderUpdateWithWhereUniqueWithoutReturnedOrderInput[]
    updateMany?: DishOrderUpdateManyWithWhereWithoutReturnedOrderInput | DishOrderUpdateManyWithWhereWithoutReturnedOrderInput[]
    deleteMany?: DishOrderScalarWhereInput | DishOrderScalarWhereInput[]
  }

  export type KitchenLogUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<KitchenLogCreateWithoutOrderInput, KitchenLogUncheckedCreateWithoutOrderInput> | KitchenLogCreateWithoutOrderInput[] | KitchenLogUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutOrderInput | KitchenLogCreateOrConnectWithoutOrderInput[]
    upsert?: KitchenLogUpsertWithWhereUniqueWithoutOrderInput | KitchenLogUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: KitchenLogCreateManyOrderInputEnvelope
    set?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    disconnect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    delete?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    update?: KitchenLogUpdateWithWhereUniqueWithoutOrderInput | KitchenLogUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: KitchenLogUpdateManyWithWhereWithoutOrderInput | KitchenLogUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
  }

  export type DiscountCreateNestedOneWithoutDiscountProductsInput = {
    create?: XOR<DiscountCreateWithoutDiscountProductsInput, DiscountUncheckedCreateWithoutDiscountProductsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutDiscountProductsInput
    connect?: DiscountWhereUniqueInput
  }

  export type EnumDiscountValueTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountValueType
  }

  export type DiscountUpdateOneRequiredWithoutDiscountProductsNestedInput = {
    create?: XOR<DiscountCreateWithoutDiscountProductsInput, DiscountUncheckedCreateWithoutDiscountProductsInput>
    connectOrCreate?: DiscountCreateOrConnectWithoutDiscountProductsInput
    upsert?: DiscountUpsertWithoutDiscountProductsInput
    connect?: DiscountWhereUniqueInput
    update?: XOR<XOR<DiscountUpdateToOneWithWhereWithoutDiscountProductsInput, DiscountUpdateWithoutDiscountProductsInput>, DiscountUncheckedUpdateWithoutDiscountProductsInput>
  }

  export type DiscountProductCreateNestedManyWithoutDiscountInput = {
    create?: XOR<DiscountProductCreateWithoutDiscountInput, DiscountProductUncheckedCreateWithoutDiscountInput> | DiscountProductCreateWithoutDiscountInput[] | DiscountProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: DiscountProductCreateOrConnectWithoutDiscountInput | DiscountProductCreateOrConnectWithoutDiscountInput[]
    createMany?: DiscountProductCreateManyDiscountInputEnvelope
    connect?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
  }

  export type OrderSessionCreateNestedOneWithoutDiscountsInput = {
    create?: XOR<OrderSessionCreateWithoutDiscountsInput, OrderSessionUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutDiscountsInput
    connect?: OrderSessionWhereUniqueInput
  }

  export type DiscountProductUncheckedCreateNestedManyWithoutDiscountInput = {
    create?: XOR<DiscountProductCreateWithoutDiscountInput, DiscountProductUncheckedCreateWithoutDiscountInput> | DiscountProductCreateWithoutDiscountInput[] | DiscountProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: DiscountProductCreateOrConnectWithoutDiscountInput | DiscountProductCreateOrConnectWithoutDiscountInput[]
    createMany?: DiscountProductCreateManyDiscountInputEnvelope
    connect?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
  }

  export type EnumDiscountTypeFieldUpdateOperationsInput = {
    set?: $Enums.DiscountType
  }

  export type DiscountProductUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<DiscountProductCreateWithoutDiscountInput, DiscountProductUncheckedCreateWithoutDiscountInput> | DiscountProductCreateWithoutDiscountInput[] | DiscountProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: DiscountProductCreateOrConnectWithoutDiscountInput | DiscountProductCreateOrConnectWithoutDiscountInput[]
    upsert?: DiscountProductUpsertWithWhereUniqueWithoutDiscountInput | DiscountProductUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: DiscountProductCreateManyDiscountInputEnvelope
    set?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    disconnect?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    delete?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    connect?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    update?: DiscountProductUpdateWithWhereUniqueWithoutDiscountInput | DiscountProductUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: DiscountProductUpdateManyWithWhereWithoutDiscountInput | DiscountProductUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: DiscountProductScalarWhereInput | DiscountProductScalarWhereInput[]
  }

  export type OrderSessionUpdateOneWithoutDiscountsNestedInput = {
    create?: XOR<OrderSessionCreateWithoutDiscountsInput, OrderSessionUncheckedCreateWithoutDiscountsInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutDiscountsInput
    upsert?: OrderSessionUpsertWithoutDiscountsInput
    disconnect?: OrderSessionWhereInput | boolean
    delete?: OrderSessionWhereInput | boolean
    connect?: OrderSessionWhereUniqueInput
    update?: XOR<XOR<OrderSessionUpdateToOneWithWhereWithoutDiscountsInput, OrderSessionUpdateWithoutDiscountsInput>, OrderSessionUncheckedUpdateWithoutDiscountsInput>
  }

  export type DiscountProductUncheckedUpdateManyWithoutDiscountNestedInput = {
    create?: XOR<DiscountProductCreateWithoutDiscountInput, DiscountProductUncheckedCreateWithoutDiscountInput> | DiscountProductCreateWithoutDiscountInput[] | DiscountProductUncheckedCreateWithoutDiscountInput[]
    connectOrCreate?: DiscountProductCreateOrConnectWithoutDiscountInput | DiscountProductCreateOrConnectWithoutDiscountInput[]
    upsert?: DiscountProductUpsertWithWhereUniqueWithoutDiscountInput | DiscountProductUpsertWithWhereUniqueWithoutDiscountInput[]
    createMany?: DiscountProductCreateManyDiscountInputEnvelope
    set?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    disconnect?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    delete?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    connect?: DiscountProductWhereUniqueInput | DiscountProductWhereUniqueInput[]
    update?: DiscountProductUpdateWithWhereUniqueWithoutDiscountInput | DiscountProductUpdateWithWhereUniqueWithoutDiscountInput[]
    updateMany?: DiscountProductUpdateManyWithWhereWithoutDiscountInput | DiscountProductUpdateManyWithWhereWithoutDiscountInput[]
    deleteMany?: DiscountProductScalarWhereInput | DiscountProductScalarWhereInput[]
  }

  export type OrderSessionCreateNestedOneWithoutTaxDetailsInput = {
    create?: XOR<OrderSessionCreateWithoutTaxDetailsInput, OrderSessionUncheckedCreateWithoutTaxDetailsInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutTaxDetailsInput
    connect?: OrderSessionWhereUniqueInput
  }

  export type OrderSessionUpdateOneRequiredWithoutTaxDetailsNestedInput = {
    create?: XOR<OrderSessionCreateWithoutTaxDetailsInput, OrderSessionUncheckedCreateWithoutTaxDetailsInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutTaxDetailsInput
    upsert?: OrderSessionUpsertWithoutTaxDetailsInput
    connect?: OrderSessionWhereUniqueInput
    update?: XOR<XOR<OrderSessionUpdateToOneWithWhereWithoutTaxDetailsInput, OrderSessionUpdateWithoutTaxDetailsInput>, OrderSessionUncheckedUpdateWithoutTaxDetailsInput>
  }

  export type OrderSessionCreateNestedOneWithoutPaymentDetailsInput = {
    create?: XOR<OrderSessionCreateWithoutPaymentDetailsInput, OrderSessionUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutPaymentDetailsInput
    connect?: OrderSessionWhereUniqueInput
  }

  export type EnumPaymentMethodEnumFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethodEnum
  }

  export type OrderSessionUpdateOneRequiredWithoutPaymentDetailsNestedInput = {
    create?: XOR<OrderSessionCreateWithoutPaymentDetailsInput, OrderSessionUncheckedCreateWithoutPaymentDetailsInput>
    connectOrCreate?: OrderSessionCreateOrConnectWithoutPaymentDetailsInput
    upsert?: OrderSessionUpsertWithoutPaymentDetailsInput
    connect?: OrderSessionWhereUniqueInput
    update?: XOR<XOR<OrderSessionUpdateToOneWithWhereWithoutPaymentDetailsInput, OrderSessionUpdateWithoutPaymentDetailsInput>, OrderSessionUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type OrderSessionCreatetableIdsInput = {
    set: string[]
  }

  export type OrderSessionCreatetableNamesInput = {
    set: string[]
  }

  export type OrderCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<OrderCreateWithoutOrderSessionInput, OrderUncheckedCreateWithoutOrderSessionInput> | OrderCreateWithoutOrderSessionInput[] | OrderUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderSessionInput | OrderCreateOrConnectWithoutOrderSessionInput[]
    createMany?: OrderCreateManyOrderSessionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DiscountCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<DiscountCreateWithoutOrderSessionInput, DiscountUncheckedCreateWithoutOrderSessionInput> | DiscountCreateWithoutOrderSessionInput[] | DiscountUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderSessionInput | DiscountCreateOrConnectWithoutOrderSessionInput[]
    createMany?: DiscountCreateManyOrderSessionInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutOrderSessionInput = {
    create?: XOR<ShopCreateWithoutOrderSessionInput, ShopUncheckedCreateWithoutOrderSessionInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrderSessionInput
    connect?: ShopWhereUniqueInput
  }

  export type TaxDetailCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<TaxDetailCreateWithoutOrderSessionInput, TaxDetailUncheckedCreateWithoutOrderSessionInput> | TaxDetailCreateWithoutOrderSessionInput[] | TaxDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: TaxDetailCreateOrConnectWithoutOrderSessionInput | TaxDetailCreateOrConnectWithoutOrderSessionInput[]
    createMany?: TaxDetailCreateManyOrderSessionInputEnvelope
    connect?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
  }

  export type PaymentDetailCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<PaymentDetailCreateWithoutOrderSessionInput, PaymentDetailUncheckedCreateWithoutOrderSessionInput> | PaymentDetailCreateWithoutOrderSessionInput[] | PaymentDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: PaymentDetailCreateOrConnectWithoutOrderSessionInput | PaymentDetailCreateOrConnectWithoutOrderSessionInput[]
    createMany?: PaymentDetailCreateManyOrderSessionInputEnvelope
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<OrderCreateWithoutOrderSessionInput, OrderUncheckedCreateWithoutOrderSessionInput> | OrderCreateWithoutOrderSessionInput[] | OrderUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderSessionInput | OrderCreateOrConnectWithoutOrderSessionInput[]
    createMany?: OrderCreateManyOrderSessionInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type DiscountUncheckedCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<DiscountCreateWithoutOrderSessionInput, DiscountUncheckedCreateWithoutOrderSessionInput> | DiscountCreateWithoutOrderSessionInput[] | DiscountUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderSessionInput | DiscountCreateOrConnectWithoutOrderSessionInput[]
    createMany?: DiscountCreateManyOrderSessionInputEnvelope
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
  }

  export type TaxDetailUncheckedCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<TaxDetailCreateWithoutOrderSessionInput, TaxDetailUncheckedCreateWithoutOrderSessionInput> | TaxDetailCreateWithoutOrderSessionInput[] | TaxDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: TaxDetailCreateOrConnectWithoutOrderSessionInput | TaxDetailCreateOrConnectWithoutOrderSessionInput[]
    createMany?: TaxDetailCreateManyOrderSessionInputEnvelope
    connect?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
  }

  export type PaymentDetailUncheckedCreateNestedManyWithoutOrderSessionInput = {
    create?: XOR<PaymentDetailCreateWithoutOrderSessionInput, PaymentDetailUncheckedCreateWithoutOrderSessionInput> | PaymentDetailCreateWithoutOrderSessionInput[] | PaymentDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: PaymentDetailCreateOrConnectWithoutOrderSessionInput | PaymentDetailCreateOrConnectWithoutOrderSessionInput[]
    createMany?: PaymentDetailCreateManyOrderSessionInputEnvelope
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
  }

  export type OrderSessionUpdatetableIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrderSessionUpdatetableNamesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type OrderUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<OrderCreateWithoutOrderSessionInput, OrderUncheckedCreateWithoutOrderSessionInput> | OrderCreateWithoutOrderSessionInput[] | OrderUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderSessionInput | OrderCreateOrConnectWithoutOrderSessionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderSessionInput | OrderUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: OrderCreateManyOrderSessionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderSessionInput | OrderUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderSessionInput | OrderUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DiscountUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<DiscountCreateWithoutOrderSessionInput, DiscountUncheckedCreateWithoutOrderSessionInput> | DiscountCreateWithoutOrderSessionInput[] | DiscountUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderSessionInput | DiscountCreateOrConnectWithoutOrderSessionInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutOrderSessionInput | DiscountUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: DiscountCreateManyOrderSessionInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutOrderSessionInput | DiscountUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutOrderSessionInput | DiscountUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type ShopUpdateOneRequiredWithoutOrderSessionNestedInput = {
    create?: XOR<ShopCreateWithoutOrderSessionInput, ShopUncheckedCreateWithoutOrderSessionInput>
    connectOrCreate?: ShopCreateOrConnectWithoutOrderSessionInput
    upsert?: ShopUpsertWithoutOrderSessionInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutOrderSessionInput, ShopUpdateWithoutOrderSessionInput>, ShopUncheckedUpdateWithoutOrderSessionInput>
  }

  export type TaxDetailUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<TaxDetailCreateWithoutOrderSessionInput, TaxDetailUncheckedCreateWithoutOrderSessionInput> | TaxDetailCreateWithoutOrderSessionInput[] | TaxDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: TaxDetailCreateOrConnectWithoutOrderSessionInput | TaxDetailCreateOrConnectWithoutOrderSessionInput[]
    upsert?: TaxDetailUpsertWithWhereUniqueWithoutOrderSessionInput | TaxDetailUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: TaxDetailCreateManyOrderSessionInputEnvelope
    set?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    disconnect?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    delete?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    connect?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    update?: TaxDetailUpdateWithWhereUniqueWithoutOrderSessionInput | TaxDetailUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: TaxDetailUpdateManyWithWhereWithoutOrderSessionInput | TaxDetailUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: TaxDetailScalarWhereInput | TaxDetailScalarWhereInput[]
  }

  export type PaymentDetailUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<PaymentDetailCreateWithoutOrderSessionInput, PaymentDetailUncheckedCreateWithoutOrderSessionInput> | PaymentDetailCreateWithoutOrderSessionInput[] | PaymentDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: PaymentDetailCreateOrConnectWithoutOrderSessionInput | PaymentDetailCreateOrConnectWithoutOrderSessionInput[]
    upsert?: PaymentDetailUpsertWithWhereUniqueWithoutOrderSessionInput | PaymentDetailUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: PaymentDetailCreateManyOrderSessionInputEnvelope
    set?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    disconnect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    delete?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    update?: PaymentDetailUpdateWithWhereUniqueWithoutOrderSessionInput | PaymentDetailUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: PaymentDetailUpdateManyWithWhereWithoutOrderSessionInput | PaymentDetailUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: PaymentDetailScalarWhereInput | PaymentDetailScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<OrderCreateWithoutOrderSessionInput, OrderUncheckedCreateWithoutOrderSessionInput> | OrderCreateWithoutOrderSessionInput[] | OrderUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutOrderSessionInput | OrderCreateOrConnectWithoutOrderSessionInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutOrderSessionInput | OrderUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: OrderCreateManyOrderSessionInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutOrderSessionInput | OrderUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutOrderSessionInput | OrderUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type DiscountUncheckedUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<DiscountCreateWithoutOrderSessionInput, DiscountUncheckedCreateWithoutOrderSessionInput> | DiscountCreateWithoutOrderSessionInput[] | DiscountUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: DiscountCreateOrConnectWithoutOrderSessionInput | DiscountCreateOrConnectWithoutOrderSessionInput[]
    upsert?: DiscountUpsertWithWhereUniqueWithoutOrderSessionInput | DiscountUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: DiscountCreateManyOrderSessionInputEnvelope
    set?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    disconnect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    delete?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    connect?: DiscountWhereUniqueInput | DiscountWhereUniqueInput[]
    update?: DiscountUpdateWithWhereUniqueWithoutOrderSessionInput | DiscountUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: DiscountUpdateManyWithWhereWithoutOrderSessionInput | DiscountUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
  }

  export type TaxDetailUncheckedUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<TaxDetailCreateWithoutOrderSessionInput, TaxDetailUncheckedCreateWithoutOrderSessionInput> | TaxDetailCreateWithoutOrderSessionInput[] | TaxDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: TaxDetailCreateOrConnectWithoutOrderSessionInput | TaxDetailCreateOrConnectWithoutOrderSessionInput[]
    upsert?: TaxDetailUpsertWithWhereUniqueWithoutOrderSessionInput | TaxDetailUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: TaxDetailCreateManyOrderSessionInputEnvelope
    set?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    disconnect?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    delete?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    connect?: TaxDetailWhereUniqueInput | TaxDetailWhereUniqueInput[]
    update?: TaxDetailUpdateWithWhereUniqueWithoutOrderSessionInput | TaxDetailUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: TaxDetailUpdateManyWithWhereWithoutOrderSessionInput | TaxDetailUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: TaxDetailScalarWhereInput | TaxDetailScalarWhereInput[]
  }

  export type PaymentDetailUncheckedUpdateManyWithoutOrderSessionNestedInput = {
    create?: XOR<PaymentDetailCreateWithoutOrderSessionInput, PaymentDetailUncheckedCreateWithoutOrderSessionInput> | PaymentDetailCreateWithoutOrderSessionInput[] | PaymentDetailUncheckedCreateWithoutOrderSessionInput[]
    connectOrCreate?: PaymentDetailCreateOrConnectWithoutOrderSessionInput | PaymentDetailCreateOrConnectWithoutOrderSessionInput[]
    upsert?: PaymentDetailUpsertWithWhereUniqueWithoutOrderSessionInput | PaymentDetailUpsertWithWhereUniqueWithoutOrderSessionInput[]
    createMany?: PaymentDetailCreateManyOrderSessionInputEnvelope
    set?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    disconnect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    delete?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    connect?: PaymentDetailWhereUniqueInput | PaymentDetailWhereUniqueInput[]
    update?: PaymentDetailUpdateWithWhereUniqueWithoutOrderSessionInput | PaymentDetailUpdateWithWhereUniqueWithoutOrderSessionInput[]
    updateMany?: PaymentDetailUpdateManyWithWhereWithoutOrderSessionInput | PaymentDetailUpdateManyWithWhereWithoutOrderSessionInput[]
    deleteMany?: PaymentDetailScalarWhereInput | PaymentDetailScalarWhereInput[]
  }

  export type DishCreateNestedManyWithoutShopInput = {
    create?: XOR<DishCreateWithoutShopInput, DishUncheckedCreateWithoutShopInput> | DishCreateWithoutShopInput[] | DishUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCreateOrConnectWithoutShopInput | DishCreateOrConnectWithoutShopInput[]
    createMany?: DishCreateManyShopInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type DishCategoryCreateNestedManyWithoutShopInput = {
    create?: XOR<DishCategoryCreateWithoutShopInput, DishCategoryUncheckedCreateWithoutShopInput> | DishCategoryCreateWithoutShopInput[] | DishCategoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutShopInput | DishCategoryCreateOrConnectWithoutShopInput[]
    createMany?: DishCategoryCreateManyShopInputEnvelope
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
  }

  export type EmployeeCreateNestedManyWithoutShopInput = {
    create?: XOR<EmployeeCreateWithoutShopInput, EmployeeUncheckedCreateWithoutShopInput> | EmployeeCreateWithoutShopInput[] | EmployeeUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShopInput | EmployeeCreateOrConnectWithoutShopInput[]
    createMany?: EmployeeCreateManyShopInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeDepartmentCreateNestedManyWithoutShopInput = {
    create?: XOR<EmployeeDepartmentCreateWithoutShopInput, EmployeeDepartmentUncheckedCreateWithoutShopInput> | EmployeeDepartmentCreateWithoutShopInput[] | EmployeeDepartmentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeDepartmentCreateOrConnectWithoutShopInput | EmployeeDepartmentCreateOrConnectWithoutShopInput[]
    createMany?: EmployeeDepartmentCreateManyShopInputEnvelope
    connect?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
  }

  export type EmployeePositionCreateNestedManyWithoutShopInput = {
    create?: XOR<EmployeePositionCreateWithoutShopInput, EmployeePositionUncheckedCreateWithoutShopInput> | EmployeePositionCreateWithoutShopInput[] | EmployeePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeePositionCreateOrConnectWithoutShopInput | EmployeePositionCreateOrConnectWithoutShopInput[]
    createMany?: EmployeePositionCreateManyShopInputEnvelope
    connect?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
  }

  export type ImageCreateNestedManyWithoutShopInput = {
    create?: XOR<ImageCreateWithoutShopInput, ImageUncheckedCreateWithoutShopInput> | ImageCreateWithoutShopInput[] | ImageUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutShopInput | ImageCreateOrConnectWithoutShopInput[]
    createMany?: ImageCreateManyShopInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutShopInput = {
    create?: XOR<UserCreateWithoutShopInput, UserUncheckedCreateWithoutShopInput>
    connectOrCreate?: UserCreateOrConnectWithoutShopInput
    connect?: UserWhereUniqueInput
  }

  export type TableCreateNestedManyWithoutShopInput = {
    create?: XOR<TableCreateWithoutShopInput, TableUncheckedCreateWithoutShopInput> | TableCreateWithoutShopInput[] | TableUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TableCreateOrConnectWithoutShopInput | TableCreateOrConnectWithoutShopInput[]
    createMany?: TableCreateManyShopInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TablePositionCreateNestedManyWithoutShopInput = {
    create?: XOR<TablePositionCreateWithoutShopInput, TablePositionUncheckedCreateWithoutShopInput> | TablePositionCreateWithoutShopInput[] | TablePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutShopInput | TablePositionCreateOrConnectWithoutShopInput[]
    createMany?: TablePositionCreateManyShopInputEnvelope
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
  }

  export type UnitCreateNestedManyWithoutShopInput = {
    create?: XOR<UnitCreateWithoutShopInput, UnitUncheckedCreateWithoutShopInput> | UnitCreateWithoutShopInput[] | UnitUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutShopInput | UnitCreateOrConnectWithoutShopInput[]
    createMany?: UnitCreateManyShopInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type KitchenCreateNestedManyWithoutShopInput = {
    create?: XOR<KitchenCreateWithoutShopInput, KitchenUncheckedCreateWithoutShopInput> | KitchenCreateWithoutShopInput[] | KitchenUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutShopInput | KitchenCreateOrConnectWithoutShopInput[]
    createMany?: KitchenCreateManyShopInputEnvelope
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
  }

  export type KitchenLogCreateNestedManyWithoutShopInput = {
    create?: XOR<KitchenLogCreateWithoutShopInput, KitchenLogUncheckedCreateWithoutShopInput> | KitchenLogCreateWithoutShopInput[] | KitchenLogUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutShopInput | KitchenLogCreateOrConnectWithoutShopInput[]
    createMany?: KitchenLogCreateManyShopInputEnvelope
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
  }

  export type OrderCreateNestedManyWithoutShopInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderSessionCreateNestedManyWithoutShopInput = {
    create?: XOR<OrderSessionCreateWithoutShopInput, OrderSessionUncheckedCreateWithoutShopInput> | OrderSessionCreateWithoutShopInput[] | OrderSessionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderSessionCreateOrConnectWithoutShopInput | OrderSessionCreateOrConnectWithoutShopInput[]
    createMany?: OrderSessionCreateManyShopInputEnvelope
    connect?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<DishCreateWithoutShopInput, DishUncheckedCreateWithoutShopInput> | DishCreateWithoutShopInput[] | DishUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCreateOrConnectWithoutShopInput | DishCreateOrConnectWithoutShopInput[]
    createMany?: DishCreateManyShopInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type DishCategoryUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<DishCategoryCreateWithoutShopInput, DishCategoryUncheckedCreateWithoutShopInput> | DishCategoryCreateWithoutShopInput[] | DishCategoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutShopInput | DishCategoryCreateOrConnectWithoutShopInput[]
    createMany?: DishCategoryCreateManyShopInputEnvelope
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<EmployeeCreateWithoutShopInput, EmployeeUncheckedCreateWithoutShopInput> | EmployeeCreateWithoutShopInput[] | EmployeeUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShopInput | EmployeeCreateOrConnectWithoutShopInput[]
    createMany?: EmployeeCreateManyShopInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<EmployeeDepartmentCreateWithoutShopInput, EmployeeDepartmentUncheckedCreateWithoutShopInput> | EmployeeDepartmentCreateWithoutShopInput[] | EmployeeDepartmentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeDepartmentCreateOrConnectWithoutShopInput | EmployeeDepartmentCreateOrConnectWithoutShopInput[]
    createMany?: EmployeeDepartmentCreateManyShopInputEnvelope
    connect?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
  }

  export type EmployeePositionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<EmployeePositionCreateWithoutShopInput, EmployeePositionUncheckedCreateWithoutShopInput> | EmployeePositionCreateWithoutShopInput[] | EmployeePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeePositionCreateOrConnectWithoutShopInput | EmployeePositionCreateOrConnectWithoutShopInput[]
    createMany?: EmployeePositionCreateManyShopInputEnvelope
    connect?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<ImageCreateWithoutShopInput, ImageUncheckedCreateWithoutShopInput> | ImageCreateWithoutShopInput[] | ImageUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutShopInput | ImageCreateOrConnectWithoutShopInput[]
    createMany?: ImageCreateManyShopInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<TableCreateWithoutShopInput, TableUncheckedCreateWithoutShopInput> | TableCreateWithoutShopInput[] | TableUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TableCreateOrConnectWithoutShopInput | TableCreateOrConnectWithoutShopInput[]
    createMany?: TableCreateManyShopInputEnvelope
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TablePositionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<TablePositionCreateWithoutShopInput, TablePositionUncheckedCreateWithoutShopInput> | TablePositionCreateWithoutShopInput[] | TablePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutShopInput | TablePositionCreateOrConnectWithoutShopInput[]
    createMany?: TablePositionCreateManyShopInputEnvelope
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
  }

  export type UnitUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<UnitCreateWithoutShopInput, UnitUncheckedCreateWithoutShopInput> | UnitCreateWithoutShopInput[] | UnitUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutShopInput | UnitCreateOrConnectWithoutShopInput[]
    createMany?: UnitCreateManyShopInputEnvelope
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
  }

  export type KitchenUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<KitchenCreateWithoutShopInput, KitchenUncheckedCreateWithoutShopInput> | KitchenCreateWithoutShopInput[] | KitchenUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutShopInput | KitchenCreateOrConnectWithoutShopInput[]
    createMany?: KitchenCreateManyShopInputEnvelope
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
  }

  export type KitchenLogUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<KitchenLogCreateWithoutShopInput, KitchenLogUncheckedCreateWithoutShopInput> | KitchenLogCreateWithoutShopInput[] | KitchenLogUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutShopInput | KitchenLogCreateOrConnectWithoutShopInput[]
    createMany?: KitchenLogCreateManyShopInputEnvelope
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type OrderSessionUncheckedCreateNestedManyWithoutShopInput = {
    create?: XOR<OrderSessionCreateWithoutShopInput, OrderSessionUncheckedCreateWithoutShopInput> | OrderSessionCreateWithoutShopInput[] | OrderSessionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderSessionCreateOrConnectWithoutShopInput | OrderSessionCreateOrConnectWithoutShopInput[]
    createMany?: OrderSessionCreateManyShopInputEnvelope
    connect?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
  }

  export type EnumRoundingPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoundingPaymentType
  }

  export type DishUpdateManyWithoutShopNestedInput = {
    create?: XOR<DishCreateWithoutShopInput, DishUncheckedCreateWithoutShopInput> | DishCreateWithoutShopInput[] | DishUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCreateOrConnectWithoutShopInput | DishCreateOrConnectWithoutShopInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutShopInput | DishUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: DishCreateManyShopInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutShopInput | DishUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: DishUpdateManyWithWhereWithoutShopInput | DishUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type DishCategoryUpdateManyWithoutShopNestedInput = {
    create?: XOR<DishCategoryCreateWithoutShopInput, DishCategoryUncheckedCreateWithoutShopInput> | DishCategoryCreateWithoutShopInput[] | DishCategoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutShopInput | DishCategoryCreateOrConnectWithoutShopInput[]
    upsert?: DishCategoryUpsertWithWhereUniqueWithoutShopInput | DishCategoryUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: DishCategoryCreateManyShopInputEnvelope
    set?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    disconnect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    delete?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    update?: DishCategoryUpdateWithWhereUniqueWithoutShopInput | DishCategoryUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: DishCategoryUpdateManyWithWhereWithoutShopInput | DishCategoryUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
  }

  export type EmployeeUpdateManyWithoutShopNestedInput = {
    create?: XOR<EmployeeCreateWithoutShopInput, EmployeeUncheckedCreateWithoutShopInput> | EmployeeCreateWithoutShopInput[] | EmployeeUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShopInput | EmployeeCreateOrConnectWithoutShopInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShopInput | EmployeeUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: EmployeeCreateManyShopInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShopInput | EmployeeUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShopInput | EmployeeUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeDepartmentUpdateManyWithoutShopNestedInput = {
    create?: XOR<EmployeeDepartmentCreateWithoutShopInput, EmployeeDepartmentUncheckedCreateWithoutShopInput> | EmployeeDepartmentCreateWithoutShopInput[] | EmployeeDepartmentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeDepartmentCreateOrConnectWithoutShopInput | EmployeeDepartmentCreateOrConnectWithoutShopInput[]
    upsert?: EmployeeDepartmentUpsertWithWhereUniqueWithoutShopInput | EmployeeDepartmentUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: EmployeeDepartmentCreateManyShopInputEnvelope
    set?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    disconnect?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    delete?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    connect?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    update?: EmployeeDepartmentUpdateWithWhereUniqueWithoutShopInput | EmployeeDepartmentUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: EmployeeDepartmentUpdateManyWithWhereWithoutShopInput | EmployeeDepartmentUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: EmployeeDepartmentScalarWhereInput | EmployeeDepartmentScalarWhereInput[]
  }

  export type EmployeePositionUpdateManyWithoutShopNestedInput = {
    create?: XOR<EmployeePositionCreateWithoutShopInput, EmployeePositionUncheckedCreateWithoutShopInput> | EmployeePositionCreateWithoutShopInput[] | EmployeePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeePositionCreateOrConnectWithoutShopInput | EmployeePositionCreateOrConnectWithoutShopInput[]
    upsert?: EmployeePositionUpsertWithWhereUniqueWithoutShopInput | EmployeePositionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: EmployeePositionCreateManyShopInputEnvelope
    set?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    disconnect?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    delete?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    connect?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    update?: EmployeePositionUpdateWithWhereUniqueWithoutShopInput | EmployeePositionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: EmployeePositionUpdateManyWithWhereWithoutShopInput | EmployeePositionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: EmployeePositionScalarWhereInput | EmployeePositionScalarWhereInput[]
  }

  export type ImageUpdateManyWithoutShopNestedInput = {
    create?: XOR<ImageCreateWithoutShopInput, ImageUncheckedCreateWithoutShopInput> | ImageCreateWithoutShopInput[] | ImageUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutShopInput | ImageCreateOrConnectWithoutShopInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutShopInput | ImageUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ImageCreateManyShopInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutShopInput | ImageUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutShopInput | ImageUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type UserUpdateOneWithoutShopNestedInput = {
    create?: XOR<UserCreateWithoutShopInput, UserUncheckedCreateWithoutShopInput>
    connectOrCreate?: UserCreateOrConnectWithoutShopInput
    upsert?: UserUpsertWithoutShopInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShopInput, UserUpdateWithoutShopInput>, UserUncheckedUpdateWithoutShopInput>
  }

  export type TableUpdateManyWithoutShopNestedInput = {
    create?: XOR<TableCreateWithoutShopInput, TableUncheckedCreateWithoutShopInput> | TableCreateWithoutShopInput[] | TableUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TableCreateOrConnectWithoutShopInput | TableCreateOrConnectWithoutShopInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutShopInput | TableUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: TableCreateManyShopInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutShopInput | TableUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: TableUpdateManyWithWhereWithoutShopInput | TableUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TablePositionUpdateManyWithoutShopNestedInput = {
    create?: XOR<TablePositionCreateWithoutShopInput, TablePositionUncheckedCreateWithoutShopInput> | TablePositionCreateWithoutShopInput[] | TablePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutShopInput | TablePositionCreateOrConnectWithoutShopInput[]
    upsert?: TablePositionUpsertWithWhereUniqueWithoutShopInput | TablePositionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: TablePositionCreateManyShopInputEnvelope
    set?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    disconnect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    delete?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    update?: TablePositionUpdateWithWhereUniqueWithoutShopInput | TablePositionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: TablePositionUpdateManyWithWhereWithoutShopInput | TablePositionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
  }

  export type UnitUpdateManyWithoutShopNestedInput = {
    create?: XOR<UnitCreateWithoutShopInput, UnitUncheckedCreateWithoutShopInput> | UnitCreateWithoutShopInput[] | UnitUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutShopInput | UnitCreateOrConnectWithoutShopInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutShopInput | UnitUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: UnitCreateManyShopInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutShopInput | UnitUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutShopInput | UnitUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type KitchenUpdateManyWithoutShopNestedInput = {
    create?: XOR<KitchenCreateWithoutShopInput, KitchenUncheckedCreateWithoutShopInput> | KitchenCreateWithoutShopInput[] | KitchenUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutShopInput | KitchenCreateOrConnectWithoutShopInput[]
    upsert?: KitchenUpsertWithWhereUniqueWithoutShopInput | KitchenUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: KitchenCreateManyShopInputEnvelope
    set?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    disconnect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    delete?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    update?: KitchenUpdateWithWhereUniqueWithoutShopInput | KitchenUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: KitchenUpdateManyWithWhereWithoutShopInput | KitchenUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: KitchenScalarWhereInput | KitchenScalarWhereInput[]
  }

  export type KitchenLogUpdateManyWithoutShopNestedInput = {
    create?: XOR<KitchenLogCreateWithoutShopInput, KitchenLogUncheckedCreateWithoutShopInput> | KitchenLogCreateWithoutShopInput[] | KitchenLogUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutShopInput | KitchenLogCreateOrConnectWithoutShopInput[]
    upsert?: KitchenLogUpsertWithWhereUniqueWithoutShopInput | KitchenLogUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: KitchenLogCreateManyShopInputEnvelope
    set?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    disconnect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    delete?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    update?: KitchenLogUpdateWithWhereUniqueWithoutShopInput | KitchenLogUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: KitchenLogUpdateManyWithWhereWithoutShopInput | KitchenLogUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
  }

  export type OrderUpdateManyWithoutShopNestedInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutShopInput | OrderUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutShopInput | OrderUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutShopInput | OrderUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderSessionUpdateManyWithoutShopNestedInput = {
    create?: XOR<OrderSessionCreateWithoutShopInput, OrderSessionUncheckedCreateWithoutShopInput> | OrderSessionCreateWithoutShopInput[] | OrderSessionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderSessionCreateOrConnectWithoutShopInput | OrderSessionCreateOrConnectWithoutShopInput[]
    upsert?: OrderSessionUpsertWithWhereUniqueWithoutShopInput | OrderSessionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OrderSessionCreateManyShopInputEnvelope
    set?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    disconnect?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    delete?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    connect?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    update?: OrderSessionUpdateWithWhereUniqueWithoutShopInput | OrderSessionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OrderSessionUpdateManyWithWhereWithoutShopInput | OrderSessionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OrderSessionScalarWhereInput | OrderSessionScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<DishCreateWithoutShopInput, DishUncheckedCreateWithoutShopInput> | DishCreateWithoutShopInput[] | DishUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCreateOrConnectWithoutShopInput | DishCreateOrConnectWithoutShopInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutShopInput | DishUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: DishCreateManyShopInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutShopInput | DishUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: DishUpdateManyWithWhereWithoutShopInput | DishUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type DishCategoryUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<DishCategoryCreateWithoutShopInput, DishCategoryUncheckedCreateWithoutShopInput> | DishCategoryCreateWithoutShopInput[] | DishCategoryUncheckedCreateWithoutShopInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutShopInput | DishCategoryCreateOrConnectWithoutShopInput[]
    upsert?: DishCategoryUpsertWithWhereUniqueWithoutShopInput | DishCategoryUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: DishCategoryCreateManyShopInputEnvelope
    set?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    disconnect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    delete?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    update?: DishCategoryUpdateWithWhereUniqueWithoutShopInput | DishCategoryUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: DishCategoryUpdateManyWithWhereWithoutShopInput | DishCategoryUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<EmployeeCreateWithoutShopInput, EmployeeUncheckedCreateWithoutShopInput> | EmployeeCreateWithoutShopInput[] | EmployeeUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShopInput | EmployeeCreateOrConnectWithoutShopInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShopInput | EmployeeUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: EmployeeCreateManyShopInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShopInput | EmployeeUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShopInput | EmployeeUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<EmployeeDepartmentCreateWithoutShopInput, EmployeeDepartmentUncheckedCreateWithoutShopInput> | EmployeeDepartmentCreateWithoutShopInput[] | EmployeeDepartmentUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeeDepartmentCreateOrConnectWithoutShopInput | EmployeeDepartmentCreateOrConnectWithoutShopInput[]
    upsert?: EmployeeDepartmentUpsertWithWhereUniqueWithoutShopInput | EmployeeDepartmentUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: EmployeeDepartmentCreateManyShopInputEnvelope
    set?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    disconnect?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    delete?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    connect?: EmployeeDepartmentWhereUniqueInput | EmployeeDepartmentWhereUniqueInput[]
    update?: EmployeeDepartmentUpdateWithWhereUniqueWithoutShopInput | EmployeeDepartmentUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: EmployeeDepartmentUpdateManyWithWhereWithoutShopInput | EmployeeDepartmentUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: EmployeeDepartmentScalarWhereInput | EmployeeDepartmentScalarWhereInput[]
  }

  export type EmployeePositionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<EmployeePositionCreateWithoutShopInput, EmployeePositionUncheckedCreateWithoutShopInput> | EmployeePositionCreateWithoutShopInput[] | EmployeePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: EmployeePositionCreateOrConnectWithoutShopInput | EmployeePositionCreateOrConnectWithoutShopInput[]
    upsert?: EmployeePositionUpsertWithWhereUniqueWithoutShopInput | EmployeePositionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: EmployeePositionCreateManyShopInputEnvelope
    set?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    disconnect?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    delete?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    connect?: EmployeePositionWhereUniqueInput | EmployeePositionWhereUniqueInput[]
    update?: EmployeePositionUpdateWithWhereUniqueWithoutShopInput | EmployeePositionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: EmployeePositionUpdateManyWithWhereWithoutShopInput | EmployeePositionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: EmployeePositionScalarWhereInput | EmployeePositionScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<ImageCreateWithoutShopInput, ImageUncheckedCreateWithoutShopInput> | ImageCreateWithoutShopInput[] | ImageUncheckedCreateWithoutShopInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutShopInput | ImageCreateOrConnectWithoutShopInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutShopInput | ImageUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: ImageCreateManyShopInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutShopInput | ImageUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutShopInput | ImageUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<TableCreateWithoutShopInput, TableUncheckedCreateWithoutShopInput> | TableCreateWithoutShopInput[] | TableUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TableCreateOrConnectWithoutShopInput | TableCreateOrConnectWithoutShopInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutShopInput | TableUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: TableCreateManyShopInputEnvelope
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutShopInput | TableUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: TableUpdateManyWithWhereWithoutShopInput | TableUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type TablePositionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<TablePositionCreateWithoutShopInput, TablePositionUncheckedCreateWithoutShopInput> | TablePositionCreateWithoutShopInput[] | TablePositionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutShopInput | TablePositionCreateOrConnectWithoutShopInput[]
    upsert?: TablePositionUpsertWithWhereUniqueWithoutShopInput | TablePositionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: TablePositionCreateManyShopInputEnvelope
    set?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    disconnect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    delete?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    update?: TablePositionUpdateWithWhereUniqueWithoutShopInput | TablePositionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: TablePositionUpdateManyWithWhereWithoutShopInput | TablePositionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
  }

  export type UnitUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<UnitCreateWithoutShopInput, UnitUncheckedCreateWithoutShopInput> | UnitCreateWithoutShopInput[] | UnitUncheckedCreateWithoutShopInput[]
    connectOrCreate?: UnitCreateOrConnectWithoutShopInput | UnitCreateOrConnectWithoutShopInput[]
    upsert?: UnitUpsertWithWhereUniqueWithoutShopInput | UnitUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: UnitCreateManyShopInputEnvelope
    set?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    disconnect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    delete?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    connect?: UnitWhereUniqueInput | UnitWhereUniqueInput[]
    update?: UnitUpdateWithWhereUniqueWithoutShopInput | UnitUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: UnitUpdateManyWithWhereWithoutShopInput | UnitUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: UnitScalarWhereInput | UnitScalarWhereInput[]
  }

  export type KitchenUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<KitchenCreateWithoutShopInput, KitchenUncheckedCreateWithoutShopInput> | KitchenCreateWithoutShopInput[] | KitchenUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutShopInput | KitchenCreateOrConnectWithoutShopInput[]
    upsert?: KitchenUpsertWithWhereUniqueWithoutShopInput | KitchenUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: KitchenCreateManyShopInputEnvelope
    set?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    disconnect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    delete?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    update?: KitchenUpdateWithWhereUniqueWithoutShopInput | KitchenUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: KitchenUpdateManyWithWhereWithoutShopInput | KitchenUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: KitchenScalarWhereInput | KitchenScalarWhereInput[]
  }

  export type KitchenLogUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<KitchenLogCreateWithoutShopInput, KitchenLogUncheckedCreateWithoutShopInput> | KitchenLogCreateWithoutShopInput[] | KitchenLogUncheckedCreateWithoutShopInput[]
    connectOrCreate?: KitchenLogCreateOrConnectWithoutShopInput | KitchenLogCreateOrConnectWithoutShopInput[]
    upsert?: KitchenLogUpsertWithWhereUniqueWithoutShopInput | KitchenLogUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: KitchenLogCreateManyShopInputEnvelope
    set?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    disconnect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    delete?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    connect?: KitchenLogWhereUniqueInput | KitchenLogWhereUniqueInput[]
    update?: KitchenLogUpdateWithWhereUniqueWithoutShopInput | KitchenLogUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: KitchenLogUpdateManyWithWhereWithoutShopInput | KitchenLogUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput> | OrderCreateWithoutShopInput[] | OrderUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutShopInput | OrderCreateOrConnectWithoutShopInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutShopInput | OrderUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OrderCreateManyShopInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutShopInput | OrderUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutShopInput | OrderUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type OrderSessionUncheckedUpdateManyWithoutShopNestedInput = {
    create?: XOR<OrderSessionCreateWithoutShopInput, OrderSessionUncheckedCreateWithoutShopInput> | OrderSessionCreateWithoutShopInput[] | OrderSessionUncheckedCreateWithoutShopInput[]
    connectOrCreate?: OrderSessionCreateOrConnectWithoutShopInput | OrderSessionCreateOrConnectWithoutShopInput[]
    upsert?: OrderSessionUpsertWithWhereUniqueWithoutShopInput | OrderSessionUpsertWithWhereUniqueWithoutShopInput[]
    createMany?: OrderSessionCreateManyShopInputEnvelope
    set?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    disconnect?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    delete?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    connect?: OrderSessionWhereUniqueInput | OrderSessionWhereUniqueInput[]
    update?: OrderSessionUpdateWithWhereUniqueWithoutShopInput | OrderSessionUpdateWithWhereUniqueWithoutShopInput[]
    updateMany?: OrderSessionUpdateManyWithWhereWithoutShopInput | OrderSessionUpdateManyWithWhereWithoutShopInput[]
    deleteMany?: OrderSessionScalarWhereInput | OrderSessionScalarWhereInput[]
  }

  export type DishCreateNestedOneWithoutImageUrlsInput = {
    create?: XOR<DishCreateWithoutImageUrlsInput, DishUncheckedCreateWithoutImageUrlsInput>
    connectOrCreate?: DishCreateOrConnectWithoutImageUrlsInput
    connect?: DishWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutImageUrlsInput = {
    create?: XOR<ShopCreateWithoutImageUrlsInput, ShopUncheckedCreateWithoutImageUrlsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutImageUrlsInput
    connect?: ShopWhereUniqueInput
  }

  export type DishUpdateOneWithoutImageUrlsNestedInput = {
    create?: XOR<DishCreateWithoutImageUrlsInput, DishUncheckedCreateWithoutImageUrlsInput>
    connectOrCreate?: DishCreateOrConnectWithoutImageUrlsInput
    upsert?: DishUpsertWithoutImageUrlsInput
    disconnect?: DishWhereInput | boolean
    delete?: DishWhereInput | boolean
    connect?: DishWhereUniqueInput
    update?: XOR<XOR<DishUpdateToOneWithWhereWithoutImageUrlsInput, DishUpdateWithoutImageUrlsInput>, DishUncheckedUpdateWithoutImageUrlsInput>
  }

  export type ShopUpdateOneWithoutImageUrlsNestedInput = {
    create?: XOR<ShopCreateWithoutImageUrlsInput, ShopUncheckedCreateWithoutImageUrlsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutImageUrlsInput
    upsert?: ShopUpsertWithoutImageUrlsInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutImageUrlsInput, ShopUpdateWithoutImageUrlsInput>, ShopUncheckedUpdateWithoutImageUrlsInput>
  }

  export type DishCreateNestedManyWithoutCategoryInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutDishCategoryInput = {
    create?: XOR<ShopCreateWithoutDishCategoryInput, ShopUncheckedCreateWithoutDishCategoryInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDishCategoryInput
    connect?: ShopWhereUniqueInput
  }

  export type TablePositionCreateNestedManyWithoutDishCategoriesInput = {
    create?: XOR<TablePositionCreateWithoutDishCategoriesInput, TablePositionUncheckedCreateWithoutDishCategoriesInput> | TablePositionCreateWithoutDishCategoriesInput[] | TablePositionUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutDishCategoriesInput | TablePositionCreateOrConnectWithoutDishCategoriesInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
  }

  export type KitchenCreateNestedManyWithoutDishCategoriesInput = {
    create?: XOR<KitchenCreateWithoutDishCategoriesInput, KitchenUncheckedCreateWithoutDishCategoriesInput> | KitchenCreateWithoutDishCategoriesInput[] | KitchenUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutDishCategoriesInput | KitchenCreateOrConnectWithoutDishCategoriesInput[]
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
  }

  export type DishUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type TablePositionUncheckedCreateNestedManyWithoutDishCategoriesInput = {
    create?: XOR<TablePositionCreateWithoutDishCategoriesInput, TablePositionUncheckedCreateWithoutDishCategoriesInput> | TablePositionCreateWithoutDishCategoriesInput[] | TablePositionUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutDishCategoriesInput | TablePositionCreateOrConnectWithoutDishCategoriesInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
  }

  export type KitchenUncheckedCreateNestedManyWithoutDishCategoriesInput = {
    create?: XOR<KitchenCreateWithoutDishCategoriesInput, KitchenUncheckedCreateWithoutDishCategoriesInput> | KitchenCreateWithoutDishCategoriesInput[] | KitchenUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutDishCategoriesInput | KitchenCreateOrConnectWithoutDishCategoriesInput[]
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
  }

  export type DishUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutCategoryInput | DishUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutCategoryInput | DishUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutCategoryInput | DishUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type ShopUpdateOneWithoutDishCategoryNestedInput = {
    create?: XOR<ShopCreateWithoutDishCategoryInput, ShopUncheckedCreateWithoutDishCategoryInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDishCategoryInput
    upsert?: ShopUpsertWithoutDishCategoryInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutDishCategoryInput, ShopUpdateWithoutDishCategoryInput>, ShopUncheckedUpdateWithoutDishCategoryInput>
  }

  export type TablePositionUpdateManyWithoutDishCategoriesNestedInput = {
    create?: XOR<TablePositionCreateWithoutDishCategoriesInput, TablePositionUncheckedCreateWithoutDishCategoriesInput> | TablePositionCreateWithoutDishCategoriesInput[] | TablePositionUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutDishCategoriesInput | TablePositionCreateOrConnectWithoutDishCategoriesInput[]
    upsert?: TablePositionUpsertWithWhereUniqueWithoutDishCategoriesInput | TablePositionUpsertWithWhereUniqueWithoutDishCategoriesInput[]
    set?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    disconnect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    delete?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    update?: TablePositionUpdateWithWhereUniqueWithoutDishCategoriesInput | TablePositionUpdateWithWhereUniqueWithoutDishCategoriesInput[]
    updateMany?: TablePositionUpdateManyWithWhereWithoutDishCategoriesInput | TablePositionUpdateManyWithWhereWithoutDishCategoriesInput[]
    deleteMany?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
  }

  export type KitchenUpdateManyWithoutDishCategoriesNestedInput = {
    create?: XOR<KitchenCreateWithoutDishCategoriesInput, KitchenUncheckedCreateWithoutDishCategoriesInput> | KitchenCreateWithoutDishCategoriesInput[] | KitchenUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutDishCategoriesInput | KitchenCreateOrConnectWithoutDishCategoriesInput[]
    upsert?: KitchenUpsertWithWhereUniqueWithoutDishCategoriesInput | KitchenUpsertWithWhereUniqueWithoutDishCategoriesInput[]
    set?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    disconnect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    delete?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    update?: KitchenUpdateWithWhereUniqueWithoutDishCategoriesInput | KitchenUpdateWithWhereUniqueWithoutDishCategoriesInput[]
    updateMany?: KitchenUpdateManyWithWhereWithoutDishCategoriesInput | KitchenUpdateManyWithWhereWithoutDishCategoriesInput[]
    deleteMany?: KitchenScalarWhereInput | KitchenScalarWhereInput[]
  }

  export type DishUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput> | DishCreateWithoutCategoryInput[] | DishUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: DishCreateOrConnectWithoutCategoryInput | DishCreateOrConnectWithoutCategoryInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutCategoryInput | DishUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: DishCreateManyCategoryInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutCategoryInput | DishUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: DishUpdateManyWithWhereWithoutCategoryInput | DishUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type TablePositionUncheckedUpdateManyWithoutDishCategoriesNestedInput = {
    create?: XOR<TablePositionCreateWithoutDishCategoriesInput, TablePositionUncheckedCreateWithoutDishCategoriesInput> | TablePositionCreateWithoutDishCategoriesInput[] | TablePositionUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutDishCategoriesInput | TablePositionCreateOrConnectWithoutDishCategoriesInput[]
    upsert?: TablePositionUpsertWithWhereUniqueWithoutDishCategoriesInput | TablePositionUpsertWithWhereUniqueWithoutDishCategoriesInput[]
    set?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    disconnect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    delete?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    update?: TablePositionUpdateWithWhereUniqueWithoutDishCategoriesInput | TablePositionUpdateWithWhereUniqueWithoutDishCategoriesInput[]
    updateMany?: TablePositionUpdateManyWithWhereWithoutDishCategoriesInput | TablePositionUpdateManyWithWhereWithoutDishCategoriesInput[]
    deleteMany?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
  }

  export type KitchenUncheckedUpdateManyWithoutDishCategoriesNestedInput = {
    create?: XOR<KitchenCreateWithoutDishCategoriesInput, KitchenUncheckedCreateWithoutDishCategoriesInput> | KitchenCreateWithoutDishCategoriesInput[] | KitchenUncheckedCreateWithoutDishCategoriesInput[]
    connectOrCreate?: KitchenCreateOrConnectWithoutDishCategoriesInput | KitchenCreateOrConnectWithoutDishCategoriesInput[]
    upsert?: KitchenUpsertWithWhereUniqueWithoutDishCategoriesInput | KitchenUpsertWithWhereUniqueWithoutDishCategoriesInput[]
    set?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    disconnect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    delete?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    connect?: KitchenWhereUniqueInput | KitchenWhereUniqueInput[]
    update?: KitchenUpdateWithWhereUniqueWithoutDishCategoriesInput | KitchenUpdateWithWhereUniqueWithoutDishCategoriesInput[]
    updateMany?: KitchenUpdateManyWithWhereWithoutDishCategoriesInput | KitchenUpdateManyWithWhereWithoutDishCategoriesInput[]
    deleteMany?: KitchenScalarWhereInput | KitchenScalarWhereInput[]
  }

  export type DishCategoryCreateNestedOneWithoutDishInput = {
    create?: XOR<DishCategoryCreateWithoutDishInput, DishCategoryUncheckedCreateWithoutDishInput>
    connectOrCreate?: DishCategoryCreateOrConnectWithoutDishInput
    connect?: DishCategoryWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutDishInput = {
    create?: XOR<ShopCreateWithoutDishInput, ShopUncheckedCreateWithoutDishInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDishInput
    connect?: ShopWhereUniqueInput
  }

  export type UnitCreateNestedOneWithoutDishInput = {
    create?: XOR<UnitCreateWithoutDishInput, UnitUncheckedCreateWithoutDishInput>
    connectOrCreate?: UnitCreateOrConnectWithoutDishInput
    connect?: UnitWhereUniqueInput
  }

  export type ImageCreateNestedManyWithoutDishInput = {
    create?: XOR<ImageCreateWithoutDishInput, ImageUncheckedCreateWithoutDishInput> | ImageCreateWithoutDishInput[] | ImageUncheckedCreateWithoutDishInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutDishInput | ImageCreateOrConnectWithoutDishInput[]
    createMany?: ImageCreateManyDishInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type ImageUncheckedCreateNestedManyWithoutDishInput = {
    create?: XOR<ImageCreateWithoutDishInput, ImageUncheckedCreateWithoutDishInput> | ImageCreateWithoutDishInput[] | ImageUncheckedCreateWithoutDishInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutDishInput | ImageCreateOrConnectWithoutDishInput[]
    createMany?: ImageCreateManyDishInputEnvelope
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
  }

  export type DishCategoryUpdateOneWithoutDishNestedInput = {
    create?: XOR<DishCategoryCreateWithoutDishInput, DishCategoryUncheckedCreateWithoutDishInput>
    connectOrCreate?: DishCategoryCreateOrConnectWithoutDishInput
    upsert?: DishCategoryUpsertWithoutDishInput
    disconnect?: DishCategoryWhereInput | boolean
    delete?: DishCategoryWhereInput | boolean
    connect?: DishCategoryWhereUniqueInput
    update?: XOR<XOR<DishCategoryUpdateToOneWithWhereWithoutDishInput, DishCategoryUpdateWithoutDishInput>, DishCategoryUncheckedUpdateWithoutDishInput>
  }

  export type ShopUpdateOneWithoutDishNestedInput = {
    create?: XOR<ShopCreateWithoutDishInput, ShopUncheckedCreateWithoutDishInput>
    connectOrCreate?: ShopCreateOrConnectWithoutDishInput
    upsert?: ShopUpsertWithoutDishInput
    disconnect?: ShopWhereInput | boolean
    delete?: ShopWhereInput | boolean
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutDishInput, ShopUpdateWithoutDishInput>, ShopUncheckedUpdateWithoutDishInput>
  }

  export type UnitUpdateOneWithoutDishNestedInput = {
    create?: XOR<UnitCreateWithoutDishInput, UnitUncheckedCreateWithoutDishInput>
    connectOrCreate?: UnitCreateOrConnectWithoutDishInput
    upsert?: UnitUpsertWithoutDishInput
    disconnect?: UnitWhereInput | boolean
    delete?: UnitWhereInput | boolean
    connect?: UnitWhereUniqueInput
    update?: XOR<XOR<UnitUpdateToOneWithWhereWithoutDishInput, UnitUpdateWithoutDishInput>, UnitUncheckedUpdateWithoutDishInput>
  }

  export type ImageUpdateManyWithoutDishNestedInput = {
    create?: XOR<ImageCreateWithoutDishInput, ImageUncheckedCreateWithoutDishInput> | ImageCreateWithoutDishInput[] | ImageUncheckedCreateWithoutDishInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutDishInput | ImageCreateOrConnectWithoutDishInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutDishInput | ImageUpsertWithWhereUniqueWithoutDishInput[]
    createMany?: ImageCreateManyDishInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutDishInput | ImageUpdateWithWhereUniqueWithoutDishInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutDishInput | ImageUpdateManyWithWhereWithoutDishInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type ImageUncheckedUpdateManyWithoutDishNestedInput = {
    create?: XOR<ImageCreateWithoutDishInput, ImageUncheckedCreateWithoutDishInput> | ImageCreateWithoutDishInput[] | ImageUncheckedCreateWithoutDishInput[]
    connectOrCreate?: ImageCreateOrConnectWithoutDishInput | ImageCreateOrConnectWithoutDishInput[]
    upsert?: ImageUpsertWithWhereUniqueWithoutDishInput | ImageUpsertWithWhereUniqueWithoutDishInput[]
    createMany?: ImageCreateManyDishInputEnvelope
    set?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    disconnect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    delete?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    connect?: ImageWhereUniqueInput | ImageWhereUniqueInput[]
    update?: ImageUpdateWithWhereUniqueWithoutDishInput | ImageUpdateWithWhereUniqueWithoutDishInput[]
    updateMany?: ImageUpdateManyWithWhereWithoutDishInput | ImageUpdateManyWithWhereWithoutDishInput[]
    deleteMany?: ImageScalarWhereInput | ImageScalarWhereInput[]
  }

  export type DishCreateNestedManyWithoutUnitInput = {
    create?: XOR<DishCreateWithoutUnitInput, DishUncheckedCreateWithoutUnitInput> | DishCreateWithoutUnitInput[] | DishUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DishCreateOrConnectWithoutUnitInput | DishCreateOrConnectWithoutUnitInput[]
    createMany?: DishCreateManyUnitInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutUnitInput = {
    create?: XOR<ShopCreateWithoutUnitInput, ShopUncheckedCreateWithoutUnitInput>
    connectOrCreate?: ShopCreateOrConnectWithoutUnitInput
    connect?: ShopWhereUniqueInput
  }

  export type DishUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<DishCreateWithoutUnitInput, DishUncheckedCreateWithoutUnitInput> | DishCreateWithoutUnitInput[] | DishUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DishCreateOrConnectWithoutUnitInput | DishCreateOrConnectWithoutUnitInput[]
    createMany?: DishCreateManyUnitInputEnvelope
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
  }

  export type DishUpdateManyWithoutUnitNestedInput = {
    create?: XOR<DishCreateWithoutUnitInput, DishUncheckedCreateWithoutUnitInput> | DishCreateWithoutUnitInput[] | DishUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DishCreateOrConnectWithoutUnitInput | DishCreateOrConnectWithoutUnitInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutUnitInput | DishUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: DishCreateManyUnitInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutUnitInput | DishUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: DishUpdateManyWithWhereWithoutUnitInput | DishUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type ShopUpdateOneRequiredWithoutUnitNestedInput = {
    create?: XOR<ShopCreateWithoutUnitInput, ShopUncheckedCreateWithoutUnitInput>
    connectOrCreate?: ShopCreateOrConnectWithoutUnitInput
    upsert?: ShopUpsertWithoutUnitInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutUnitInput, ShopUpdateWithoutUnitInput>, ShopUncheckedUpdateWithoutUnitInput>
  }

  export type DishUncheckedUpdateManyWithoutUnitNestedInput = {
    create?: XOR<DishCreateWithoutUnitInput, DishUncheckedCreateWithoutUnitInput> | DishCreateWithoutUnitInput[] | DishUncheckedCreateWithoutUnitInput[]
    connectOrCreate?: DishCreateOrConnectWithoutUnitInput | DishCreateOrConnectWithoutUnitInput[]
    upsert?: DishUpsertWithWhereUniqueWithoutUnitInput | DishUpsertWithWhereUniqueWithoutUnitInput[]
    createMany?: DishCreateManyUnitInputEnvelope
    set?: DishWhereUniqueInput | DishWhereUniqueInput[]
    disconnect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    delete?: DishWhereUniqueInput | DishWhereUniqueInput[]
    connect?: DishWhereUniqueInput | DishWhereUniqueInput[]
    update?: DishUpdateWithWhereUniqueWithoutUnitInput | DishUpdateWithWhereUniqueWithoutUnitInput[]
    updateMany?: DishUpdateManyWithWhereWithoutUnitInput | DishUpdateManyWithWhereWithoutUnitInput[]
    deleteMany?: DishScalarWhereInput | DishScalarWhereInput[]
  }

  export type TablePositionCreatedishCategoryIdsInput = {
    set: string[]
  }

  export type TablePositionCreatetableIdsInput = {
    set: string[]
  }

  export type ShopCreateNestedOneWithoutTablePositionInput = {
    create?: XOR<ShopCreateWithoutTablePositionInput, ShopUncheckedCreateWithoutTablePositionInput>
    connectOrCreate?: ShopCreateOrConnectWithoutTablePositionInput
    connect?: ShopWhereUniqueInput
  }

  export type DishCategoryCreateNestedManyWithoutTablePositionInput = {
    create?: XOR<DishCategoryCreateWithoutTablePositionInput, DishCategoryUncheckedCreateWithoutTablePositionInput> | DishCategoryCreateWithoutTablePositionInput[] | DishCategoryUncheckedCreateWithoutTablePositionInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutTablePositionInput | DishCategoryCreateOrConnectWithoutTablePositionInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
  }

  export type TableCreateNestedManyWithoutPositionInput = {
    create?: XOR<TableCreateWithoutPositionInput, TableUncheckedCreateWithoutPositionInput> | TableCreateWithoutPositionInput[] | TableUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPositionInput | TableCreateOrConnectWithoutPositionInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type DishCategoryUncheckedCreateNestedManyWithoutTablePositionInput = {
    create?: XOR<DishCategoryCreateWithoutTablePositionInput, DishCategoryUncheckedCreateWithoutTablePositionInput> | DishCategoryCreateWithoutTablePositionInput[] | DishCategoryUncheckedCreateWithoutTablePositionInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutTablePositionInput | DishCategoryCreateOrConnectWithoutTablePositionInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
  }

  export type TableUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<TableCreateWithoutPositionInput, TableUncheckedCreateWithoutPositionInput> | TableCreateWithoutPositionInput[] | TableUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPositionInput | TableCreateOrConnectWithoutPositionInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
  }

  export type TablePositionUpdatedishCategoryIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TablePositionUpdatetableIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ShopUpdateOneRequiredWithoutTablePositionNestedInput = {
    create?: XOR<ShopCreateWithoutTablePositionInput, ShopUncheckedCreateWithoutTablePositionInput>
    connectOrCreate?: ShopCreateOrConnectWithoutTablePositionInput
    upsert?: ShopUpsertWithoutTablePositionInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutTablePositionInput, ShopUpdateWithoutTablePositionInput>, ShopUncheckedUpdateWithoutTablePositionInput>
  }

  export type DishCategoryUpdateManyWithoutTablePositionNestedInput = {
    create?: XOR<DishCategoryCreateWithoutTablePositionInput, DishCategoryUncheckedCreateWithoutTablePositionInput> | DishCategoryCreateWithoutTablePositionInput[] | DishCategoryUncheckedCreateWithoutTablePositionInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutTablePositionInput | DishCategoryCreateOrConnectWithoutTablePositionInput[]
    upsert?: DishCategoryUpsertWithWhereUniqueWithoutTablePositionInput | DishCategoryUpsertWithWhereUniqueWithoutTablePositionInput[]
    set?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    disconnect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    delete?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    update?: DishCategoryUpdateWithWhereUniqueWithoutTablePositionInput | DishCategoryUpdateWithWhereUniqueWithoutTablePositionInput[]
    updateMany?: DishCategoryUpdateManyWithWhereWithoutTablePositionInput | DishCategoryUpdateManyWithWhereWithoutTablePositionInput[]
    deleteMany?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
  }

  export type TableUpdateManyWithoutPositionNestedInput = {
    create?: XOR<TableCreateWithoutPositionInput, TableUncheckedCreateWithoutPositionInput> | TableCreateWithoutPositionInput[] | TableUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPositionInput | TableCreateOrConnectWithoutPositionInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutPositionInput | TableUpsertWithWhereUniqueWithoutPositionInput[]
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutPositionInput | TableUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: TableUpdateManyWithWhereWithoutPositionInput | TableUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type DishCategoryUncheckedUpdateManyWithoutTablePositionNestedInput = {
    create?: XOR<DishCategoryCreateWithoutTablePositionInput, DishCategoryUncheckedCreateWithoutTablePositionInput> | DishCategoryCreateWithoutTablePositionInput[] | DishCategoryUncheckedCreateWithoutTablePositionInput[]
    connectOrCreate?: DishCategoryCreateOrConnectWithoutTablePositionInput | DishCategoryCreateOrConnectWithoutTablePositionInput[]
    upsert?: DishCategoryUpsertWithWhereUniqueWithoutTablePositionInput | DishCategoryUpsertWithWhereUniqueWithoutTablePositionInput[]
    set?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    disconnect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    delete?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    connect?: DishCategoryWhereUniqueInput | DishCategoryWhereUniqueInput[]
    update?: DishCategoryUpdateWithWhereUniqueWithoutTablePositionInput | DishCategoryUpdateWithWhereUniqueWithoutTablePositionInput[]
    updateMany?: DishCategoryUpdateManyWithWhereWithoutTablePositionInput | DishCategoryUpdateManyWithWhereWithoutTablePositionInput[]
    deleteMany?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
  }

  export type TableUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<TableCreateWithoutPositionInput, TableUncheckedCreateWithoutPositionInput> | TableCreateWithoutPositionInput[] | TableUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: TableCreateOrConnectWithoutPositionInput | TableCreateOrConnectWithoutPositionInput[]
    upsert?: TableUpsertWithWhereUniqueWithoutPositionInput | TableUpsertWithWhereUniqueWithoutPositionInput[]
    set?: TableWhereUniqueInput | TableWhereUniqueInput[]
    disconnect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    delete?: TableWhereUniqueInput | TableWhereUniqueInput[]
    connect?: TableWhereUniqueInput | TableWhereUniqueInput[]
    update?: TableUpdateWithWhereUniqueWithoutPositionInput | TableUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: TableUpdateManyWithWhereWithoutPositionInput | TableUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: TableScalarWhereInput | TableScalarWhereInput[]
  }

  export type ShopCreateNestedOneWithoutTableInput = {
    create?: XOR<ShopCreateWithoutTableInput, ShopUncheckedCreateWithoutTableInput>
    connectOrCreate?: ShopCreateOrConnectWithoutTableInput
    connect?: ShopWhereUniqueInput
  }

  export type TablePositionCreateNestedManyWithoutTablesInput = {
    create?: XOR<TablePositionCreateWithoutTablesInput, TablePositionUncheckedCreateWithoutTablesInput> | TablePositionCreateWithoutTablesInput[] | TablePositionUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutTablesInput | TablePositionCreateOrConnectWithoutTablesInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
  }

  export type KitchenCreateNestedOneWithoutTablesInput = {
    create?: XOR<KitchenCreateWithoutTablesInput, KitchenUncheckedCreateWithoutTablesInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutTablesInput
    connect?: KitchenWhereUniqueInput
  }

  export type OrderCreateNestedManyWithoutTableInput = {
    create?: XOR<OrderCreateWithoutTableInput, OrderUncheckedCreateWithoutTableInput> | OrderCreateWithoutTableInput[] | OrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableInput | OrderCreateOrConnectWithoutTableInput[]
    createMany?: OrderCreateManyTableInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type TablePositionUncheckedCreateNestedManyWithoutTablesInput = {
    create?: XOR<TablePositionCreateWithoutTablesInput, TablePositionUncheckedCreateWithoutTablesInput> | TablePositionCreateWithoutTablesInput[] | TablePositionUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutTablesInput | TablePositionCreateOrConnectWithoutTablesInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
  }

  export type OrderUncheckedCreateNestedManyWithoutTableInput = {
    create?: XOR<OrderCreateWithoutTableInput, OrderUncheckedCreateWithoutTableInput> | OrderCreateWithoutTableInput[] | OrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableInput | OrderCreateOrConnectWithoutTableInput[]
    createMany?: OrderCreateManyTableInputEnvelope
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
  }

  export type ShopUpdateOneRequiredWithoutTableNestedInput = {
    create?: XOR<ShopCreateWithoutTableInput, ShopUncheckedCreateWithoutTableInput>
    connectOrCreate?: ShopCreateOrConnectWithoutTableInput
    upsert?: ShopUpsertWithoutTableInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutTableInput, ShopUpdateWithoutTableInput>, ShopUncheckedUpdateWithoutTableInput>
  }

  export type TablePositionUpdateManyWithoutTablesNestedInput = {
    create?: XOR<TablePositionCreateWithoutTablesInput, TablePositionUncheckedCreateWithoutTablesInput> | TablePositionCreateWithoutTablesInput[] | TablePositionUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutTablesInput | TablePositionCreateOrConnectWithoutTablesInput[]
    upsert?: TablePositionUpsertWithWhereUniqueWithoutTablesInput | TablePositionUpsertWithWhereUniqueWithoutTablesInput[]
    set?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    disconnect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    delete?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    update?: TablePositionUpdateWithWhereUniqueWithoutTablesInput | TablePositionUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: TablePositionUpdateManyWithWhereWithoutTablesInput | TablePositionUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
  }

  export type KitchenUpdateOneWithoutTablesNestedInput = {
    create?: XOR<KitchenCreateWithoutTablesInput, KitchenUncheckedCreateWithoutTablesInput>
    connectOrCreate?: KitchenCreateOrConnectWithoutTablesInput
    upsert?: KitchenUpsertWithoutTablesInput
    disconnect?: KitchenWhereInput | boolean
    delete?: KitchenWhereInput | boolean
    connect?: KitchenWhereUniqueInput
    update?: XOR<XOR<KitchenUpdateToOneWithWhereWithoutTablesInput, KitchenUpdateWithoutTablesInput>, KitchenUncheckedUpdateWithoutTablesInput>
  }

  export type OrderUpdateManyWithoutTableNestedInput = {
    create?: XOR<OrderCreateWithoutTableInput, OrderUncheckedCreateWithoutTableInput> | OrderCreateWithoutTableInput[] | OrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableInput | OrderCreateOrConnectWithoutTableInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTableInput | OrderUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: OrderCreateManyTableInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTableInput | OrderUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTableInput | OrderUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type TablePositionUncheckedUpdateManyWithoutTablesNestedInput = {
    create?: XOR<TablePositionCreateWithoutTablesInput, TablePositionUncheckedCreateWithoutTablesInput> | TablePositionCreateWithoutTablesInput[] | TablePositionUncheckedCreateWithoutTablesInput[]
    connectOrCreate?: TablePositionCreateOrConnectWithoutTablesInput | TablePositionCreateOrConnectWithoutTablesInput[]
    upsert?: TablePositionUpsertWithWhereUniqueWithoutTablesInput | TablePositionUpsertWithWhereUniqueWithoutTablesInput[]
    set?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    disconnect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    delete?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    connect?: TablePositionWhereUniqueInput | TablePositionWhereUniqueInput[]
    update?: TablePositionUpdateWithWhereUniqueWithoutTablesInput | TablePositionUpdateWithWhereUniqueWithoutTablesInput[]
    updateMany?: TablePositionUpdateManyWithWhereWithoutTablesInput | TablePositionUpdateManyWithWhereWithoutTablesInput[]
    deleteMany?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
  }

  export type OrderUncheckedUpdateManyWithoutTableNestedInput = {
    create?: XOR<OrderCreateWithoutTableInput, OrderUncheckedCreateWithoutTableInput> | OrderCreateWithoutTableInput[] | OrderUncheckedCreateWithoutTableInput[]
    connectOrCreate?: OrderCreateOrConnectWithoutTableInput | OrderCreateOrConnectWithoutTableInput[]
    upsert?: OrderUpsertWithWhereUniqueWithoutTableInput | OrderUpsertWithWhereUniqueWithoutTableInput[]
    createMany?: OrderCreateManyTableInputEnvelope
    set?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    disconnect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    delete?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    connect?: OrderWhereUniqueInput | OrderWhereUniqueInput[]
    update?: OrderUpdateWithWhereUniqueWithoutTableInput | OrderUpdateWithWhereUniqueWithoutTableInput[]
    updateMany?: OrderUpdateManyWithWhereWithoutTableInput | OrderUpdateManyWithWhereWithoutTableInput[]
    deleteMany?: OrderScalarWhereInput | OrderScalarWhereInput[]
  }

  export type EmployeeDepartmentCreatepermissionsInput = {
    set: string[]
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutEmployeeDepartmentsInput = {
    create?: XOR<ShopCreateWithoutEmployeeDepartmentsInput, ShopUncheckedCreateWithoutEmployeeDepartmentsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEmployeeDepartmentsInput
    connect?: ShopWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeDepartmentUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShopUpdateOneRequiredWithoutEmployeeDepartmentsNestedInput = {
    create?: XOR<ShopCreateWithoutEmployeeDepartmentsInput, ShopUncheckedCreateWithoutEmployeeDepartmentsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEmployeeDepartmentsInput
    upsert?: ShopUpsertWithoutEmployeeDepartmentsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutEmployeeDepartmentsInput, ShopUpdateWithoutEmployeeDepartmentsInput>, ShopUncheckedUpdateWithoutEmployeeDepartmentsInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShopCreateNestedOneWithoutEmployeePositionsInput = {
    create?: XOR<ShopCreateWithoutEmployeePositionsInput, ShopUncheckedCreateWithoutEmployeePositionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEmployeePositionsInput
    connect?: ShopWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedManyWithoutPositionInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShopUpdateOneRequiredWithoutEmployeePositionsNestedInput = {
    create?: XOR<ShopCreateWithoutEmployeePositionsInput, ShopUncheckedCreateWithoutEmployeePositionsInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEmployeePositionsInput
    upsert?: ShopUpsertWithoutEmployeePositionsInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutEmployeePositionsInput, ShopUpdateWithoutEmployeePositionsInput>, ShopUncheckedUpdateWithoutEmployeePositionsInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionNestedInput = {
    create?: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput> | EmployeeCreateWithoutPositionInput[] | EmployeeUncheckedCreateWithoutPositionInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutPositionInput | EmployeeCreateOrConnectWithoutPositionInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutPositionInput | EmployeeUpsertWithWhereUniqueWithoutPositionInput[]
    createMany?: EmployeeCreateManyPositionInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutPositionInput | EmployeeUpdateWithWhereUniqueWithoutPositionInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutPositionInput | EmployeeUpdateManyWithWhereWithoutPositionInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeCreatepermissionsInput = {
    set: string[]
  }

  export type EmployeeDepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EmployeeDepartmentCreateWithoutEmployeesInput, EmployeeDepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployeeDepartmentCreateOrConnectWithoutEmployeesInput
    connect?: EmployeeDepartmentWhereUniqueInput
  }

  export type EmployeePositionCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<EmployeePositionCreateWithoutEmployeesInput, EmployeePositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployeePositionCreateOrConnectWithoutEmployeesInput
    connect?: EmployeePositionWhereUniqueInput
  }

  export type ShopCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ShopCreateWithoutEmployeesInput, ShopUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEmployeesInput
    connect?: ShopWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EmployeeDepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<EmployeeDepartmentCreateWithoutEmployeesInput, EmployeeDepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployeeDepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: EmployeeDepartmentUpsertWithoutEmployeesInput
    disconnect?: EmployeeDepartmentWhereInput | boolean
    delete?: EmployeeDepartmentWhereInput | boolean
    connect?: EmployeeDepartmentWhereUniqueInput
    update?: XOR<XOR<EmployeeDepartmentUpdateToOneWithWhereWithoutEmployeesInput, EmployeeDepartmentUpdateWithoutEmployeesInput>, EmployeeDepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeePositionUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<EmployeePositionCreateWithoutEmployeesInput, EmployeePositionUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: EmployeePositionCreateOrConnectWithoutEmployeesInput
    upsert?: EmployeePositionUpsertWithoutEmployeesInput
    disconnect?: EmployeePositionWhereInput | boolean
    delete?: EmployeePositionWhereInput | boolean
    connect?: EmployeePositionWhereUniqueInput
    update?: XOR<XOR<EmployeePositionUpdateToOneWithWhereWithoutEmployeesInput, EmployeePositionUpdateWithoutEmployeesInput>, EmployeePositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShopUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<ShopCreateWithoutEmployeesInput, ShopUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShopCreateOrConnectWithoutEmployeesInput
    upsert?: ShopUpsertWithoutEmployeesInput
    connect?: ShopWhereUniqueInput
    update?: XOR<XOR<ShopUpdateToOneWithWhereWithoutEmployeesInput, ShopUpdateWithoutEmployeesInput>, ShopUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneRequiredWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTokenTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeFilter<$PrismaModel> | $Enums.TokenType
  }

  export type NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TokenType | EnumTokenTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TokenType[] | ListEnumTokenTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTokenTypeWithAggregatesFilter<$PrismaModel> | $Enums.TokenType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTokenTypeFilter<$PrismaModel>
    _max?: NestedEnumTokenTypeFilter<$PrismaModel>
  }

  export type NestedEnumSwitchabletatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Switchabletatus | EnumSwitchabletatusFieldRefInput<$PrismaModel>
    in?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwitchabletatusFilter<$PrismaModel> | $Enums.Switchabletatus
  }

  export type NestedEnumSwitchabletatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Switchabletatus | EnumSwitchabletatusFieldRefInput<$PrismaModel>
    in?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Switchabletatus[] | ListEnumSwitchabletatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSwitchabletatusWithAggregatesFilter<$PrismaModel> | $Enums.Switchabletatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSwitchabletatusFilter<$PrismaModel>
    _max?: NestedEnumSwitchabletatusFilter<$PrismaModel>
  }

  export type NestedEnumKitchenActionEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenActionEnum | EnumKitchenActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenActionEnumFilter<$PrismaModel> | $Enums.KitchenActionEnum
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumKitchenActionEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KitchenActionEnum | EnumKitchenActionEnumFieldRefInput<$PrismaModel>
    in?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.KitchenActionEnum[] | ListEnumKitchenActionEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumKitchenActionEnumWithAggregatesFilter<$PrismaModel> | $Enums.KitchenActionEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKitchenActionEnumFilter<$PrismaModel>
    _max?: NestedEnumKitchenActionEnumFilter<$PrismaModel>
  }

  export type NestedEnumDishOrderStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DishOrderStatus | EnumDishOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDishOrderStatusFilter<$PrismaModel> | $Enums.DishOrderStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumDishOrderStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DishOrderStatus | EnumDishOrderStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DishOrderStatus[] | ListEnumDishOrderStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDishOrderStatusWithAggregatesFilter<$PrismaModel> | $Enums.DishOrderStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDishOrderStatusFilter<$PrismaModel>
    _max?: NestedEnumDishOrderStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumOrderSessionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSessionStatus | EnumOrderSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSessionStatusFilter<$PrismaModel> | $Enums.OrderSessionStatus
  }

  export type NestedEnumOrderSessionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OrderSessionStatus | EnumOrderSessionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.OrderSessionStatus[] | ListEnumOrderSessionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumOrderSessionStatusWithAggregatesFilter<$PrismaModel> | $Enums.OrderSessionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOrderSessionStatusFilter<$PrismaModel>
    _max?: NestedEnumOrderSessionStatusFilter<$PrismaModel>
  }

  export type NestedEnumDiscountValueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountValueType | EnumDiscountValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountValueTypeFilter<$PrismaModel> | $Enums.DiscountValueType
  }

  export type NestedEnumDiscountValueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountValueType | EnumDiscountValueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountValueType[] | ListEnumDiscountValueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountValueTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountValueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountValueTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountValueTypeFilter<$PrismaModel>
  }

  export type NestedEnumDiscountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeFilter<$PrismaModel> | $Enums.DiscountType
  }

  export type NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DiscountType | EnumDiscountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DiscountType[] | ListEnumDiscountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDiscountTypeWithAggregatesFilter<$PrismaModel> | $Enums.DiscountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDiscountTypeFilter<$PrismaModel>
    _max?: NestedEnumDiscountTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodEnumFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumFilter<$PrismaModel> | $Enums.PaymentMethodEnum
  }

  export type NestedEnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethodEnum | EnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethodEnum[] | ListEnumPaymentMethodEnumFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodEnumWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethodEnum
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodEnumFilter<$PrismaModel>
  }

  export type NestedEnumRoundingPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoundingPaymentType | EnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoundingPaymentTypeFilter<$PrismaModel> | $Enums.RoundingPaymentType
  }

  export type NestedEnumRoundingPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoundingPaymentType | EnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoundingPaymentType[] | ListEnumRoundingPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoundingPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoundingPaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoundingPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumRoundingPaymentTypeFilter<$PrismaModel>
  }

  export type EmployeeCreateWithoutUserInput = {
    name?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    department?: EmployeeDepartmentCreateNestedOneWithoutEmployeesInput
    position?: EmployeePositionCreateNestedOneWithoutEmployeesInput
    shop: ShopCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeCreateManyUserInputEnvelope = {
    data: EmployeeCreateManyUserInput | EmployeeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutOwnerInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutOwnerInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOwnerInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOwnerInput, ShopUncheckedCreateWithoutOwnerInput>
  }

  export type ShopCreateManyOwnerInputEnvelope = {
    data: ShopCreateManyOwnerInput | ShopCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    customer?: CustomerCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type KitchenLogCreateWithoutUserInput = {
    id?: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutKitchenLogInput
    order: OrderCreateNestedOneWithoutKitchenLogInput
  }

  export type KitchenLogUncheckedCreateWithoutUserInput = {
    id?: string
    shopId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogCreateOrConnectWithoutUserInput = {
    where: KitchenLogWhereUniqueInput
    create: XOR<KitchenLogCreateWithoutUserInput, KitchenLogUncheckedCreateWithoutUserInput>
  }

  export type KitchenLogCreateManyUserInputEnvelope = {
    data: KitchenLogCreateManyUserInput | KitchenLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutApprovedByInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutApprovedByInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutApprovedByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput>
  }

  export type OrderCreateManyApprovedByInputEnvelope = {
    data: OrderCreateManyApprovedByInput | OrderCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCancelledByInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCancelledByInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCancelledByInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCancelledByInput, OrderUncheckedCreateWithoutCancelledByInput>
  }

  export type OrderCreateManyCancelledByInputEnvelope = {
    data: OrderCreateManyCancelledByInput | OrderCreateManyCancelledByInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeUpsertWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutUserInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutUserInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    shopId?: StringFilter<"Employee"> | string
    userId?: StringFilter<"Employee"> | string
    name?: StringNullableFilter<"Employee"> | string | null
    positionId?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    status?: EnumStatusFilter<"Employee"> | $Enums.Status
    permissions?: StringNullableListFilter<"Employee">
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    id?: StringFilter<"Employee"> | string
  }

  export type ShopUpsertWithWhereUniqueWithoutOwnerInput = {
    where: ShopWhereUniqueInput
    update: XOR<ShopUpdateWithoutOwnerInput, ShopUncheckedUpdateWithoutOwnerInput>
    create: XOR<ShopCreateWithoutOwnerInput, ShopUncheckedCreateWithoutOwnerInput>
  }

  export type ShopUpdateWithWhereUniqueWithoutOwnerInput = {
    where: ShopWhereUniqueInput
    data: XOR<ShopUpdateWithoutOwnerInput, ShopUncheckedUpdateWithoutOwnerInput>
  }

  export type ShopUpdateManyWithWhereWithoutOwnerInput = {
    where: ShopScalarWhereInput
    data: XOR<ShopUpdateManyMutationInput, ShopUncheckedUpdateManyWithoutOwnerInput>
  }

  export type ShopScalarWhereInput = {
    AND?: ShopScalarWhereInput | ShopScalarWhereInput[]
    OR?: ShopScalarWhereInput[]
    NOT?: ShopScalarWhereInput | ShopScalarWhereInput[]
    status?: EnumStatusFilter<"Shop"> | $Enums.Status
    name?: StringNullableFilter<"Shop"> | string | null
    phone?: StringNullableFilter<"Shop"> | string | null
    email?: StringNullableFilter<"Shop"> | string | null
    ownerId?: StringNullableFilter<"Shop"> | string | null
    taxRate?: FloatNullableFilter<"Shop"> | number | null
    location?: StringNullableFilter<"Shop"> | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFilter<"Shop"> | $Enums.RoundingPaymentType
    calculateTaxDirectly?: BoolNullableFilter<"Shop"> | boolean | null
    countryName?: StringNullableFilter<"Shop"> | string | null
    countryCurrency?: StringNullableFilter<"Shop"> | string | null
    utcOffset?: IntFilter<"Shop"> | number
    timezone?: StringFilter<"Shop"> | string
    reportTime?: IntFilter<"Shop"> | number
    createdAt?: DateTimeFilter<"Shop"> | Date | string
    updatedAt?: DateTimeFilter<"Shop"> | Date | string
    id?: StringFilter<"Shop"> | string
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: StringFilter<"Token"> | string
    token?: StringFilter<"Token"> | string
    type?: EnumTokenTypeFilter<"Token"> | $Enums.TokenType
    expires?: DateTimeFilter<"Token"> | Date | string
    blacklisted?: BoolFilter<"Token"> | boolean
    isCustomer?: BoolFilter<"Token"> | boolean
    userId?: StringNullableFilter<"Token"> | string | null
    customerId?: StringNullableFilter<"Token"> | string | null
    createdAt?: DateTimeFilter<"Token"> | Date | string
    updatedAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type KitchenLogUpsertWithWhereUniqueWithoutUserInput = {
    where: KitchenLogWhereUniqueInput
    update: XOR<KitchenLogUpdateWithoutUserInput, KitchenLogUncheckedUpdateWithoutUserInput>
    create: XOR<KitchenLogCreateWithoutUserInput, KitchenLogUncheckedCreateWithoutUserInput>
  }

  export type KitchenLogUpdateWithWhereUniqueWithoutUserInput = {
    where: KitchenLogWhereUniqueInput
    data: XOR<KitchenLogUpdateWithoutUserInput, KitchenLogUncheckedUpdateWithoutUserInput>
  }

  export type KitchenLogUpdateManyWithWhereWithoutUserInput = {
    where: KitchenLogScalarWhereInput
    data: XOR<KitchenLogUpdateManyMutationInput, KitchenLogUncheckedUpdateManyWithoutUserInput>
  }

  export type KitchenLogScalarWhereInput = {
    AND?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
    OR?: KitchenLogScalarWhereInput[]
    NOT?: KitchenLogScalarWhereInput | KitchenLogScalarWhereInput[]
    id?: StringFilter<"KitchenLog"> | string
    shopId?: StringFilter<"KitchenLog"> | string
    userId?: StringFilter<"KitchenLog"> | string
    orderId?: StringFilter<"KitchenLog"> | string
    dishOrderId?: StringFilter<"KitchenLog"> | string
    dishName?: StringFilter<"KitchenLog"> | string
    dishQuantity?: IntFilter<"KitchenLog"> | number
    status?: EnumStatusFilter<"KitchenLog"> | $Enums.Status
    action?: EnumKitchenActionEnumFilter<"KitchenLog"> | $Enums.KitchenActionEnum
    createdAt?: DateTimeFilter<"KitchenLog"> | Date | string
    updatedAt?: DateTimeFilter<"KitchenLog"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutApprovedByInput, OrderUncheckedUpdateWithoutApprovedByInput>
    create: XOR<OrderCreateWithoutApprovedByInput, OrderUncheckedCreateWithoutApprovedByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutApprovedByInput, OrderUncheckedUpdateWithoutApprovedByInput>
  }

  export type OrderUpdateManyWithWhereWithoutApprovedByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type OrderScalarWhereInput = {
    AND?: OrderScalarWhereInput | OrderScalarWhereInput[]
    OR?: OrderScalarWhereInput[]
    NOT?: OrderScalarWhereInput | OrderScalarWhereInput[]
    id?: StringFilter<"Order"> | string
    shopId?: StringFilter<"Order"> | string
    tableId?: StringFilter<"Order"> | string
    orderSessionId?: StringFilter<"Order"> | string
    orderNo?: IntFilter<"Order"> | number
    customerId?: StringNullableFilter<"Order"> | string | null
    totalQuantity?: IntFilter<"Order"> | number
    totalBeforeTaxAmount?: FloatFilter<"Order"> | number
    totalAfterTaxAmount?: FloatFilter<"Order"> | number
    approvedById?: StringNullableFilter<"Order"> | string | null
    cancelledById?: StringNullableFilter<"Order"> | string | null
    status?: EnumStatusFilter<"Order"> | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFilter<"Order"> | $Enums.OrderSessionStatus
    numberOfCustomer?: IntNullableFilter<"Order"> | number | null
    createdAt?: DateTimeFilter<"Order"> | Date | string
    updatedAt?: DateTimeFilter<"Order"> | Date | string
  }

  export type OrderUpsertWithWhereUniqueWithoutCancelledByInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCancelledByInput, OrderUncheckedUpdateWithoutCancelledByInput>
    create: XOR<OrderCreateWithoutCancelledByInput, OrderUncheckedCreateWithoutCancelledByInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCancelledByInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCancelledByInput, OrderUncheckedUpdateWithoutCancelledByInput>
  }

  export type OrderUpdateManyWithWhereWithoutCancelledByInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCancelledByInput>
  }

  export type TokenCreateWithoutCustomerInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTokenInput
  }

  export type TokenUncheckedCreateWithoutCustomerInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenCreateOrConnectWithoutCustomerInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutCustomerInput, TokenUncheckedCreateWithoutCustomerInput>
  }

  export type TokenCreateManyCustomerInputEnvelope = {
    data: TokenCreateManyCustomerInput | TokenCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutCustomerInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutCustomerInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderCreateManyCustomerInputEnvelope = {
    data: OrderCreateManyCustomerInput | OrderCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TokenUpsertWithWhereUniqueWithoutCustomerInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutCustomerInput, TokenUncheckedUpdateWithoutCustomerInput>
    create: XOR<TokenCreateWithoutCustomerInput, TokenUncheckedCreateWithoutCustomerInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutCustomerInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutCustomerInput, TokenUncheckedUpdateWithoutCustomerInput>
  }

  export type TokenUpdateManyWithWhereWithoutCustomerInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutCustomerInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
    create: XOR<OrderCreateWithoutCustomerInput, OrderUncheckedCreateWithoutCustomerInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutCustomerInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutCustomerInput, OrderUncheckedUpdateWithoutCustomerInput>
  }

  export type OrderUpdateManyWithWhereWithoutCustomerInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutCustomerInput>
  }

  export type UserCreateWithoutTokenInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeCreateNestedManyWithoutUserInput
    shop?: ShopCreateNestedManyWithoutOwnerInput
    kitchenLog?: KitchenLogCreateNestedManyWithoutUserInput
    approveOrder?: OrderCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderCreateNestedManyWithoutCancelledByInput
  }

  export type UserUncheckedCreateWithoutTokenInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    shop?: ShopUncheckedCreateNestedManyWithoutOwnerInput
    kitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutUserInput
    approveOrder?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderUncheckedCreateNestedManyWithoutCancelledByInput
  }

  export type UserCreateOrConnectWithoutTokenInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
  }

  export type CustomerCreateWithoutTokensInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Order?: OrderCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutTokensInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Order?: OrderUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutTokensInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutTokensInput, CustomerUncheckedCreateWithoutTokensInput>
  }

  export type UserUpsertWithoutTokenInput = {
    update: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
    create: XOR<UserCreateWithoutTokenInput, UserUncheckedCreateWithoutTokenInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTokenInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTokenInput, UserUncheckedUpdateWithoutTokenInput>
  }

  export type UserUpdateWithoutTokenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    shop?: ShopUpdateManyWithoutOwnerNestedInput
    kitchenLog?: KitchenLogUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUncheckedUpdateWithoutTokenInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    shop?: ShopUncheckedUpdateManyWithoutOwnerNestedInput
    kitchenLog?: KitchenLogUncheckedUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUncheckedUpdateManyWithoutCancelledByNestedInput
  }

  export type CustomerUpsertWithoutTokensInput = {
    update: XOR<CustomerUpdateWithoutTokensInput, CustomerUncheckedUpdateWithoutTokensInput>
    create: XOR<CustomerCreateWithoutTokensInput, CustomerUncheckedCreateWithoutTokensInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutTokensInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutTokensInput, CustomerUncheckedUpdateWithoutTokensInput>
  }

  export type CustomerUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Order?: OrderUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Order?: OrderUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type DishCategoryCreateWithoutKitchenInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutCategoryInput
    shop?: ShopCreateNestedOneWithoutDishCategoryInput
    tablePosition?: TablePositionCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryUncheckedCreateWithoutKitchenInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutCategoryInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryCreateOrConnectWithoutKitchenInput = {
    where: DishCategoryWhereUniqueInput
    create: XOR<DishCategoryCreateWithoutKitchenInput, DishCategoryUncheckedCreateWithoutKitchenInput>
  }

  export type TableCreateWithoutKitchenInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTableInput
    position?: TablePositionCreateNestedManyWithoutTablesInput
    Order?: OrderCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutKitchenInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    position?: TablePositionUncheckedCreateNestedManyWithoutTablesInput
    Order?: OrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutKitchenInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutKitchenInput, TableUncheckedCreateWithoutKitchenInput>
  }

  export type TableCreateManyKitchenInputEnvelope = {
    data: TableCreateManyKitchenInput | TableCreateManyKitchenInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutKitchenInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutKitchenInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutKitchenInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutKitchenInput, ShopUncheckedCreateWithoutKitchenInput>
  }

  export type DishCategoryUpsertWithWhereUniqueWithoutKitchenInput = {
    where: DishCategoryWhereUniqueInput
    update: XOR<DishCategoryUpdateWithoutKitchenInput, DishCategoryUncheckedUpdateWithoutKitchenInput>
    create: XOR<DishCategoryCreateWithoutKitchenInput, DishCategoryUncheckedCreateWithoutKitchenInput>
  }

  export type DishCategoryUpdateWithWhereUniqueWithoutKitchenInput = {
    where: DishCategoryWhereUniqueInput
    data: XOR<DishCategoryUpdateWithoutKitchenInput, DishCategoryUncheckedUpdateWithoutKitchenInput>
  }

  export type DishCategoryUpdateManyWithWhereWithoutKitchenInput = {
    where: DishCategoryScalarWhereInput
    data: XOR<DishCategoryUpdateManyMutationInput, DishCategoryUncheckedUpdateManyWithoutKitchenInput>
  }

  export type DishCategoryScalarWhereInput = {
    AND?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
    OR?: DishCategoryScalarWhereInput[]
    NOT?: DishCategoryScalarWhereInput | DishCategoryScalarWhereInput[]
    shopId?: StringNullableFilter<"DishCategory"> | string | null
    name?: StringNullableFilter<"DishCategory"> | string | null
    code?: StringNullableFilter<"DishCategory"> | string | null
    status?: EnumStatusFilter<"DishCategory"> | $Enums.Status
    createdAt?: DateTimeFilter<"DishCategory"> | Date | string
    updatedAt?: DateTimeFilter<"DishCategory"> | Date | string
    id?: StringFilter<"DishCategory"> | string
  }

  export type TableUpsertWithWhereUniqueWithoutKitchenInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutKitchenInput, TableUncheckedUpdateWithoutKitchenInput>
    create: XOR<TableCreateWithoutKitchenInput, TableUncheckedCreateWithoutKitchenInput>
  }

  export type TableUpdateWithWhereUniqueWithoutKitchenInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutKitchenInput, TableUncheckedUpdateWithoutKitchenInput>
  }

  export type TableUpdateManyWithWhereWithoutKitchenInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutKitchenInput>
  }

  export type TableScalarWhereInput = {
    AND?: TableScalarWhereInput | TableScalarWhereInput[]
    OR?: TableScalarWhereInput[]
    NOT?: TableScalarWhereInput | TableScalarWhereInput[]
    shopId?: StringFilter<"Table"> | string
    name?: StringNullableFilter<"Table"> | string | null
    positionId?: StringNullableFilter<"Table"> | string | null
    status?: EnumStatusFilter<"Table"> | $Enums.Status
    allowMultipleOrderSession?: BoolNullableFilter<"Table"> | boolean | null
    needApprovalWhenCustomerOrder?: BoolNullableFilter<"Table"> | boolean | null
    createdAt?: DateTimeFilter<"Table"> | Date | string
    updatedAt?: DateTimeFilter<"Table"> | Date | string
    id?: StringFilter<"Table"> | string
    kitchenId?: StringNullableFilter<"Table"> | string | null
  }

  export type ShopUpsertWithoutKitchenInput = {
    update: XOR<ShopUpdateWithoutKitchenInput, ShopUncheckedUpdateWithoutKitchenInput>
    create: XOR<ShopCreateWithoutKitchenInput, ShopUncheckedCreateWithoutKitchenInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutKitchenInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutKitchenInput, ShopUncheckedUpdateWithoutKitchenInput>
  }

  export type ShopUpdateWithoutKitchenInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutKitchenInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutKitchenLogInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutKitchenLogInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutKitchenLogInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutKitchenLogInput, ShopUncheckedCreateWithoutKitchenLogInput>
  }

  export type UserCreateWithoutKitchenLogInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeCreateNestedManyWithoutUserInput
    shop?: ShopCreateNestedManyWithoutOwnerInput
    token?: TokenCreateNestedManyWithoutUserInput
    approveOrder?: OrderCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderCreateNestedManyWithoutCancelledByInput
  }

  export type UserUncheckedCreateWithoutKitchenLogInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    shop?: ShopUncheckedCreateNestedManyWithoutOwnerInput
    token?: TokenUncheckedCreateNestedManyWithoutUserInput
    approveOrder?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderUncheckedCreateNestedManyWithoutCancelledByInput
  }

  export type UserCreateOrConnectWithoutKitchenLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutKitchenLogInput, UserUncheckedCreateWithoutKitchenLogInput>
  }

  export type OrderCreateWithoutKitchenLogInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
  }

  export type OrderUncheckedCreateWithoutKitchenLogInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
  }

  export type OrderCreateOrConnectWithoutKitchenLogInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutKitchenLogInput, OrderUncheckedCreateWithoutKitchenLogInput>
  }

  export type ShopUpsertWithoutKitchenLogInput = {
    update: XOR<ShopUpdateWithoutKitchenLogInput, ShopUncheckedUpdateWithoutKitchenLogInput>
    create: XOR<ShopCreateWithoutKitchenLogInput, ShopUncheckedCreateWithoutKitchenLogInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutKitchenLogInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutKitchenLogInput, ShopUncheckedUpdateWithoutKitchenLogInput>
  }

  export type ShopUpdateWithoutKitchenLogInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutKitchenLogInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserUpsertWithoutKitchenLogInput = {
    update: XOR<UserUpdateWithoutKitchenLogInput, UserUncheckedUpdateWithoutKitchenLogInput>
    create: XOR<UserCreateWithoutKitchenLogInput, UserUncheckedCreateWithoutKitchenLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutKitchenLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutKitchenLogInput, UserUncheckedUpdateWithoutKitchenLogInput>
  }

  export type UserUpdateWithoutKitchenLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    shop?: ShopUpdateManyWithoutOwnerNestedInput
    token?: TokenUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUncheckedUpdateWithoutKitchenLogInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    shop?: ShopUncheckedUpdateManyWithoutOwnerNestedInput
    token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUncheckedUpdateManyWithoutCancelledByNestedInput
  }

  export type OrderUpsertWithoutKitchenLogInput = {
    update: XOR<OrderUpdateWithoutKitchenLogInput, OrderUncheckedUpdateWithoutKitchenLogInput>
    create: XOR<OrderCreateWithoutKitchenLogInput, OrderUncheckedCreateWithoutKitchenLogInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutKitchenLogInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutKitchenLogInput, OrderUncheckedUpdateWithoutKitchenLogInput>
  }

  export type OrderUpdateWithoutKitchenLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutKitchenLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
  }

  export type OrderCreateWithoutDishOrdersInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutDishOrdersInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutDishOrdersInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutDishOrdersInput, OrderUncheckedCreateWithoutDishOrdersInput>
  }

  export type OrderCreateWithoutReturnedDishOrdersInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutReturnedDishOrdersInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutReturnedDishOrdersInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutReturnedDishOrdersInput, OrderUncheckedCreateWithoutReturnedDishOrdersInput>
  }

  export type OrderUpsertWithoutDishOrdersInput = {
    update: XOR<OrderUpdateWithoutDishOrdersInput, OrderUncheckedUpdateWithoutDishOrdersInput>
    create: XOR<OrderCreateWithoutDishOrdersInput, OrderUncheckedCreateWithoutDishOrdersInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutDishOrdersInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutDishOrdersInput, OrderUncheckedUpdateWithoutDishOrdersInput>
  }

  export type OrderUpdateWithoutDishOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutDishOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUpsertWithoutReturnedDishOrdersInput = {
    update: XOR<OrderUpdateWithoutReturnedDishOrdersInput, OrderUncheckedUpdateWithoutReturnedDishOrdersInput>
    create: XOR<OrderCreateWithoutReturnedDishOrdersInput, OrderUncheckedCreateWithoutReturnedDishOrdersInput>
    where?: OrderWhereInput
  }

  export type OrderUpdateToOneWithWhereWithoutReturnedDishOrdersInput = {
    where?: OrderWhereInput
    data: XOR<OrderUpdateWithoutReturnedDishOrdersInput, OrderUncheckedUpdateWithoutReturnedDishOrdersInput>
  }

  export type OrderUpdateWithoutReturnedDishOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutReturnedDishOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type DishOrderCreateWithoutOrderInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    returnedOrder?: OrderCreateNestedOneWithoutReturnedDishOrdersInput
  }

  export type DishOrderUncheckedCreateWithoutOrderInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    returnedOrderId?: string | null
  }

  export type DishOrderCreateOrConnectWithoutOrderInput = {
    where: DishOrderWhereUniqueInput
    create: XOR<DishOrderCreateWithoutOrderInput, DishOrderUncheckedCreateWithoutOrderInput>
  }

  export type DishOrderCreateManyOrderInputEnvelope = {
    data: DishOrderCreateManyOrderInput | DishOrderCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DishOrderCreateWithoutReturnedOrderInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    order?: OrderCreateNestedOneWithoutDishOrdersInput
  }

  export type DishOrderUncheckedCreateWithoutReturnedOrderInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    orderId?: string | null
  }

  export type DishOrderCreateOrConnectWithoutReturnedOrderInput = {
    where: DishOrderWhereUniqueInput
    create: XOR<DishOrderCreateWithoutReturnedOrderInput, DishOrderUncheckedCreateWithoutReturnedOrderInput>
  }

  export type DishOrderCreateManyReturnedOrderInputEnvelope = {
    data: DishOrderCreateManyReturnedOrderInput | DishOrderCreateManyReturnedOrderInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutOrderInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutOrderInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOrderInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOrderInput, ShopUncheckedCreateWithoutOrderInput>
  }

  export type TableCreateWithoutOrderInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTableInput
    position?: TablePositionCreateNestedManyWithoutTablesInput
    Kitchen?: KitchenCreateNestedOneWithoutTablesInput
  }

  export type TableUncheckedCreateWithoutOrderInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    kitchenId?: string | null
    position?: TablePositionUncheckedCreateNestedManyWithoutTablesInput
  }

  export type TableCreateOrConnectWithoutOrderInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutOrderInput, TableUncheckedCreateWithoutOrderInput>
  }

  export type OrderSessionCreateWithoutOrdersInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discounts?: DiscountCreateNestedManyWithoutOrderSessionInput
    shop: ShopCreateNestedOneWithoutOrderSessionInput
    taxDetails?: TaxDetailCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUncheckedCreateWithoutOrdersInput = {
    id?: string
    shopId: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderSessionInput
    taxDetails?: TaxDetailUncheckedCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailUncheckedCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionCreateOrConnectWithoutOrdersInput = {
    where: OrderSessionWhereUniqueInput
    create: XOR<OrderSessionCreateWithoutOrdersInput, OrderSessionUncheckedCreateWithoutOrdersInput>
  }

  export type CustomerCreateWithoutOrderInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenCreateNestedManyWithoutCustomerInput
  }

  export type CustomerUncheckedCreateWithoutOrderInput = {
    id?: string
    name?: string | null
    phone?: string | null
    email?: string | null
    password?: string | null
    address?: string | null
    anonymous?: boolean | null
    totalOrderTimes?: number | null
    totalOrderValue?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tokens?: TokenUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type CustomerCreateOrConnectWithoutOrderInput = {
    where: CustomerWhereUniqueInput
    create: XOR<CustomerCreateWithoutOrderInput, CustomerUncheckedCreateWithoutOrderInput>
  }

  export type UserCreateWithoutApproveOrderInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeCreateNestedManyWithoutUserInput
    shop?: ShopCreateNestedManyWithoutOwnerInput
    token?: TokenCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogCreateNestedManyWithoutUserInput
    cancelledOrder?: OrderCreateNestedManyWithoutCancelledByInput
  }

  export type UserUncheckedCreateWithoutApproveOrderInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    shop?: ShopUncheckedCreateNestedManyWithoutOwnerInput
    token?: TokenUncheckedCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutUserInput
    cancelledOrder?: OrderUncheckedCreateNestedManyWithoutCancelledByInput
  }

  export type UserCreateOrConnectWithoutApproveOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutApproveOrderInput, UserUncheckedCreateWithoutApproveOrderInput>
  }

  export type UserCreateWithoutCancelledOrderInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeCreateNestedManyWithoutUserInput
    shop?: ShopCreateNestedManyWithoutOwnerInput
    token?: TokenCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogCreateNestedManyWithoutUserInput
    approveOrder?: OrderCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutCancelledOrderInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    shop?: ShopUncheckedCreateNestedManyWithoutOwnerInput
    token?: TokenUncheckedCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutUserInput
    approveOrder?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutCancelledOrderInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCancelledOrderInput, UserUncheckedCreateWithoutCancelledOrderInput>
  }

  export type KitchenLogCreateWithoutOrderInput = {
    id?: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    shop: ShopCreateNestedOneWithoutKitchenLogInput
    user: UserCreateNestedOneWithoutKitchenLogInput
  }

  export type KitchenLogUncheckedCreateWithoutOrderInput = {
    id?: string
    shopId: string
    userId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogCreateOrConnectWithoutOrderInput = {
    where: KitchenLogWhereUniqueInput
    create: XOR<KitchenLogCreateWithoutOrderInput, KitchenLogUncheckedCreateWithoutOrderInput>
  }

  export type KitchenLogCreateManyOrderInputEnvelope = {
    data: KitchenLogCreateManyOrderInput | KitchenLogCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type DishOrderUpsertWithWhereUniqueWithoutOrderInput = {
    where: DishOrderWhereUniqueInput
    update: XOR<DishOrderUpdateWithoutOrderInput, DishOrderUncheckedUpdateWithoutOrderInput>
    create: XOR<DishOrderCreateWithoutOrderInput, DishOrderUncheckedCreateWithoutOrderInput>
  }

  export type DishOrderUpdateWithWhereUniqueWithoutOrderInput = {
    where: DishOrderWhereUniqueInput
    data: XOR<DishOrderUpdateWithoutOrderInput, DishOrderUncheckedUpdateWithoutOrderInput>
  }

  export type DishOrderUpdateManyWithWhereWithoutOrderInput = {
    where: DishOrderScalarWhereInput
    data: XOR<DishOrderUpdateManyMutationInput, DishOrderUncheckedUpdateManyWithoutOrderInput>
  }

  export type DishOrderScalarWhereInput = {
    AND?: DishOrderScalarWhereInput | DishOrderScalarWhereInput[]
    OR?: DishOrderScalarWhereInput[]
    NOT?: DishOrderScalarWhereInput | DishOrderScalarWhereInput[]
    id?: StringFilter<"DishOrder"> | string
    dishOrderNo?: IntNullableFilter<"DishOrder"> | number | null
    dishId?: StringFilter<"DishOrder"> | string
    name?: StringFilter<"DishOrder"> | string
    unit?: StringFilter<"DishOrder"> | string
    price?: FloatFilter<"DishOrder"> | number
    isTaxIncludedPrice?: BoolFilter<"DishOrder"> | boolean
    taxIncludedPrice?: FloatNullableFilter<"DishOrder"> | number | null
    quantity?: IntFilter<"DishOrder"> | number
    beforeTaxTotalPrice?: FloatFilter<"DishOrder"> | number
    afterTaxTotalPrice?: FloatFilter<"DishOrder"> | number
    taxRate?: FloatFilter<"DishOrder"> | number
    taxAmount?: FloatFilter<"DishOrder"> | number
    beforeTaxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    afterTaxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    taxTotalDiscountAmount?: FloatFilter<"DishOrder"> | number
    paymentAmount?: FloatFilter<"DishOrder"> | number
    status?: EnumDishOrderStatusFilter<"DishOrder"> | $Enums.DishOrderStatus
    returnedAt?: DateTimeNullableFilter<"DishOrder"> | Date | string | null
    note?: StringNullableFilter<"DishOrder"> | string | null
    orderId?: StringNullableFilter<"DishOrder"> | string | null
    returnedOrderId?: StringNullableFilter<"DishOrder"> | string | null
  }

  export type DishOrderUpsertWithWhereUniqueWithoutReturnedOrderInput = {
    where: DishOrderWhereUniqueInput
    update: XOR<DishOrderUpdateWithoutReturnedOrderInput, DishOrderUncheckedUpdateWithoutReturnedOrderInput>
    create: XOR<DishOrderCreateWithoutReturnedOrderInput, DishOrderUncheckedCreateWithoutReturnedOrderInput>
  }

  export type DishOrderUpdateWithWhereUniqueWithoutReturnedOrderInput = {
    where: DishOrderWhereUniqueInput
    data: XOR<DishOrderUpdateWithoutReturnedOrderInput, DishOrderUncheckedUpdateWithoutReturnedOrderInput>
  }

  export type DishOrderUpdateManyWithWhereWithoutReturnedOrderInput = {
    where: DishOrderScalarWhereInput
    data: XOR<DishOrderUpdateManyMutationInput, DishOrderUncheckedUpdateManyWithoutReturnedOrderInput>
  }

  export type ShopUpsertWithoutOrderInput = {
    update: XOR<ShopUpdateWithoutOrderInput, ShopUncheckedUpdateWithoutOrderInput>
    create: XOR<ShopCreateWithoutOrderInput, ShopUncheckedCreateWithoutOrderInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutOrderInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutOrderInput, ShopUncheckedUpdateWithoutOrderInput>
  }

  export type ShopUpdateWithoutOrderInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutOrderInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type TableUpsertWithoutOrderInput = {
    update: XOR<TableUpdateWithoutOrderInput, TableUncheckedUpdateWithoutOrderInput>
    create: XOR<TableCreateWithoutOrderInput, TableUncheckedCreateWithoutOrderInput>
    where?: TableWhereInput
  }

  export type TableUpdateToOneWithWhereWithoutOrderInput = {
    where?: TableWhereInput
    data: XOR<TableUpdateWithoutOrderInput, TableUncheckedUpdateWithoutOrderInput>
  }

  export type TableUpdateWithoutOrderInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTableNestedInput
    position?: TablePositionUpdateManyWithoutTablesNestedInput
    Kitchen?: KitchenUpdateOneWithoutTablesNestedInput
  }

  export type TableUncheckedUpdateWithoutOrderInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: TablePositionUncheckedUpdateManyWithoutTablesNestedInput
  }

  export type OrderSessionUpsertWithoutOrdersInput = {
    update: XOR<OrderSessionUpdateWithoutOrdersInput, OrderSessionUncheckedUpdateWithoutOrdersInput>
    create: XOR<OrderSessionCreateWithoutOrdersInput, OrderSessionUncheckedCreateWithoutOrdersInput>
    where?: OrderSessionWhereInput
  }

  export type OrderSessionUpdateToOneWithWhereWithoutOrdersInput = {
    where?: OrderSessionWhereInput
    data: XOR<OrderSessionUpdateWithoutOrdersInput, OrderSessionUncheckedUpdateWithoutOrdersInput>
  }

  export type OrderSessionUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discounts?: DiscountUpdateManyWithoutOrderSessionNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateWithoutOrdersInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discounts?: DiscountUncheckedUpdateManyWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
  }

  export type CustomerUpsertWithoutOrderInput = {
    update: XOR<CustomerUpdateWithoutOrderInput, CustomerUncheckedUpdateWithoutOrderInput>
    create: XOR<CustomerCreateWithoutOrderInput, CustomerUncheckedCreateWithoutOrderInput>
    where?: CustomerWhereInput
  }

  export type CustomerUpdateToOneWithWhereWithoutOrderInput = {
    where?: CustomerWhereInput
    data: XOR<CustomerUpdateWithoutOrderInput, CustomerUncheckedUpdateWithoutOrderInput>
  }

  export type CustomerUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUpdateManyWithoutCustomerNestedInput
  }

  export type CustomerUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    anonymous?: NullableBoolFieldUpdateOperationsInput | boolean | null
    totalOrderTimes?: NullableIntFieldUpdateOperationsInput | number | null
    totalOrderValue?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tokens?: TokenUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type UserUpsertWithoutApproveOrderInput = {
    update: XOR<UserUpdateWithoutApproveOrderInput, UserUncheckedUpdateWithoutApproveOrderInput>
    create: XOR<UserCreateWithoutApproveOrderInput, UserUncheckedCreateWithoutApproveOrderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutApproveOrderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutApproveOrderInput, UserUncheckedUpdateWithoutApproveOrderInput>
  }

  export type UserUpdateWithoutApproveOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    shop?: ShopUpdateManyWithoutOwnerNestedInput
    token?: TokenUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUpdateManyWithoutUserNestedInput
    cancelledOrder?: OrderUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUncheckedUpdateWithoutApproveOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    shop?: ShopUncheckedUpdateManyWithoutOwnerNestedInput
    token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUncheckedUpdateManyWithoutUserNestedInput
    cancelledOrder?: OrderUncheckedUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUpsertWithoutCancelledOrderInput = {
    update: XOR<UserUpdateWithoutCancelledOrderInput, UserUncheckedUpdateWithoutCancelledOrderInput>
    create: XOR<UserCreateWithoutCancelledOrderInput, UserUncheckedCreateWithoutCancelledOrderInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCancelledOrderInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCancelledOrderInput, UserUncheckedUpdateWithoutCancelledOrderInput>
  }

  export type UserUpdateWithoutCancelledOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    shop?: ShopUpdateManyWithoutOwnerNestedInput
    token?: TokenUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutCancelledOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    shop?: ShopUncheckedUpdateManyWithoutOwnerNestedInput
    token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUncheckedUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type KitchenLogUpsertWithWhereUniqueWithoutOrderInput = {
    where: KitchenLogWhereUniqueInput
    update: XOR<KitchenLogUpdateWithoutOrderInput, KitchenLogUncheckedUpdateWithoutOrderInput>
    create: XOR<KitchenLogCreateWithoutOrderInput, KitchenLogUncheckedCreateWithoutOrderInput>
  }

  export type KitchenLogUpdateWithWhereUniqueWithoutOrderInput = {
    where: KitchenLogWhereUniqueInput
    data: XOR<KitchenLogUpdateWithoutOrderInput, KitchenLogUncheckedUpdateWithoutOrderInput>
  }

  export type KitchenLogUpdateManyWithWhereWithoutOrderInput = {
    where: KitchenLogScalarWhereInput
    data: XOR<KitchenLogUpdateManyMutationInput, KitchenLogUncheckedUpdateManyWithoutOrderInput>
  }

  export type DiscountCreateWithoutDiscountProductsInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderSession?: OrderSessionCreateNestedOneWithoutDiscountsInput
  }

  export type DiscountUncheckedCreateWithoutDiscountProductsInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    orderSessionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountCreateOrConnectWithoutDiscountProductsInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutDiscountProductsInput, DiscountUncheckedCreateWithoutDiscountProductsInput>
  }

  export type DiscountUpsertWithoutDiscountProductsInput = {
    update: XOR<DiscountUpdateWithoutDiscountProductsInput, DiscountUncheckedUpdateWithoutDiscountProductsInput>
    create: XOR<DiscountCreateWithoutDiscountProductsInput, DiscountUncheckedCreateWithoutDiscountProductsInput>
    where?: DiscountWhereInput
  }

  export type DiscountUpdateToOneWithWhereWithoutDiscountProductsInput = {
    where?: DiscountWhereInput
    data: XOR<DiscountUpdateWithoutDiscountProductsInput, DiscountUncheckedUpdateWithoutDiscountProductsInput>
  }

  export type DiscountUpdateWithoutDiscountProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderSession?: OrderSessionUpdateOneWithoutDiscountsNestedInput
  }

  export type DiscountUncheckedUpdateWithoutDiscountProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    orderSessionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductCreateWithoutDiscountInput = {
    id?: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountProductUncheckedCreateWithoutDiscountInput = {
    id?: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountProductCreateOrConnectWithoutDiscountInput = {
    where: DiscountProductWhereUniqueInput
    create: XOR<DiscountProductCreateWithoutDiscountInput, DiscountProductUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountProductCreateManyDiscountInputEnvelope = {
    data: DiscountProductCreateManyDiscountInput | DiscountProductCreateManyDiscountInput[]
    skipDuplicates?: boolean
  }

  export type OrderSessionCreateWithoutDiscountsInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOrderSessionInput
    shop: ShopCreateNestedOneWithoutOrderSessionInput
    taxDetails?: TaxDetailCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUncheckedCreateWithoutDiscountsInput = {
    id?: string
    shopId: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOrderSessionInput
    taxDetails?: TaxDetailUncheckedCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailUncheckedCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionCreateOrConnectWithoutDiscountsInput = {
    where: OrderSessionWhereUniqueInput
    create: XOR<OrderSessionCreateWithoutDiscountsInput, OrderSessionUncheckedCreateWithoutDiscountsInput>
  }

  export type DiscountProductUpsertWithWhereUniqueWithoutDiscountInput = {
    where: DiscountProductWhereUniqueInput
    update: XOR<DiscountProductUpdateWithoutDiscountInput, DiscountProductUncheckedUpdateWithoutDiscountInput>
    create: XOR<DiscountProductCreateWithoutDiscountInput, DiscountProductUncheckedCreateWithoutDiscountInput>
  }

  export type DiscountProductUpdateWithWhereUniqueWithoutDiscountInput = {
    where: DiscountProductWhereUniqueInput
    data: XOR<DiscountProductUpdateWithoutDiscountInput, DiscountProductUncheckedUpdateWithoutDiscountInput>
  }

  export type DiscountProductUpdateManyWithWhereWithoutDiscountInput = {
    where: DiscountProductScalarWhereInput
    data: XOR<DiscountProductUpdateManyMutationInput, DiscountProductUncheckedUpdateManyWithoutDiscountInput>
  }

  export type DiscountProductScalarWhereInput = {
    AND?: DiscountProductScalarWhereInput | DiscountProductScalarWhereInput[]
    OR?: DiscountProductScalarWhereInput[]
    NOT?: DiscountProductScalarWhereInput | DiscountProductScalarWhereInput[]
    id?: StringFilter<"DiscountProduct"> | string
    dishOrderId?: StringFilter<"DiscountProduct"> | string
    dishId?: StringFilter<"DiscountProduct"> | string
    dishName?: StringFilter<"DiscountProduct"> | string
    discountRate?: FloatFilter<"DiscountProduct"> | number
    discountValue?: FloatFilter<"DiscountProduct"> | number
    discountValueType?: EnumDiscountValueTypeFilter<"DiscountProduct"> | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    afterTaxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    taxDiscountPrice?: FloatFilter<"DiscountProduct"> | number
    discountId?: StringFilter<"DiscountProduct"> | string
    createdAt?: DateTimeFilter<"DiscountProduct"> | Date | string
    updatedAt?: DateTimeFilter<"DiscountProduct"> | Date | string
  }

  export type OrderSessionUpsertWithoutDiscountsInput = {
    update: XOR<OrderSessionUpdateWithoutDiscountsInput, OrderSessionUncheckedUpdateWithoutDiscountsInput>
    create: XOR<OrderSessionCreateWithoutDiscountsInput, OrderSessionUncheckedCreateWithoutDiscountsInput>
    where?: OrderSessionWhereInput
  }

  export type OrderSessionUpdateToOneWithWhereWithoutDiscountsInput = {
    where?: OrderSessionWhereInput
    data: XOR<OrderSessionUpdateWithoutDiscountsInput, OrderSessionUncheckedUpdateWithoutDiscountsInput>
  }

  export type OrderSessionUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOrderSessionNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateWithoutDiscountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionCreateWithoutTaxDetailsInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountCreateNestedManyWithoutOrderSessionInput
    shop: ShopCreateNestedOneWithoutOrderSessionInput
    paymentDetails?: PaymentDetailCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUncheckedCreateWithoutTaxDetailsInput = {
    id?: string
    shopId: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailUncheckedCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionCreateOrConnectWithoutTaxDetailsInput = {
    where: OrderSessionWhereUniqueInput
    create: XOR<OrderSessionCreateWithoutTaxDetailsInput, OrderSessionUncheckedCreateWithoutTaxDetailsInput>
  }

  export type OrderSessionUpsertWithoutTaxDetailsInput = {
    update: XOR<OrderSessionUpdateWithoutTaxDetailsInput, OrderSessionUncheckedUpdateWithoutTaxDetailsInput>
    create: XOR<OrderSessionCreateWithoutTaxDetailsInput, OrderSessionUncheckedCreateWithoutTaxDetailsInput>
    where?: OrderSessionWhereInput
  }

  export type OrderSessionUpdateToOneWithWhereWithoutTaxDetailsInput = {
    where?: OrderSessionWhereInput
    data: XOR<OrderSessionUpdateWithoutTaxDetailsInput, OrderSessionUncheckedUpdateWithoutTaxDetailsInput>
  }

  export type OrderSessionUpdateWithoutTaxDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUpdateManyWithoutOrderSessionNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateWithoutTaxDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionCreateWithoutPaymentDetailsInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountCreateNestedManyWithoutOrderSessionInput
    shop: ShopCreateNestedOneWithoutOrderSessionInput
    taxDetails?: TaxDetailCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUncheckedCreateWithoutPaymentDetailsInput = {
    id?: string
    shopId: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderSessionInput
    taxDetails?: TaxDetailUncheckedCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionCreateOrConnectWithoutPaymentDetailsInput = {
    where: OrderSessionWhereUniqueInput
    create: XOR<OrderSessionCreateWithoutPaymentDetailsInput, OrderSessionUncheckedCreateWithoutPaymentDetailsInput>
  }

  export type OrderSessionUpsertWithoutPaymentDetailsInput = {
    update: XOR<OrderSessionUpdateWithoutPaymentDetailsInput, OrderSessionUncheckedUpdateWithoutPaymentDetailsInput>
    create: XOR<OrderSessionCreateWithoutPaymentDetailsInput, OrderSessionUncheckedCreateWithoutPaymentDetailsInput>
    where?: OrderSessionWhereInput
  }

  export type OrderSessionUpdateToOneWithWhereWithoutPaymentDetailsInput = {
    where?: OrderSessionWhereInput
    data: XOR<OrderSessionUpdateWithoutPaymentDetailsInput, OrderSessionUncheckedUpdateWithoutPaymentDetailsInput>
  }

  export type OrderSessionUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUpdateManyWithoutOrderSessionNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateWithoutPaymentDetailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderCreateWithoutOrderSessionInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutOrderSessionInput = {
    id?: string
    shopId: string
    tableId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutOrderSessionInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutOrderSessionInput, OrderUncheckedCreateWithoutOrderSessionInput>
  }

  export type OrderCreateManyOrderSessionInputEnvelope = {
    data: OrderCreateManyOrderSessionInput | OrderCreateManyOrderSessionInput[]
    skipDuplicates?: boolean
  }

  export type DiscountCreateWithoutOrderSessionInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discountProducts?: DiscountProductCreateNestedManyWithoutDiscountInput
  }

  export type DiscountUncheckedCreateWithoutOrderSessionInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
    discountProducts?: DiscountProductUncheckedCreateNestedManyWithoutDiscountInput
  }

  export type DiscountCreateOrConnectWithoutOrderSessionInput = {
    where: DiscountWhereUniqueInput
    create: XOR<DiscountCreateWithoutOrderSessionInput, DiscountUncheckedCreateWithoutOrderSessionInput>
  }

  export type DiscountCreateManyOrderSessionInputEnvelope = {
    data: DiscountCreateManyOrderSessionInput | DiscountCreateManyOrderSessionInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutOrderSessionInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutOrderSessionInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutOrderSessionInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutOrderSessionInput, ShopUncheckedCreateWithoutOrderSessionInput>
  }

  export type TaxDetailCreateWithoutOrderSessionInput = {
    id?: string
    taxAmount: number
    taxRate: number
  }

  export type TaxDetailUncheckedCreateWithoutOrderSessionInput = {
    id?: string
    taxAmount: number
    taxRate: number
  }

  export type TaxDetailCreateOrConnectWithoutOrderSessionInput = {
    where: TaxDetailWhereUniqueInput
    create: XOR<TaxDetailCreateWithoutOrderSessionInput, TaxDetailUncheckedCreateWithoutOrderSessionInput>
  }

  export type TaxDetailCreateManyOrderSessionInputEnvelope = {
    data: TaxDetailCreateManyOrderSessionInput | TaxDetailCreateManyOrderSessionInput[]
    skipDuplicates?: boolean
  }

  export type PaymentDetailCreateWithoutOrderSessionInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
  }

  export type PaymentDetailUncheckedCreateWithoutOrderSessionInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
  }

  export type PaymentDetailCreateOrConnectWithoutOrderSessionInput = {
    where: PaymentDetailWhereUniqueInput
    create: XOR<PaymentDetailCreateWithoutOrderSessionInput, PaymentDetailUncheckedCreateWithoutOrderSessionInput>
  }

  export type PaymentDetailCreateManyOrderSessionInputEnvelope = {
    data: PaymentDetailCreateManyOrderSessionInput | PaymentDetailCreateManyOrderSessionInput[]
    skipDuplicates?: boolean
  }

  export type OrderUpsertWithWhereUniqueWithoutOrderSessionInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutOrderSessionInput, OrderUncheckedUpdateWithoutOrderSessionInput>
    create: XOR<OrderCreateWithoutOrderSessionInput, OrderUncheckedCreateWithoutOrderSessionInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutOrderSessionInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutOrderSessionInput, OrderUncheckedUpdateWithoutOrderSessionInput>
  }

  export type OrderUpdateManyWithWhereWithoutOrderSessionInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutOrderSessionInput>
  }

  export type DiscountUpsertWithWhereUniqueWithoutOrderSessionInput = {
    where: DiscountWhereUniqueInput
    update: XOR<DiscountUpdateWithoutOrderSessionInput, DiscountUncheckedUpdateWithoutOrderSessionInput>
    create: XOR<DiscountCreateWithoutOrderSessionInput, DiscountUncheckedCreateWithoutOrderSessionInput>
  }

  export type DiscountUpdateWithWhereUniqueWithoutOrderSessionInput = {
    where: DiscountWhereUniqueInput
    data: XOR<DiscountUpdateWithoutOrderSessionInput, DiscountUncheckedUpdateWithoutOrderSessionInput>
  }

  export type DiscountUpdateManyWithWhereWithoutOrderSessionInput = {
    where: DiscountScalarWhereInput
    data: XOR<DiscountUpdateManyMutationInput, DiscountUncheckedUpdateManyWithoutOrderSessionInput>
  }

  export type DiscountScalarWhereInput = {
    AND?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    OR?: DiscountScalarWhereInput[]
    NOT?: DiscountScalarWhereInput | DiscountScalarWhereInput[]
    id?: StringFilter<"Discount"> | string
    name?: StringFilter<"Discount"> | string
    discountType?: EnumDiscountTypeFilter<"Discount"> | $Enums.DiscountType
    discountValue?: FloatFilter<"Discount"> | number
    discountValueType?: EnumDiscountValueTypeFilter<"Discount"> | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    afterTaxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    taxTotalDiscountAmount?: FloatFilter<"Discount"> | number
    orderSessionId?: StringNullableFilter<"Discount"> | string | null
    createdAt?: DateTimeFilter<"Discount"> | Date | string
    updatedAt?: DateTimeFilter<"Discount"> | Date | string
  }

  export type ShopUpsertWithoutOrderSessionInput = {
    update: XOR<ShopUpdateWithoutOrderSessionInput, ShopUncheckedUpdateWithoutOrderSessionInput>
    create: XOR<ShopCreateWithoutOrderSessionInput, ShopUncheckedCreateWithoutOrderSessionInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutOrderSessionInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutOrderSessionInput, ShopUncheckedUpdateWithoutOrderSessionInput>
  }

  export type ShopUpdateWithoutOrderSessionInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutOrderSessionInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
  }

  export type TaxDetailUpsertWithWhereUniqueWithoutOrderSessionInput = {
    where: TaxDetailWhereUniqueInput
    update: XOR<TaxDetailUpdateWithoutOrderSessionInput, TaxDetailUncheckedUpdateWithoutOrderSessionInput>
    create: XOR<TaxDetailCreateWithoutOrderSessionInput, TaxDetailUncheckedCreateWithoutOrderSessionInput>
  }

  export type TaxDetailUpdateWithWhereUniqueWithoutOrderSessionInput = {
    where: TaxDetailWhereUniqueInput
    data: XOR<TaxDetailUpdateWithoutOrderSessionInput, TaxDetailUncheckedUpdateWithoutOrderSessionInput>
  }

  export type TaxDetailUpdateManyWithWhereWithoutOrderSessionInput = {
    where: TaxDetailScalarWhereInput
    data: XOR<TaxDetailUpdateManyMutationInput, TaxDetailUncheckedUpdateManyWithoutOrderSessionInput>
  }

  export type TaxDetailScalarWhereInput = {
    AND?: TaxDetailScalarWhereInput | TaxDetailScalarWhereInput[]
    OR?: TaxDetailScalarWhereInput[]
    NOT?: TaxDetailScalarWhereInput | TaxDetailScalarWhereInput[]
    id?: StringFilter<"TaxDetail"> | string
    taxAmount?: FloatFilter<"TaxDetail"> | number
    taxRate?: FloatFilter<"TaxDetail"> | number
    orderSessionId?: StringFilter<"TaxDetail"> | string
  }

  export type PaymentDetailUpsertWithWhereUniqueWithoutOrderSessionInput = {
    where: PaymentDetailWhereUniqueInput
    update: XOR<PaymentDetailUpdateWithoutOrderSessionInput, PaymentDetailUncheckedUpdateWithoutOrderSessionInput>
    create: XOR<PaymentDetailCreateWithoutOrderSessionInput, PaymentDetailUncheckedCreateWithoutOrderSessionInput>
  }

  export type PaymentDetailUpdateWithWhereUniqueWithoutOrderSessionInput = {
    where: PaymentDetailWhereUniqueInput
    data: XOR<PaymentDetailUpdateWithoutOrderSessionInput, PaymentDetailUncheckedUpdateWithoutOrderSessionInput>
  }

  export type PaymentDetailUpdateManyWithWhereWithoutOrderSessionInput = {
    where: PaymentDetailScalarWhereInput
    data: XOR<PaymentDetailUpdateManyMutationInput, PaymentDetailUncheckedUpdateManyWithoutOrderSessionInput>
  }

  export type PaymentDetailScalarWhereInput = {
    AND?: PaymentDetailScalarWhereInput | PaymentDetailScalarWhereInput[]
    OR?: PaymentDetailScalarWhereInput[]
    NOT?: PaymentDetailScalarWhereInput | PaymentDetailScalarWhereInput[]
    id?: StringFilter<"PaymentDetail"> | string
    paymentMethod?: EnumPaymentMethodEnumFilter<"PaymentDetail"> | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFilter<"PaymentDetail"> | number
    orderSessionId?: StringFilter<"PaymentDetail"> | string
  }

  export type DishCreateWithoutShopInput = {
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    category?: DishCategoryCreateNestedOneWithoutDishInput
    unit?: UnitCreateNestedOneWithoutDishInput
    imageUrls?: ImageCreateNestedManyWithoutDishInput
  }

  export type DishUncheckedCreateWithoutShopInput = {
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    imageUrls?: ImageUncheckedCreateNestedManyWithoutDishInput
  }

  export type DishCreateOrConnectWithoutShopInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutShopInput, DishUncheckedCreateWithoutShopInput>
  }

  export type DishCreateManyShopInputEnvelope = {
    data: DishCreateManyShopInput | DishCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type DishCategoryCreateWithoutShopInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutCategoryInput
    tablePosition?: TablePositionCreateNestedManyWithoutDishCategoriesInput
    kitchen?: KitchenCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryUncheckedCreateWithoutShopInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutCategoryInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutDishCategoriesInput
    kitchen?: KitchenUncheckedCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryCreateOrConnectWithoutShopInput = {
    where: DishCategoryWhereUniqueInput
    create: XOR<DishCategoryCreateWithoutShopInput, DishCategoryUncheckedCreateWithoutShopInput>
  }

  export type DishCategoryCreateManyShopInputEnvelope = {
    data: DishCategoryCreateManyShopInput | DishCategoryCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutShopInput = {
    name?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    department?: EmployeeDepartmentCreateNestedOneWithoutEmployeesInput
    position?: EmployeePositionCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutShopInput = {
    userId: string
    name?: string | null
    positionId?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeCreateOrConnectWithoutShopInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShopInput, EmployeeUncheckedCreateWithoutShopInput>
  }

  export type EmployeeCreateManyShopInputEnvelope = {
    data: EmployeeCreateManyShopInput | EmployeeCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeDepartmentCreateWithoutShopInput = {
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type EmployeeDepartmentUncheckedCreateWithoutShopInput = {
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type EmployeeDepartmentCreateOrConnectWithoutShopInput = {
    where: EmployeeDepartmentWhereUniqueInput
    create: XOR<EmployeeDepartmentCreateWithoutShopInput, EmployeeDepartmentUncheckedCreateWithoutShopInput>
  }

  export type EmployeeDepartmentCreateManyShopInputEnvelope = {
    data: EmployeeDepartmentCreateManyShopInput | EmployeeDepartmentCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type EmployeePositionCreateWithoutShopInput = {
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeCreateNestedManyWithoutPositionInput
  }

  export type EmployeePositionUncheckedCreateWithoutShopInput = {
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employees?: EmployeeUncheckedCreateNestedManyWithoutPositionInput
  }

  export type EmployeePositionCreateOrConnectWithoutShopInput = {
    where: EmployeePositionWhereUniqueInput
    create: XOR<EmployeePositionCreateWithoutShopInput, EmployeePositionUncheckedCreateWithoutShopInput>
  }

  export type EmployeePositionCreateManyShopInputEnvelope = {
    data: EmployeePositionCreateManyShopInput | EmployeePositionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type ImageCreateWithoutShopInput = {
    url: string
    id?: string
    dish?: DishCreateNestedOneWithoutImageUrlsInput
  }

  export type ImageUncheckedCreateWithoutShopInput = {
    url: string
    dishId?: string | null
    id?: string
  }

  export type ImageCreateOrConnectWithoutShopInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutShopInput, ImageUncheckedCreateWithoutShopInput>
  }

  export type ImageCreateManyShopInputEnvelope = {
    data: ImageCreateManyShopInput | ImageCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutShopInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeCreateNestedManyWithoutUserInput
    token?: TokenCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogCreateNestedManyWithoutUserInput
    approveOrder?: OrderCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderCreateNestedManyWithoutCancelledByInput
  }

  export type UserUncheckedCreateWithoutShopInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    employee?: EmployeeUncheckedCreateNestedManyWithoutUserInput
    token?: TokenUncheckedCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutUserInput
    approveOrder?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderUncheckedCreateNestedManyWithoutCancelledByInput
  }

  export type UserCreateOrConnectWithoutShopInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShopInput, UserUncheckedCreateWithoutShopInput>
  }

  export type TableCreateWithoutShopInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    position?: TablePositionCreateNestedManyWithoutTablesInput
    Kitchen?: KitchenCreateNestedOneWithoutTablesInput
    Order?: OrderCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutShopInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    kitchenId?: string | null
    position?: TablePositionUncheckedCreateNestedManyWithoutTablesInput
    Order?: OrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutShopInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutShopInput, TableUncheckedCreateWithoutShopInput>
  }

  export type TableCreateManyShopInputEnvelope = {
    data: TableCreateManyShopInput | TableCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type TablePositionCreateWithoutShopInput = {
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dishCategories?: DishCategoryCreateNestedManyWithoutTablePositionInput
    tables?: TableCreateNestedManyWithoutPositionInput
  }

  export type TablePositionUncheckedCreateWithoutShopInput = {
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dishCategories?: DishCategoryUncheckedCreateNestedManyWithoutTablePositionInput
    tables?: TableUncheckedCreateNestedManyWithoutPositionInput
  }

  export type TablePositionCreateOrConnectWithoutShopInput = {
    where: TablePositionWhereUniqueInput
    create: XOR<TablePositionCreateWithoutShopInput, TablePositionUncheckedCreateWithoutShopInput>
  }

  export type TablePositionCreateManyShopInputEnvelope = {
    data: TablePositionCreateManyShopInput | TablePositionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type UnitCreateWithoutShopInput = {
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutShopInput = {
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitCreateOrConnectWithoutShopInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutShopInput, UnitUncheckedCreateWithoutShopInput>
  }

  export type UnitCreateManyShopInputEnvelope = {
    data: UnitCreateManyShopInput | UnitCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type KitchenCreateWithoutShopInput = {
    id?: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dishCategories?: DishCategoryCreateNestedManyWithoutKitchenInput
    tables?: TableCreateNestedManyWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutShopInput = {
    id?: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dishCategories?: DishCategoryUncheckedCreateNestedManyWithoutKitchenInput
    tables?: TableUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutShopInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutShopInput, KitchenUncheckedCreateWithoutShopInput>
  }

  export type KitchenCreateManyShopInputEnvelope = {
    data: KitchenCreateManyShopInput | KitchenCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type KitchenLogCreateWithoutShopInput = {
    id?: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutKitchenLogInput
    order: OrderCreateNestedOneWithoutKitchenLogInput
  }

  export type KitchenLogUncheckedCreateWithoutShopInput = {
    id?: string
    userId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogCreateOrConnectWithoutShopInput = {
    where: KitchenLogWhereUniqueInput
    create: XOR<KitchenLogCreateWithoutShopInput, KitchenLogUncheckedCreateWithoutShopInput>
  }

  export type KitchenLogCreateManyShopInputEnvelope = {
    data: KitchenLogCreateManyShopInput | KitchenLogCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type OrderCreateWithoutShopInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    table: TableCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutShopInput = {
    id?: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutShopInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput>
  }

  export type OrderCreateManyShopInputEnvelope = {
    data: OrderCreateManyShopInput | OrderCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type OrderSessionCreateWithoutShopInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountCreateNestedManyWithoutOrderSessionInput
    taxDetails?: TaxDetailCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionUncheckedCreateWithoutShopInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orders?: OrderUncheckedCreateNestedManyWithoutOrderSessionInput
    discounts?: DiscountUncheckedCreateNestedManyWithoutOrderSessionInput
    taxDetails?: TaxDetailUncheckedCreateNestedManyWithoutOrderSessionInput
    paymentDetails?: PaymentDetailUncheckedCreateNestedManyWithoutOrderSessionInput
  }

  export type OrderSessionCreateOrConnectWithoutShopInput = {
    where: OrderSessionWhereUniqueInput
    create: XOR<OrderSessionCreateWithoutShopInput, OrderSessionUncheckedCreateWithoutShopInput>
  }

  export type OrderSessionCreateManyShopInputEnvelope = {
    data: OrderSessionCreateManyShopInput | OrderSessionCreateManyShopInput[]
    skipDuplicates?: boolean
  }

  export type DishUpsertWithWhereUniqueWithoutShopInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutShopInput, DishUncheckedUpdateWithoutShopInput>
    create: XOR<DishCreateWithoutShopInput, DishUncheckedCreateWithoutShopInput>
  }

  export type DishUpdateWithWhereUniqueWithoutShopInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutShopInput, DishUncheckedUpdateWithoutShopInput>
  }

  export type DishUpdateManyWithWhereWithoutShopInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutShopInput>
  }

  export type DishScalarWhereInput = {
    AND?: DishScalarWhereInput | DishScalarWhereInput[]
    OR?: DishScalarWhereInput[]
    NOT?: DishScalarWhereInput | DishScalarWhereInput[]
    shopId?: StringNullableFilter<"Dish"> | string | null
    name?: StringNullableFilter<"Dish"> | string | null
    code?: StringNullableFilter<"Dish"> | string | null
    unitId?: StringNullableFilter<"Dish"> | string | null
    price?: FloatNullableFilter<"Dish"> | number | null
    taxIncludedPrice?: FloatNullableFilter<"Dish"> | number | null
    isTaxIncludedPrice?: BoolNullableFilter<"Dish"> | boolean | null
    categoryId?: StringNullableFilter<"Dish"> | string | null
    type?: StringNullableFilter<"Dish"> | string | null
    taxRate?: FloatNullableFilter<"Dish"> | number | null
    status?: EnumSwitchabletatusFilter<"Dish"> | $Enums.Switchabletatus
    isNewlyCreated?: BoolFilter<"Dish"> | boolean
    isBestSeller?: BoolNullableFilter<"Dish"> | boolean | null
    stockQuantity?: FloatNullableFilter<"Dish"> | number | null
    hideForCustomers?: BoolNullableFilter<"Dish"> | boolean | null
    hideForEmployees?: BoolNullableFilter<"Dish"> | boolean | null
    outOfStockNotification?: BoolNullableFilter<"Dish"> | boolean | null
    description?: StringNullableFilter<"Dish"> | string | null
    soldCount?: FloatNullableFilter<"Dish"> | number | null
    createdAt?: DateTimeFilter<"Dish"> | Date | string
    updatedAt?: DateTimeFilter<"Dish"> | Date | string
    id?: StringFilter<"Dish"> | string
  }

  export type DishCategoryUpsertWithWhereUniqueWithoutShopInput = {
    where: DishCategoryWhereUniqueInput
    update: XOR<DishCategoryUpdateWithoutShopInput, DishCategoryUncheckedUpdateWithoutShopInput>
    create: XOR<DishCategoryCreateWithoutShopInput, DishCategoryUncheckedCreateWithoutShopInput>
  }

  export type DishCategoryUpdateWithWhereUniqueWithoutShopInput = {
    where: DishCategoryWhereUniqueInput
    data: XOR<DishCategoryUpdateWithoutShopInput, DishCategoryUncheckedUpdateWithoutShopInput>
  }

  export type DishCategoryUpdateManyWithWhereWithoutShopInput = {
    where: DishCategoryScalarWhereInput
    data: XOR<DishCategoryUpdateManyMutationInput, DishCategoryUncheckedUpdateManyWithoutShopInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutShopInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutShopInput, EmployeeUncheckedUpdateWithoutShopInput>
    create: XOR<EmployeeCreateWithoutShopInput, EmployeeUncheckedCreateWithoutShopInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutShopInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutShopInput, EmployeeUncheckedUpdateWithoutShopInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutShopInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutShopInput>
  }

  export type EmployeeDepartmentUpsertWithWhereUniqueWithoutShopInput = {
    where: EmployeeDepartmentWhereUniqueInput
    update: XOR<EmployeeDepartmentUpdateWithoutShopInput, EmployeeDepartmentUncheckedUpdateWithoutShopInput>
    create: XOR<EmployeeDepartmentCreateWithoutShopInput, EmployeeDepartmentUncheckedCreateWithoutShopInput>
  }

  export type EmployeeDepartmentUpdateWithWhereUniqueWithoutShopInput = {
    where: EmployeeDepartmentWhereUniqueInput
    data: XOR<EmployeeDepartmentUpdateWithoutShopInput, EmployeeDepartmentUncheckedUpdateWithoutShopInput>
  }

  export type EmployeeDepartmentUpdateManyWithWhereWithoutShopInput = {
    where: EmployeeDepartmentScalarWhereInput
    data: XOR<EmployeeDepartmentUpdateManyMutationInput, EmployeeDepartmentUncheckedUpdateManyWithoutShopInput>
  }

  export type EmployeeDepartmentScalarWhereInput = {
    AND?: EmployeeDepartmentScalarWhereInput | EmployeeDepartmentScalarWhereInput[]
    OR?: EmployeeDepartmentScalarWhereInput[]
    NOT?: EmployeeDepartmentScalarWhereInput | EmployeeDepartmentScalarWhereInput[]
    shopId?: StringFilter<"EmployeeDepartment"> | string
    name?: StringNullableFilter<"EmployeeDepartment"> | string | null
    permissions?: StringNullableListFilter<"EmployeeDepartment">
    status?: EnumStatusFilter<"EmployeeDepartment"> | $Enums.Status
    createdAt?: DateTimeFilter<"EmployeeDepartment"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeDepartment"> | Date | string
    id?: StringFilter<"EmployeeDepartment"> | string
  }

  export type EmployeePositionUpsertWithWhereUniqueWithoutShopInput = {
    where: EmployeePositionWhereUniqueInput
    update: XOR<EmployeePositionUpdateWithoutShopInput, EmployeePositionUncheckedUpdateWithoutShopInput>
    create: XOR<EmployeePositionCreateWithoutShopInput, EmployeePositionUncheckedCreateWithoutShopInput>
  }

  export type EmployeePositionUpdateWithWhereUniqueWithoutShopInput = {
    where: EmployeePositionWhereUniqueInput
    data: XOR<EmployeePositionUpdateWithoutShopInput, EmployeePositionUncheckedUpdateWithoutShopInput>
  }

  export type EmployeePositionUpdateManyWithWhereWithoutShopInput = {
    where: EmployeePositionScalarWhereInput
    data: XOR<EmployeePositionUpdateManyMutationInput, EmployeePositionUncheckedUpdateManyWithoutShopInput>
  }

  export type EmployeePositionScalarWhereInput = {
    AND?: EmployeePositionScalarWhereInput | EmployeePositionScalarWhereInput[]
    OR?: EmployeePositionScalarWhereInput[]
    NOT?: EmployeePositionScalarWhereInput | EmployeePositionScalarWhereInput[]
    shopId?: StringFilter<"EmployeePosition"> | string
    name?: StringNullableFilter<"EmployeePosition"> | string | null
    status?: EnumStatusFilter<"EmployeePosition"> | $Enums.Status
    createdAt?: DateTimeFilter<"EmployeePosition"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeePosition"> | Date | string
    id?: StringFilter<"EmployeePosition"> | string
  }

  export type ImageUpsertWithWhereUniqueWithoutShopInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutShopInput, ImageUncheckedUpdateWithoutShopInput>
    create: XOR<ImageCreateWithoutShopInput, ImageUncheckedCreateWithoutShopInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutShopInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutShopInput, ImageUncheckedUpdateWithoutShopInput>
  }

  export type ImageUpdateManyWithWhereWithoutShopInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutShopInput>
  }

  export type ImageScalarWhereInput = {
    AND?: ImageScalarWhereInput | ImageScalarWhereInput[]
    OR?: ImageScalarWhereInput[]
    NOT?: ImageScalarWhereInput | ImageScalarWhereInput[]
    url?: StringFilter<"Image"> | string
    shopId?: StringNullableFilter<"Image"> | string | null
    dishId?: StringNullableFilter<"Image"> | string | null
    id?: StringFilter<"Image"> | string
  }

  export type UserUpsertWithoutShopInput = {
    update: XOR<UserUpdateWithoutShopInput, UserUncheckedUpdateWithoutShopInput>
    create: XOR<UserCreateWithoutShopInput, UserUncheckedCreateWithoutShopInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShopInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShopInput, UserUncheckedUpdateWithoutShopInput>
  }

  export type UserUpdateWithoutShopInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateManyWithoutUserNestedInput
    token?: TokenUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUncheckedUpdateWithoutShopInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUncheckedUpdateManyWithoutUserNestedInput
    token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUncheckedUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUncheckedUpdateManyWithoutCancelledByNestedInput
  }

  export type TableUpsertWithWhereUniqueWithoutShopInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutShopInput, TableUncheckedUpdateWithoutShopInput>
    create: XOR<TableCreateWithoutShopInput, TableUncheckedCreateWithoutShopInput>
  }

  export type TableUpdateWithWhereUniqueWithoutShopInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutShopInput, TableUncheckedUpdateWithoutShopInput>
  }

  export type TableUpdateManyWithWhereWithoutShopInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutShopInput>
  }

  export type TablePositionUpsertWithWhereUniqueWithoutShopInput = {
    where: TablePositionWhereUniqueInput
    update: XOR<TablePositionUpdateWithoutShopInput, TablePositionUncheckedUpdateWithoutShopInput>
    create: XOR<TablePositionCreateWithoutShopInput, TablePositionUncheckedCreateWithoutShopInput>
  }

  export type TablePositionUpdateWithWhereUniqueWithoutShopInput = {
    where: TablePositionWhereUniqueInput
    data: XOR<TablePositionUpdateWithoutShopInput, TablePositionUncheckedUpdateWithoutShopInput>
  }

  export type TablePositionUpdateManyWithWhereWithoutShopInput = {
    where: TablePositionScalarWhereInput
    data: XOR<TablePositionUpdateManyMutationInput, TablePositionUncheckedUpdateManyWithoutShopInput>
  }

  export type TablePositionScalarWhereInput = {
    AND?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
    OR?: TablePositionScalarWhereInput[]
    NOT?: TablePositionScalarWhereInput | TablePositionScalarWhereInput[]
    shopId?: StringFilter<"TablePosition"> | string
    name?: StringNullableFilter<"TablePosition"> | string | null
    dishCategoryIds?: StringNullableListFilter<"TablePosition">
    tableIds?: StringNullableListFilter<"TablePosition">
    status?: EnumStatusFilter<"TablePosition"> | $Enums.Status
    createdAt?: DateTimeFilter<"TablePosition"> | Date | string
    updatedAt?: DateTimeFilter<"TablePosition"> | Date | string
    id?: StringFilter<"TablePosition"> | string
  }

  export type UnitUpsertWithWhereUniqueWithoutShopInput = {
    where: UnitWhereUniqueInput
    update: XOR<UnitUpdateWithoutShopInput, UnitUncheckedUpdateWithoutShopInput>
    create: XOR<UnitCreateWithoutShopInput, UnitUncheckedCreateWithoutShopInput>
  }

  export type UnitUpdateWithWhereUniqueWithoutShopInput = {
    where: UnitWhereUniqueInput
    data: XOR<UnitUpdateWithoutShopInput, UnitUncheckedUpdateWithoutShopInput>
  }

  export type UnitUpdateManyWithWhereWithoutShopInput = {
    where: UnitScalarWhereInput
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyWithoutShopInput>
  }

  export type UnitScalarWhereInput = {
    AND?: UnitScalarWhereInput | UnitScalarWhereInput[]
    OR?: UnitScalarWhereInput[]
    NOT?: UnitScalarWhereInput | UnitScalarWhereInput[]
    shopId?: StringFilter<"Unit"> | string
    name?: StringNullableFilter<"Unit"> | string | null
    code?: StringNullableFilter<"Unit"> | string | null
    description?: StringNullableFilter<"Unit"> | string | null
    status?: EnumSwitchabletatusFilter<"Unit"> | $Enums.Switchabletatus
    createdAt?: DateTimeFilter<"Unit"> | Date | string
    updatedAt?: DateTimeFilter<"Unit"> | Date | string
    id?: StringFilter<"Unit"> | string
  }

  export type KitchenUpsertWithWhereUniqueWithoutShopInput = {
    where: KitchenWhereUniqueInput
    update: XOR<KitchenUpdateWithoutShopInput, KitchenUncheckedUpdateWithoutShopInput>
    create: XOR<KitchenCreateWithoutShopInput, KitchenUncheckedCreateWithoutShopInput>
  }

  export type KitchenUpdateWithWhereUniqueWithoutShopInput = {
    where: KitchenWhereUniqueInput
    data: XOR<KitchenUpdateWithoutShopInput, KitchenUncheckedUpdateWithoutShopInput>
  }

  export type KitchenUpdateManyWithWhereWithoutShopInput = {
    where: KitchenScalarWhereInput
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyWithoutShopInput>
  }

  export type KitchenScalarWhereInput = {
    AND?: KitchenScalarWhereInput | KitchenScalarWhereInput[]
    OR?: KitchenScalarWhereInput[]
    NOT?: KitchenScalarWhereInput | KitchenScalarWhereInput[]
    id?: StringFilter<"Kitchen"> | string
    shopId?: StringFilter<"Kitchen"> | string
    name?: StringFilter<"Kitchen"> | string
    status?: EnumSwitchabletatusFilter<"Kitchen"> | $Enums.Switchabletatus
    createdAt?: DateTimeFilter<"Kitchen"> | Date | string
    updatedAt?: DateTimeFilter<"Kitchen"> | Date | string
  }

  export type KitchenLogUpsertWithWhereUniqueWithoutShopInput = {
    where: KitchenLogWhereUniqueInput
    update: XOR<KitchenLogUpdateWithoutShopInput, KitchenLogUncheckedUpdateWithoutShopInput>
    create: XOR<KitchenLogCreateWithoutShopInput, KitchenLogUncheckedCreateWithoutShopInput>
  }

  export type KitchenLogUpdateWithWhereUniqueWithoutShopInput = {
    where: KitchenLogWhereUniqueInput
    data: XOR<KitchenLogUpdateWithoutShopInput, KitchenLogUncheckedUpdateWithoutShopInput>
  }

  export type KitchenLogUpdateManyWithWhereWithoutShopInput = {
    where: KitchenLogScalarWhereInput
    data: XOR<KitchenLogUpdateManyMutationInput, KitchenLogUncheckedUpdateManyWithoutShopInput>
  }

  export type OrderUpsertWithWhereUniqueWithoutShopInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutShopInput, OrderUncheckedUpdateWithoutShopInput>
    create: XOR<OrderCreateWithoutShopInput, OrderUncheckedCreateWithoutShopInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutShopInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutShopInput, OrderUncheckedUpdateWithoutShopInput>
  }

  export type OrderUpdateManyWithWhereWithoutShopInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutShopInput>
  }

  export type OrderSessionUpsertWithWhereUniqueWithoutShopInput = {
    where: OrderSessionWhereUniqueInput
    update: XOR<OrderSessionUpdateWithoutShopInput, OrderSessionUncheckedUpdateWithoutShopInput>
    create: XOR<OrderSessionCreateWithoutShopInput, OrderSessionUncheckedCreateWithoutShopInput>
  }

  export type OrderSessionUpdateWithWhereUniqueWithoutShopInput = {
    where: OrderSessionWhereUniqueInput
    data: XOR<OrderSessionUpdateWithoutShopInput, OrderSessionUncheckedUpdateWithoutShopInput>
  }

  export type OrderSessionUpdateManyWithWhereWithoutShopInput = {
    where: OrderSessionScalarWhereInput
    data: XOR<OrderSessionUpdateManyMutationInput, OrderSessionUncheckedUpdateManyWithoutShopInput>
  }

  export type OrderSessionScalarWhereInput = {
    AND?: OrderSessionScalarWhereInput | OrderSessionScalarWhereInput[]
    OR?: OrderSessionScalarWhereInput[]
    NOT?: OrderSessionScalarWhereInput | OrderSessionScalarWhereInput[]
    id?: StringFilter<"OrderSession"> | string
    shopId?: StringFilter<"OrderSession"> | string
    tableIds?: StringNullableListFilter<"OrderSession">
    tableNames?: StringNullableListFilter<"OrderSession">
    orderSessionNo?: IntFilter<"OrderSession"> | number
    taxRate?: FloatFilter<"OrderSession"> | number
    totalTaxAmount?: FloatFilter<"OrderSession"> | number
    endedAt?: DateTimeNullableFilter<"OrderSession"> | Date | string | null
    auditedAt?: DateTimeNullableFilter<"OrderSession"> | Date | string | null
    status?: EnumOrderSessionStatusFilter<"OrderSession"> | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFilter<"OrderSession"> | number
    paymentAmount?: FloatFilter<"OrderSession"> | number
    paidByEmployeeId?: StringNullableFilter<"OrderSession"> | string | null
    paidByEmployeeName?: StringNullableFilter<"OrderSession"> | string | null
    cancelledByEmployeeId?: StringNullableFilter<"OrderSession"> | string | null
    cancelledByEmployeeName?: StringNullableFilter<"OrderSession"> | string | null
    cancellationReason?: StringNullableFilter<"OrderSession"> | string | null
    customerId?: StringNullableFilter<"OrderSession"> | string | null
    customerName?: StringNullableFilter<"OrderSession"> | string | null
    customerPhone?: StringNullableFilter<"OrderSession"> | string | null
    customerAddress?: StringNullableFilter<"OrderSession"> | string | null
    numberOfCustomer?: IntNullableFilter<"OrderSession"> | number | null
    totalDiscountAmountBeforeTax?: FloatFilter<"OrderSession"> | number
    totalDiscountAmountAfterTax?: FloatFilter<"OrderSession"> | number
    createdAt?: DateTimeFilter<"OrderSession"> | Date | string
    updatedAt?: DateTimeFilter<"OrderSession"> | Date | string
  }

  export type DishCreateWithoutImageUrlsInput = {
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    category?: DishCategoryCreateNestedOneWithoutDishInput
    shop?: ShopCreateNestedOneWithoutDishInput
    unit?: UnitCreateNestedOneWithoutDishInput
  }

  export type DishUncheckedCreateWithoutImageUrlsInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishCreateOrConnectWithoutImageUrlsInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutImageUrlsInput, DishUncheckedCreateWithoutImageUrlsInput>
  }

  export type ShopCreateWithoutImageUrlsInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutImageUrlsInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutImageUrlsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutImageUrlsInput, ShopUncheckedCreateWithoutImageUrlsInput>
  }

  export type DishUpsertWithoutImageUrlsInput = {
    update: XOR<DishUpdateWithoutImageUrlsInput, DishUncheckedUpdateWithoutImageUrlsInput>
    create: XOR<DishCreateWithoutImageUrlsInput, DishUncheckedCreateWithoutImageUrlsInput>
    where?: DishWhereInput
  }

  export type DishUpdateToOneWithWhereWithoutImageUrlsInput = {
    where?: DishWhereInput
    data: XOR<DishUpdateWithoutImageUrlsInput, DishUncheckedUpdateWithoutImageUrlsInput>
  }

  export type DishUpdateWithoutImageUrlsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    category?: DishCategoryUpdateOneWithoutDishNestedInput
    shop?: ShopUpdateOneWithoutDishNestedInput
    unit?: UnitUpdateOneWithoutDishNestedInput
  }

  export type DishUncheckedUpdateWithoutImageUrlsInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ShopUpsertWithoutImageUrlsInput = {
    update: XOR<ShopUpdateWithoutImageUrlsInput, ShopUncheckedUpdateWithoutImageUrlsInput>
    create: XOR<ShopCreateWithoutImageUrlsInput, ShopUncheckedCreateWithoutImageUrlsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutImageUrlsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutImageUrlsInput, ShopUncheckedUpdateWithoutImageUrlsInput>
  }

  export type ShopUpdateWithoutImageUrlsInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutImageUrlsInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type DishCreateWithoutCategoryInput = {
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop?: ShopCreateNestedOneWithoutDishInput
    unit?: UnitCreateNestedOneWithoutDishInput
    imageUrls?: ImageCreateNestedManyWithoutDishInput
  }

  export type DishUncheckedCreateWithoutCategoryInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    imageUrls?: ImageUncheckedCreateNestedManyWithoutDishInput
  }

  export type DishCreateOrConnectWithoutCategoryInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput>
  }

  export type DishCreateManyCategoryInputEnvelope = {
    data: DishCreateManyCategoryInput | DishCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutDishCategoryInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutDishCategoryInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutDishCategoryInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutDishCategoryInput, ShopUncheckedCreateWithoutDishCategoryInput>
  }

  export type TablePositionCreateWithoutDishCategoriesInput = {
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTablePositionInput
    tables?: TableCreateNestedManyWithoutPositionInput
  }

  export type TablePositionUncheckedCreateWithoutDishCategoriesInput = {
    shopId: string
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    tables?: TableUncheckedCreateNestedManyWithoutPositionInput
  }

  export type TablePositionCreateOrConnectWithoutDishCategoriesInput = {
    where: TablePositionWhereUniqueInput
    create: XOR<TablePositionCreateWithoutDishCategoriesInput, TablePositionUncheckedCreateWithoutDishCategoriesInput>
  }

  export type KitchenCreateWithoutDishCategoriesInput = {
    id?: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableCreateNestedManyWithoutKitchenInput
    shop: ShopCreateNestedOneWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutDishCategoriesInput = {
    id?: string
    shopId: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tables?: TableUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutDishCategoriesInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutDishCategoriesInput, KitchenUncheckedCreateWithoutDishCategoriesInput>
  }

  export type DishUpsertWithWhereUniqueWithoutCategoryInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutCategoryInput, DishUncheckedUpdateWithoutCategoryInput>
    create: XOR<DishCreateWithoutCategoryInput, DishUncheckedCreateWithoutCategoryInput>
  }

  export type DishUpdateWithWhereUniqueWithoutCategoryInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutCategoryInput, DishUncheckedUpdateWithoutCategoryInput>
  }

  export type DishUpdateManyWithWhereWithoutCategoryInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutCategoryInput>
  }

  export type ShopUpsertWithoutDishCategoryInput = {
    update: XOR<ShopUpdateWithoutDishCategoryInput, ShopUncheckedUpdateWithoutDishCategoryInput>
    create: XOR<ShopCreateWithoutDishCategoryInput, ShopUncheckedCreateWithoutDishCategoryInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutDishCategoryInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutDishCategoryInput, ShopUncheckedUpdateWithoutDishCategoryInput>
  }

  export type ShopUpdateWithoutDishCategoryInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutDishCategoryInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type TablePositionUpsertWithWhereUniqueWithoutDishCategoriesInput = {
    where: TablePositionWhereUniqueInput
    update: XOR<TablePositionUpdateWithoutDishCategoriesInput, TablePositionUncheckedUpdateWithoutDishCategoriesInput>
    create: XOR<TablePositionCreateWithoutDishCategoriesInput, TablePositionUncheckedCreateWithoutDishCategoriesInput>
  }

  export type TablePositionUpdateWithWhereUniqueWithoutDishCategoriesInput = {
    where: TablePositionWhereUniqueInput
    data: XOR<TablePositionUpdateWithoutDishCategoriesInput, TablePositionUncheckedUpdateWithoutDishCategoriesInput>
  }

  export type TablePositionUpdateManyWithWhereWithoutDishCategoriesInput = {
    where: TablePositionScalarWhereInput
    data: XOR<TablePositionUpdateManyMutationInput, TablePositionUncheckedUpdateManyWithoutDishCategoriesInput>
  }

  export type KitchenUpsertWithWhereUniqueWithoutDishCategoriesInput = {
    where: KitchenWhereUniqueInput
    update: XOR<KitchenUpdateWithoutDishCategoriesInput, KitchenUncheckedUpdateWithoutDishCategoriesInput>
    create: XOR<KitchenCreateWithoutDishCategoriesInput, KitchenUncheckedCreateWithoutDishCategoriesInput>
  }

  export type KitchenUpdateWithWhereUniqueWithoutDishCategoriesInput = {
    where: KitchenWhereUniqueInput
    data: XOR<KitchenUpdateWithoutDishCategoriesInput, KitchenUncheckedUpdateWithoutDishCategoriesInput>
  }

  export type KitchenUpdateManyWithWhereWithoutDishCategoriesInput = {
    where: KitchenScalarWhereInput
    data: XOR<KitchenUpdateManyMutationInput, KitchenUncheckedUpdateManyWithoutDishCategoriesInput>
  }

  export type DishCategoryCreateWithoutDishInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop?: ShopCreateNestedOneWithoutDishCategoryInput
    tablePosition?: TablePositionCreateNestedManyWithoutDishCategoriesInput
    kitchen?: KitchenCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryUncheckedCreateWithoutDishInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutDishCategoriesInput
    kitchen?: KitchenUncheckedCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryCreateOrConnectWithoutDishInput = {
    where: DishCategoryWhereUniqueInput
    create: XOR<DishCategoryCreateWithoutDishInput, DishCategoryUncheckedCreateWithoutDishInput>
  }

  export type ShopCreateWithoutDishInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutDishInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutDishInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutDishInput, ShopUncheckedCreateWithoutDishInput>
  }

  export type UnitCreateWithoutDishInput = {
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutUnitInput
  }

  export type UnitUncheckedCreateWithoutDishInput = {
    shopId: string
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UnitCreateOrConnectWithoutDishInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutDishInput, UnitUncheckedCreateWithoutDishInput>
  }

  export type ImageCreateWithoutDishInput = {
    url: string
    id?: string
    shop?: ShopCreateNestedOneWithoutImageUrlsInput
  }

  export type ImageUncheckedCreateWithoutDishInput = {
    url: string
    shopId?: string | null
    id?: string
  }

  export type ImageCreateOrConnectWithoutDishInput = {
    where: ImageWhereUniqueInput
    create: XOR<ImageCreateWithoutDishInput, ImageUncheckedCreateWithoutDishInput>
  }

  export type ImageCreateManyDishInputEnvelope = {
    data: ImageCreateManyDishInput | ImageCreateManyDishInput[]
    skipDuplicates?: boolean
  }

  export type DishCategoryUpsertWithoutDishInput = {
    update: XOR<DishCategoryUpdateWithoutDishInput, DishCategoryUncheckedUpdateWithoutDishInput>
    create: XOR<DishCategoryCreateWithoutDishInput, DishCategoryUncheckedCreateWithoutDishInput>
    where?: DishCategoryWhereInput
  }

  export type DishCategoryUpdateToOneWithWhereWithoutDishInput = {
    where?: DishCategoryWhereInput
    data: XOR<DishCategoryUpdateWithoutDishInput, DishCategoryUncheckedUpdateWithoutDishInput>
  }

  export type DishCategoryUpdateWithoutDishInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneWithoutDishCategoryNestedInput
    tablePosition?: TablePositionUpdateManyWithoutDishCategoriesNestedInput
    kitchen?: KitchenUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateWithoutDishInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    tablePosition?: TablePositionUncheckedUpdateManyWithoutDishCategoriesNestedInput
    kitchen?: KitchenUncheckedUpdateManyWithoutDishCategoriesNestedInput
  }

  export type ShopUpsertWithoutDishInput = {
    update: XOR<ShopUpdateWithoutDishInput, ShopUncheckedUpdateWithoutDishInput>
    create: XOR<ShopCreateWithoutDishInput, ShopUncheckedCreateWithoutDishInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutDishInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutDishInput, ShopUncheckedUpdateWithoutDishInput>
  }

  export type ShopUpdateWithoutDishInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutDishInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UnitUpsertWithoutDishInput = {
    update: XOR<UnitUpdateWithoutDishInput, UnitUncheckedUpdateWithoutDishInput>
    create: XOR<UnitCreateWithoutDishInput, UnitUncheckedCreateWithoutDishInput>
    where?: UnitWhereInput
  }

  export type UnitUpdateToOneWithWhereWithoutDishInput = {
    where?: UnitWhereInput
    data: XOR<UnitUpdateWithoutDishInput, UnitUncheckedUpdateWithoutDishInput>
  }

  export type UnitUpdateWithoutDishInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutDishInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUpsertWithWhereUniqueWithoutDishInput = {
    where: ImageWhereUniqueInput
    update: XOR<ImageUpdateWithoutDishInput, ImageUncheckedUpdateWithoutDishInput>
    create: XOR<ImageCreateWithoutDishInput, ImageUncheckedCreateWithoutDishInput>
  }

  export type ImageUpdateWithWhereUniqueWithoutDishInput = {
    where: ImageWhereUniqueInput
    data: XOR<ImageUpdateWithoutDishInput, ImageUncheckedUpdateWithoutDishInput>
  }

  export type ImageUpdateManyWithWhereWithoutDishInput = {
    where: ImageScalarWhereInput
    data: XOR<ImageUpdateManyMutationInput, ImageUncheckedUpdateManyWithoutDishInput>
  }

  export type DishCreateWithoutUnitInput = {
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    category?: DishCategoryCreateNestedOneWithoutDishInput
    shop?: ShopCreateNestedOneWithoutDishInput
    imageUrls?: ImageCreateNestedManyWithoutDishInput
  }

  export type DishUncheckedCreateWithoutUnitInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    imageUrls?: ImageUncheckedCreateNestedManyWithoutDishInput
  }

  export type DishCreateOrConnectWithoutUnitInput = {
    where: DishWhereUniqueInput
    create: XOR<DishCreateWithoutUnitInput, DishUncheckedCreateWithoutUnitInput>
  }

  export type DishCreateManyUnitInputEnvelope = {
    data: DishCreateManyUnitInput | DishCreateManyUnitInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutUnitInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutUnitInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutUnitInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutUnitInput, ShopUncheckedCreateWithoutUnitInput>
  }

  export type DishUpsertWithWhereUniqueWithoutUnitInput = {
    where: DishWhereUniqueInput
    update: XOR<DishUpdateWithoutUnitInput, DishUncheckedUpdateWithoutUnitInput>
    create: XOR<DishCreateWithoutUnitInput, DishUncheckedCreateWithoutUnitInput>
  }

  export type DishUpdateWithWhereUniqueWithoutUnitInput = {
    where: DishWhereUniqueInput
    data: XOR<DishUpdateWithoutUnitInput, DishUncheckedUpdateWithoutUnitInput>
  }

  export type DishUpdateManyWithWhereWithoutUnitInput = {
    where: DishScalarWhereInput
    data: XOR<DishUpdateManyMutationInput, DishUncheckedUpdateManyWithoutUnitInput>
  }

  export type ShopUpsertWithoutUnitInput = {
    update: XOR<ShopUpdateWithoutUnitInput, ShopUncheckedUpdateWithoutUnitInput>
    create: XOR<ShopCreateWithoutUnitInput, ShopUncheckedCreateWithoutUnitInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutUnitInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutUnitInput, ShopUncheckedUpdateWithoutUnitInput>
  }

  export type ShopUpdateWithoutUnitInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutUnitInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopCreateWithoutTablePositionInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutTablePositionInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutTablePositionInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutTablePositionInput, ShopUncheckedCreateWithoutTablePositionInput>
  }

  export type DishCategoryCreateWithoutTablePositionInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutCategoryInput
    shop?: ShopCreateNestedOneWithoutDishCategoryInput
    kitchen?: KitchenCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryUncheckedCreateWithoutTablePositionInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutCategoryInput
    kitchen?: KitchenUncheckedCreateNestedManyWithoutDishCategoriesInput
  }

  export type DishCategoryCreateOrConnectWithoutTablePositionInput = {
    where: DishCategoryWhereUniqueInput
    create: XOR<DishCategoryCreateWithoutTablePositionInput, DishCategoryUncheckedCreateWithoutTablePositionInput>
  }

  export type TableCreateWithoutPositionInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTableInput
    Kitchen?: KitchenCreateNestedOneWithoutTablesInput
    Order?: OrderCreateNestedManyWithoutTableInput
  }

  export type TableUncheckedCreateWithoutPositionInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    kitchenId?: string | null
    Order?: OrderUncheckedCreateNestedManyWithoutTableInput
  }

  export type TableCreateOrConnectWithoutPositionInput = {
    where: TableWhereUniqueInput
    create: XOR<TableCreateWithoutPositionInput, TableUncheckedCreateWithoutPositionInput>
  }

  export type ShopUpsertWithoutTablePositionInput = {
    update: XOR<ShopUpdateWithoutTablePositionInput, ShopUncheckedUpdateWithoutTablePositionInput>
    create: XOR<ShopCreateWithoutTablePositionInput, ShopUncheckedCreateWithoutTablePositionInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutTablePositionInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutTablePositionInput, ShopUncheckedUpdateWithoutTablePositionInput>
  }

  export type ShopUpdateWithoutTablePositionInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutTablePositionInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type DishCategoryUpsertWithWhereUniqueWithoutTablePositionInput = {
    where: DishCategoryWhereUniqueInput
    update: XOR<DishCategoryUpdateWithoutTablePositionInput, DishCategoryUncheckedUpdateWithoutTablePositionInput>
    create: XOR<DishCategoryCreateWithoutTablePositionInput, DishCategoryUncheckedCreateWithoutTablePositionInput>
  }

  export type DishCategoryUpdateWithWhereUniqueWithoutTablePositionInput = {
    where: DishCategoryWhereUniqueInput
    data: XOR<DishCategoryUpdateWithoutTablePositionInput, DishCategoryUncheckedUpdateWithoutTablePositionInput>
  }

  export type DishCategoryUpdateManyWithWhereWithoutTablePositionInput = {
    where: DishCategoryScalarWhereInput
    data: XOR<DishCategoryUpdateManyMutationInput, DishCategoryUncheckedUpdateManyWithoutTablePositionInput>
  }

  export type TableUpsertWithWhereUniqueWithoutPositionInput = {
    where: TableWhereUniqueInput
    update: XOR<TableUpdateWithoutPositionInput, TableUncheckedUpdateWithoutPositionInput>
    create: XOR<TableCreateWithoutPositionInput, TableUncheckedCreateWithoutPositionInput>
  }

  export type TableUpdateWithWhereUniqueWithoutPositionInput = {
    where: TableWhereUniqueInput
    data: XOR<TableUpdateWithoutPositionInput, TableUncheckedUpdateWithoutPositionInput>
  }

  export type TableUpdateManyWithWhereWithoutPositionInput = {
    where: TableScalarWhereInput
    data: XOR<TableUpdateManyMutationInput, TableUncheckedUpdateManyWithoutPositionInput>
  }

  export type ShopCreateWithoutTableInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutTableInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutTableInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutTableInput, ShopUncheckedCreateWithoutTableInput>
  }

  export type TablePositionCreateWithoutTablesInput = {
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutTablePositionInput
    dishCategories?: DishCategoryCreateNestedManyWithoutTablePositionInput
  }

  export type TablePositionUncheckedCreateWithoutTablesInput = {
    shopId: string
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dishCategories?: DishCategoryUncheckedCreateNestedManyWithoutTablePositionInput
  }

  export type TablePositionCreateOrConnectWithoutTablesInput = {
    where: TablePositionWhereUniqueInput
    create: XOR<TablePositionCreateWithoutTablesInput, TablePositionUncheckedCreateWithoutTablesInput>
  }

  export type KitchenCreateWithoutTablesInput = {
    id?: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dishCategories?: DishCategoryCreateNestedManyWithoutKitchenInput
    shop: ShopCreateNestedOneWithoutKitchenInput
  }

  export type KitchenUncheckedCreateWithoutTablesInput = {
    id?: string
    shopId: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    dishCategories?: DishCategoryUncheckedCreateNestedManyWithoutKitchenInput
  }

  export type KitchenCreateOrConnectWithoutTablesInput = {
    where: KitchenWhereUniqueInput
    create: XOR<KitchenCreateWithoutTablesInput, KitchenUncheckedCreateWithoutTablesInput>
  }

  export type OrderCreateWithoutTableInput = {
    id?: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderCreateNestedManyWithoutReturnedOrderInput
    shop: ShopCreateNestedOneWithoutOrderInput
    orderSession: OrderSessionCreateNestedOneWithoutOrdersInput
    customer?: CustomerCreateNestedOneWithoutOrderInput
    approvedBy?: UserCreateNestedOneWithoutApproveOrderInput
    cancelledBy?: UserCreateNestedOneWithoutCancelledOrderInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutOrderInput
  }

  export type OrderUncheckedCreateWithoutTableInput = {
    id?: string
    shopId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dishOrders?: DishOrderUncheckedCreateNestedManyWithoutOrderInput
    returnedDishOrders?: DishOrderUncheckedCreateNestedManyWithoutReturnedOrderInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutOrderInput
  }

  export type OrderCreateOrConnectWithoutTableInput = {
    where: OrderWhereUniqueInput
    create: XOR<OrderCreateWithoutTableInput, OrderUncheckedCreateWithoutTableInput>
  }

  export type OrderCreateManyTableInputEnvelope = {
    data: OrderCreateManyTableInput | OrderCreateManyTableInput[]
    skipDuplicates?: boolean
  }

  export type ShopUpsertWithoutTableInput = {
    update: XOR<ShopUpdateWithoutTableInput, ShopUncheckedUpdateWithoutTableInput>
    create: XOR<ShopCreateWithoutTableInput, ShopUncheckedCreateWithoutTableInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutTableInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutTableInput, ShopUncheckedUpdateWithoutTableInput>
  }

  export type ShopUpdateWithoutTableInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutTableInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type TablePositionUpsertWithWhereUniqueWithoutTablesInput = {
    where: TablePositionWhereUniqueInput
    update: XOR<TablePositionUpdateWithoutTablesInput, TablePositionUncheckedUpdateWithoutTablesInput>
    create: XOR<TablePositionCreateWithoutTablesInput, TablePositionUncheckedCreateWithoutTablesInput>
  }

  export type TablePositionUpdateWithWhereUniqueWithoutTablesInput = {
    where: TablePositionWhereUniqueInput
    data: XOR<TablePositionUpdateWithoutTablesInput, TablePositionUncheckedUpdateWithoutTablesInput>
  }

  export type TablePositionUpdateManyWithWhereWithoutTablesInput = {
    where: TablePositionScalarWhereInput
    data: XOR<TablePositionUpdateManyMutationInput, TablePositionUncheckedUpdateManyWithoutTablesInput>
  }

  export type KitchenUpsertWithoutTablesInput = {
    update: XOR<KitchenUpdateWithoutTablesInput, KitchenUncheckedUpdateWithoutTablesInput>
    create: XOR<KitchenCreateWithoutTablesInput, KitchenUncheckedCreateWithoutTablesInput>
    where?: KitchenWhereInput
  }

  export type KitchenUpdateToOneWithWhereWithoutTablesInput = {
    where?: KitchenWhereInput
    data: XOR<KitchenUpdateWithoutTablesInput, KitchenUncheckedUpdateWithoutTablesInput>
  }

  export type KitchenUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishCategories?: DishCategoryUpdateManyWithoutKitchenNestedInput
    shop?: ShopUpdateOneRequiredWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutTablesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishCategories?: DishCategoryUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type OrderUpsertWithWhereUniqueWithoutTableInput = {
    where: OrderWhereUniqueInput
    update: XOR<OrderUpdateWithoutTableInput, OrderUncheckedUpdateWithoutTableInput>
    create: XOR<OrderCreateWithoutTableInput, OrderUncheckedCreateWithoutTableInput>
  }

  export type OrderUpdateWithWhereUniqueWithoutTableInput = {
    where: OrderWhereUniqueInput
    data: XOR<OrderUpdateWithoutTableInput, OrderUncheckedUpdateWithoutTableInput>
  }

  export type OrderUpdateManyWithWhereWithoutTableInput = {
    where: OrderScalarWhereInput
    data: XOR<OrderUpdateManyMutationInput, OrderUncheckedUpdateManyWithoutTableInput>
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    name?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    position?: EmployeePositionCreateNestedOneWithoutEmployeesInput
    shop: ShopCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    shopId: string
    userId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutEmployeeDepartmentsInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutEmployeeDepartmentsInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutEmployeeDepartmentsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutEmployeeDepartmentsInput, ShopUncheckedCreateWithoutEmployeeDepartmentsInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type ShopUpsertWithoutEmployeeDepartmentsInput = {
    update: XOR<ShopUpdateWithoutEmployeeDepartmentsInput, ShopUncheckedUpdateWithoutEmployeeDepartmentsInput>
    create: XOR<ShopCreateWithoutEmployeeDepartmentsInput, ShopUncheckedCreateWithoutEmployeeDepartmentsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutEmployeeDepartmentsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutEmployeeDepartmentsInput, ShopUncheckedUpdateWithoutEmployeeDepartmentsInput>
  }

  export type ShopUpdateWithoutEmployeeDepartmentsInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutEmployeeDepartmentsInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type EmployeeCreateWithoutPositionInput = {
    name?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    department?: EmployeeDepartmentCreateNestedOneWithoutEmployeesInput
    shop: ShopCreateNestedOneWithoutEmployeesInput
    user: UserCreateNestedOneWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPositionInput = {
    shopId: string
    userId: string
    name?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeCreateOrConnectWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeCreateManyPositionInputEnvelope = {
    data: EmployeeCreateManyPositionInput | EmployeeCreateManyPositionInput[]
    skipDuplicates?: boolean
  }

  export type ShopCreateWithoutEmployeePositionsInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employees?: EmployeeCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutEmployeePositionsInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutEmployeePositionsInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutEmployeePositionsInput, ShopUncheckedCreateWithoutEmployeePositionsInput>
  }

  export type EmployeeUpsertWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
    create: XOR<EmployeeCreateWithoutPositionInput, EmployeeUncheckedCreateWithoutPositionInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutPositionInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutPositionInput, EmployeeUncheckedUpdateWithoutPositionInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutPositionInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutPositionInput>
  }

  export type ShopUpsertWithoutEmployeePositionsInput = {
    update: XOR<ShopUpdateWithoutEmployeePositionsInput, ShopUncheckedUpdateWithoutEmployeePositionsInput>
    create: XOR<ShopCreateWithoutEmployeePositionsInput, ShopUncheckedCreateWithoutEmployeePositionsInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutEmployeePositionsInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutEmployeePositionsInput, ShopUncheckedUpdateWithoutEmployeePositionsInput>
  }

  export type ShopUpdateWithoutEmployeePositionsInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutEmployeePositionsInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type EmployeeDepartmentCreateWithoutEmployeesInput = {
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutEmployeeDepartmentsInput
  }

  export type EmployeeDepartmentUncheckedCreateWithoutEmployeesInput = {
    shopId: string
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeDepartmentCreateOrConnectWithoutEmployeesInput = {
    where: EmployeeDepartmentWhereUniqueInput
    create: XOR<EmployeeDepartmentCreateWithoutEmployeesInput, EmployeeDepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeePositionCreateWithoutEmployeesInput = {
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop: ShopCreateNestedOneWithoutEmployeePositionsInput
  }

  export type EmployeePositionUncheckedCreateWithoutEmployeesInput = {
    shopId: string
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeePositionCreateOrConnectWithoutEmployeesInput = {
    where: EmployeePositionWhereUniqueInput
    create: XOR<EmployeePositionCreateWithoutEmployeesInput, EmployeePositionUncheckedCreateWithoutEmployeesInput>
  }

  export type ShopCreateWithoutEmployeesInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionCreateNestedManyWithoutShopInput
    imageUrls?: ImageCreateNestedManyWithoutShopInput
    owner?: UserCreateNestedOneWithoutShopInput
    table?: TableCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionCreateNestedManyWithoutShopInput
    unit?: UnitCreateNestedManyWithoutShopInput
    Kitchen?: KitchenCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogCreateNestedManyWithoutShopInput
    Order?: OrderCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionCreateNestedManyWithoutShopInput
  }

  export type ShopUncheckedCreateWithoutEmployeesInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    ownerId?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    dish?: DishUncheckedCreateNestedManyWithoutShopInput
    dishCategory?: DishCategoryUncheckedCreateNestedManyWithoutShopInput
    employeeDepartments?: EmployeeDepartmentUncheckedCreateNestedManyWithoutShopInput
    employeePositions?: EmployeePositionUncheckedCreateNestedManyWithoutShopInput
    imageUrls?: ImageUncheckedCreateNestedManyWithoutShopInput
    table?: TableUncheckedCreateNestedManyWithoutShopInput
    tablePosition?: TablePositionUncheckedCreateNestedManyWithoutShopInput
    unit?: UnitUncheckedCreateNestedManyWithoutShopInput
    Kitchen?: KitchenUncheckedCreateNestedManyWithoutShopInput
    KitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutShopInput
    Order?: OrderUncheckedCreateNestedManyWithoutShopInput
    OrderSession?: OrderSessionUncheckedCreateNestedManyWithoutShopInput
  }

  export type ShopCreateOrConnectWithoutEmployeesInput = {
    where: ShopWhereUniqueInput
    create: XOR<ShopCreateWithoutEmployeesInput, ShopUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop?: ShopCreateNestedManyWithoutOwnerInput
    token?: TokenCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogCreateNestedManyWithoutUserInput
    approveOrder?: OrderCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderCreateNestedManyWithoutCancelledByInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    name: string
    email: string
    phone?: string | null
    password: string
    role?: $Enums.Role
    isEmailVerified?: boolean
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    shop?: ShopUncheckedCreateNestedManyWithoutOwnerInput
    token?: TokenUncheckedCreateNestedManyWithoutUserInput
    kitchenLog?: KitchenLogUncheckedCreateNestedManyWithoutUserInput
    approveOrder?: OrderUncheckedCreateNestedManyWithoutApprovedByInput
    cancelledOrder?: OrderUncheckedCreateNestedManyWithoutCancelledByInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeDepartmentUpsertWithoutEmployeesInput = {
    update: XOR<EmployeeDepartmentUpdateWithoutEmployeesInput, EmployeeDepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EmployeeDepartmentCreateWithoutEmployeesInput, EmployeeDepartmentUncheckedCreateWithoutEmployeesInput>
    where?: EmployeeDepartmentWhereInput
  }

  export type EmployeeDepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: EmployeeDepartmentWhereInput
    data: XOR<EmployeeDepartmentUpdateWithoutEmployeesInput, EmployeeDepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeDepartmentUpdateWithoutEmployeesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutEmployeeDepartmentsNestedInput
  }

  export type EmployeeDepartmentUncheckedUpdateWithoutEmployeesInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeePositionUpsertWithoutEmployeesInput = {
    update: XOR<EmployeePositionUpdateWithoutEmployeesInput, EmployeePositionUncheckedUpdateWithoutEmployeesInput>
    create: XOR<EmployeePositionCreateWithoutEmployeesInput, EmployeePositionUncheckedCreateWithoutEmployeesInput>
    where?: EmployeePositionWhereInput
  }

  export type EmployeePositionUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: EmployeePositionWhereInput
    data: XOR<EmployeePositionUpdateWithoutEmployeesInput, EmployeePositionUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeePositionUpdateWithoutEmployeesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutEmployeePositionsNestedInput
  }

  export type EmployeePositionUncheckedUpdateWithoutEmployeesInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ShopUpsertWithoutEmployeesInput = {
    update: XOR<ShopUpdateWithoutEmployeesInput, ShopUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ShopCreateWithoutEmployeesInput, ShopUncheckedCreateWithoutEmployeesInput>
    where?: ShopWhereInput
  }

  export type ShopUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ShopWhereInput
    data: XOR<ShopUpdateWithoutEmployeesInput, ShopUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShopUpdateWithoutEmployeesInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    owner?: UserUpdateOneWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutEmployeesInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateManyWithoutOwnerNestedInput
    token?: TokenUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUpdateManyWithoutCancelledByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUncheckedUpdateManyWithoutOwnerNestedInput
    token?: TokenUncheckedUpdateManyWithoutUserNestedInput
    kitchenLog?: KitchenLogUncheckedUpdateManyWithoutUserNestedInput
    approveOrder?: OrderUncheckedUpdateManyWithoutApprovedByNestedInput
    cancelledOrder?: OrderUncheckedUpdateManyWithoutCancelledByNestedInput
  }

  export type EmployeeCreateManyUserInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type ShopCreateManyOwnerInput = {
    status?: $Enums.Status
    name?: string | null
    phone?: string | null
    email?: string | null
    taxRate?: number | null
    location?: string | null
    dishPriceRoundingType?: $Enums.RoundingPaymentType
    discountRoundingType?: $Enums.RoundingPaymentType
    taxRoundingType?: $Enums.RoundingPaymentType
    calculateTaxDirectly?: boolean | null
    countryName?: string | null
    countryCurrency?: string | null
    utcOffset?: number
    timezone?: string
    reportTime?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type TokenCreateManyUserInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    customerId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogCreateManyUserInput = {
    id?: string
    shopId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyApprovedByInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCancelledByInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    department?: EmployeeDepartmentUpdateOneWithoutEmployeesNestedInput
    position?: EmployeePositionUpdateOneWithoutEmployeesNestedInput
    shop?: ShopUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUncheckedUpdateManyWithoutUserInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ShopUpdateWithoutOwnerInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUpdateManyWithoutShopNestedInput
    employees?: EmployeeUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUpdateManyWithoutShopNestedInput
    table?: TableUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUpdateManyWithoutShopNestedInput
    unit?: UnitUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutShopNestedInput
    Order?: OrderUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateWithoutOwnerInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutShopNestedInput
    dishCategory?: DishCategoryUncheckedUpdateManyWithoutShopNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutShopNestedInput
    employeeDepartments?: EmployeeDepartmentUncheckedUpdateManyWithoutShopNestedInput
    employeePositions?: EmployeePositionUncheckedUpdateManyWithoutShopNestedInput
    imageUrls?: ImageUncheckedUpdateManyWithoutShopNestedInput
    table?: TableUncheckedUpdateManyWithoutShopNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutShopNestedInput
    unit?: UnitUncheckedUpdateManyWithoutShopNestedInput
    Kitchen?: KitchenUncheckedUpdateManyWithoutShopNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutShopNestedInput
    Order?: OrderUncheckedUpdateManyWithoutShopNestedInput
    OrderSession?: OrderSessionUncheckedUpdateManyWithoutShopNestedInput
  }

  export type ShopUncheckedUpdateManyWithoutOwnerInput = {
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    dishPriceRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    discountRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    taxRoundingType?: EnumRoundingPaymentTypeFieldUpdateOperationsInput | $Enums.RoundingPaymentType
    calculateTaxDirectly?: NullableBoolFieldUpdateOperationsInput | boolean | null
    countryName?: NullableStringFieldUpdateOperationsInput | string | null
    countryCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    utcOffset?: IntFieldUpdateOperationsInput | number
    timezone?: StringFieldUpdateOperationsInput | string
    reportTime?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: CustomerUpdateOneWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutKitchenLogNestedInput
    order?: OrderUpdateOneRequiredWithoutKitchenLogNestedInput
  }

  export type KitchenLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCancelledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCancelledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCancelledByInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyCustomerInput = {
    id?: string
    token: string
    type: $Enums.TokenType
    expires: Date | string
    blacklisted?: boolean
    isCustomer?: boolean
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyCustomerInput = {
    id?: string
    shopId: string
    tableId: string
    orderSessionId: string
    orderNo: number
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TokenUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTokenNestedInput
  }

  export type TokenUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    type?: EnumTokenTypeFieldUpdateOperationsInput | $Enums.TokenType
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    blacklisted?: BoolFieldUpdateOperationsInput | boolean
    isCustomer?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TableCreateManyKitchenInput = {
    shopId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishCategoryUpdateWithoutKitchenInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutCategoryNestedInput
    shop?: ShopUpdateOneWithoutDishCategoryNestedInput
    tablePosition?: TablePositionUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateWithoutKitchenInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutCategoryNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateManyWithoutKitchenInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TableUpdateWithoutKitchenInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTableNestedInput
    position?: TablePositionUpdateManyWithoutTablesNestedInput
    Order?: OrderUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutKitchenInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    position?: TablePositionUncheckedUpdateManyWithoutTablesNestedInput
    Order?: OrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutKitchenInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishOrderCreateManyOrderInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    returnedOrderId?: string | null
  }

  export type DishOrderCreateManyReturnedOrderInput = {
    id?: string
    dishOrderNo?: number | null
    dishId: string
    name: string
    unit: string
    price: number
    isTaxIncludedPrice: boolean
    taxIncludedPrice?: number | null
    quantity: number
    beforeTaxTotalPrice: number
    afterTaxTotalPrice: number
    taxRate: number
    taxAmount: number
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    paymentAmount: number
    status?: $Enums.DishOrderStatus
    returnedAt?: Date | string | null
    note?: string | null
    orderId?: string | null
  }

  export type KitchenLogCreateManyOrderInput = {
    id?: string
    shopId: string
    userId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DishOrderUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    returnedOrder?: OrderUpdateOneWithoutReturnedDishOrdersNestedInput
  }

  export type DishOrderUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    returnedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DishOrderUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    returnedOrderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DishOrderUpdateWithoutReturnedOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    order?: OrderUpdateOneWithoutDishOrdersNestedInput
  }

  export type DishOrderUncheckedUpdateWithoutReturnedOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DishOrderUncheckedUpdateManyWithoutReturnedOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderNo?: NullableIntFieldUpdateOperationsInput | number | null
    dishId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    price?: FloatFieldUpdateOperationsInput | number
    isTaxIncludedPrice?: BoolFieldUpdateOperationsInput | boolean
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    quantity?: IntFieldUpdateOperationsInput | number
    beforeTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalPrice?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    taxAmount?: FloatFieldUpdateOperationsInput | number
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumDishOrderStatusFieldUpdateOperationsInput | $Enums.DishOrderStatus
    returnedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    orderId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type KitchenLogUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shop?: ShopUpdateOneRequiredWithoutKitchenLogNestedInput
    user?: UserUpdateOneRequiredWithoutKitchenLogNestedInput
  }

  export type KitchenLogUncheckedUpdateWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogUncheckedUpdateManyWithoutOrderInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductCreateManyDiscountInput = {
    id?: string
    dishOrderId: string
    dishId: string
    dishName: string
    discountRate: number
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxDiscountPrice: number
    afterTaxDiscountPrice: number
    taxDiscountPrice: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountProductUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductUncheckedUpdateWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountProductUncheckedUpdateManyWithoutDiscountInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    discountRate?: FloatFieldUpdateOperationsInput | number
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    afterTaxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    taxDiscountPrice?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderCreateManyOrderSessionInput = {
    id?: string
    shopId: string
    tableId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DiscountCreateManyOrderSessionInput = {
    id?: string
    name: string
    discountType: $Enums.DiscountType
    discountValue: number
    discountValueType: $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount: number
    afterTaxTotalDiscountAmount: number
    taxTotalDiscountAmount: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaxDetailCreateManyOrderSessionInput = {
    id?: string
    taxAmount: number
    taxRate: number
  }

  export type PaymentDetailCreateManyOrderSessionInput = {
    id?: string
    paymentMethod: $Enums.PaymentMethodEnum
    paymentAmount: number
  }

  export type OrderUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DiscountUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountProducts?: DiscountProductUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    discountProducts?: DiscountProductUncheckedUpdateManyWithoutDiscountNestedInput
  }

  export type DiscountUncheckedUpdateManyWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    discountType?: EnumDiscountTypeFieldUpdateOperationsInput | $Enums.DiscountType
    discountValue?: FloatFieldUpdateOperationsInput | number
    discountValueType?: EnumDiscountValueTypeFieldUpdateOperationsInput | $Enums.DiscountValueType
    beforeTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    afterTaxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    taxTotalDiscountAmount?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaxDetailUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
  }

  export type TaxDetailUncheckedUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
  }

  export type TaxDetailUncheckedUpdateManyWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxAmount?: FloatFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentDetailUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentDetailUncheckedUpdateWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type PaymentDetailUncheckedUpdateManyWithoutOrderSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentMethod?: EnumPaymentMethodEnumFieldUpdateOperationsInput | $Enums.PaymentMethodEnum
    paymentAmount?: FloatFieldUpdateOperationsInput | number
  }

  export type DishCreateManyShopInput = {
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishCategoryCreateManyShopInput = {
    name?: string | null
    code?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeCreateManyShopInput = {
    userId: string
    name?: string | null
    positionId?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeDepartmentCreateManyShopInput = {
    name?: string | null
    permissions?: EmployeeDepartmentCreatepermissionsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeePositionCreateManyShopInput = {
    name?: string | null
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type ImageCreateManyShopInput = {
    url: string
    dishId?: string | null
    id?: string
  }

  export type TableCreateManyShopInput = {
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    allowMultipleOrderSession?: boolean | null
    needApprovalWhenCustomerOrder?: boolean | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
    kitchenId?: string | null
  }

  export type TablePositionCreateManyShopInput = {
    name?: string | null
    dishCategoryIds?: TablePositionCreatedishCategoryIdsInput | string[]
    tableIds?: TablePositionCreatetableIdsInput | string[]
    status?: $Enums.Status
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type UnitCreateManyShopInput = {
    name?: string | null
    code?: string | null
    description?: string | null
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type KitchenCreateManyShopInput = {
    id?: string
    name: string
    status?: $Enums.Switchabletatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KitchenLogCreateManyShopInput = {
    id?: string
    userId: string
    orderId: string
    dishOrderId: string
    dishName: string
    dishQuantity: number
    status?: $Enums.Status
    action: $Enums.KitchenActionEnum
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderCreateManyShopInput = {
    id?: string
    tableId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type OrderSessionCreateManyShopInput = {
    id?: string
    tableIds?: OrderSessionCreatetableIdsInput | string[]
    tableNames?: OrderSessionCreatetableNamesInput | string[]
    orderSessionNo: number
    taxRate: number
    totalTaxAmount: number
    endedAt?: Date | string | null
    auditedAt?: Date | string | null
    status?: $Enums.OrderSessionStatus
    pretaxPaymentAmount: number
    paymentAmount: number
    paidByEmployeeId?: string | null
    paidByEmployeeName?: string | null
    cancelledByEmployeeId?: string | null
    cancelledByEmployeeName?: string | null
    cancellationReason?: string | null
    customerId?: string | null
    customerName?: string | null
    customerPhone?: string | null
    customerAddress?: string | null
    numberOfCustomer?: number | null
    totalDiscountAmountBeforeTax: number
    totalDiscountAmountAfterTax: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DishUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    category?: DishCategoryUpdateOneWithoutDishNestedInput
    unit?: UnitUpdateOneWithoutDishNestedInput
    imageUrls?: ImageUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    imageUrls?: ImageUncheckedUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishCategoryUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutCategoryNestedInput
    tablePosition?: TablePositionUpdateManyWithoutDishCategoriesNestedInput
    kitchen?: KitchenUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutCategoryNestedInput
    tablePosition?: TablePositionUncheckedUpdateManyWithoutDishCategoriesNestedInput
    kitchen?: KitchenUncheckedUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    department?: EmployeeDepartmentUpdateOneWithoutEmployeesNestedInput
    position?: EmployeePositionUpdateOneWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShopInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUncheckedUpdateManyWithoutShopInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeDepartmentUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type EmployeeDepartmentUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type EmployeeDepartmentUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: EmployeeDepartmentUpdatepermissionsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeePositionUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUpdateManyWithoutPositionNestedInput
  }

  export type EmployeePositionUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    employees?: EmployeeUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type EmployeePositionUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUpdateWithoutShopInput = {
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateOneWithoutImageUrlsNestedInput
  }

  export type ImageUncheckedUpdateWithoutShopInput = {
    url?: StringFieldUpdateOperationsInput | string
    dishId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyWithoutShopInput = {
    url?: StringFieldUpdateOperationsInput | string
    dishId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TableUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    position?: TablePositionUpdateManyWithoutTablesNestedInput
    Kitchen?: KitchenUpdateOneWithoutTablesNestedInput
    Order?: OrderUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    position?: TablePositionUncheckedUpdateManyWithoutTablesNestedInput
    Order?: OrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TablePositionUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dishCategories?: DishCategoryUpdateManyWithoutTablePositionNestedInput
    tables?: TableUpdateManyWithoutPositionNestedInput
  }

  export type TablePositionUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dishCategories?: DishCategoryUncheckedUpdateManyWithoutTablePositionNestedInput
    tables?: TableUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type TablePositionUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutUnitNestedInput
  }

  export type UnitUncheckedUpdateManyWithoutShopInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type KitchenUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishCategories?: DishCategoryUpdateManyWithoutKitchenNestedInput
    tables?: TableUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishCategories?: DishCategoryUncheckedUpdateManyWithoutKitchenNestedInput
    tables?: TableUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutKitchenLogNestedInput
    order?: OrderUpdateOneRequiredWithoutKitchenLogNestedInput
  }

  export type KitchenLogUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KitchenLogUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    orderId?: StringFieldUpdateOperationsInput | string
    dishOrderId?: StringFieldUpdateOperationsInput | string
    dishName?: StringFieldUpdateOperationsInput | string
    dishQuantity?: IntFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    action?: EnumKitchenActionEnumFieldUpdateOperationsInput | $Enums.KitchenActionEnum
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    table?: TableUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderSessionUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUpdateManyWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orders?: OrderUncheckedUpdateManyWithoutOrderSessionNestedInput
    discounts?: DiscountUncheckedUpdateManyWithoutOrderSessionNestedInput
    taxDetails?: TaxDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
    paymentDetails?: PaymentDetailUncheckedUpdateManyWithoutOrderSessionNestedInput
  }

  export type OrderSessionUncheckedUpdateManyWithoutShopInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableIds?: OrderSessionUpdatetableIdsInput | string[]
    tableNames?: OrderSessionUpdatetableNamesInput | string[]
    orderSessionNo?: IntFieldUpdateOperationsInput | number
    taxRate?: FloatFieldUpdateOperationsInput | number
    totalTaxAmount?: FloatFieldUpdateOperationsInput | number
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    auditedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    pretaxPaymentAmount?: FloatFieldUpdateOperationsInput | number
    paymentAmount?: FloatFieldUpdateOperationsInput | number
    paidByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    paidByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeId?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledByEmployeeName?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationReason?: NullableStringFieldUpdateOperationsInput | string | null
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    customerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    customerAddress?: NullableStringFieldUpdateOperationsInput | string | null
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    totalDiscountAmountBeforeTax?: FloatFieldUpdateOperationsInput | number
    totalDiscountAmountAfterTax?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DishCreateManyCategoryInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    unitId?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishUpdateWithoutCategoryInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneWithoutDishNestedInput
    unit?: UnitUpdateOneWithoutDishNestedInput
    imageUrls?: ImageUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateWithoutCategoryInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    imageUrls?: ImageUncheckedUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateManyWithoutCategoryInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    unitId?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TablePositionUpdateWithoutDishCategoriesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTablePositionNestedInput
    tables?: TableUpdateManyWithoutPositionNestedInput
  }

  export type TablePositionUncheckedUpdateWithoutDishCategoriesInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    tables?: TableUncheckedUpdateManyWithoutPositionNestedInput
  }

  export type TablePositionUncheckedUpdateManyWithoutDishCategoriesInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type KitchenUpdateWithoutDishCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUpdateManyWithoutKitchenNestedInput
    shop?: ShopUpdateOneRequiredWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateWithoutDishCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tables?: TableUncheckedUpdateManyWithoutKitchenNestedInput
  }

  export type KitchenUncheckedUpdateManyWithoutDishCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ImageCreateManyDishInput = {
    url: string
    shopId?: string | null
    id?: string
  }

  export type ImageUpdateWithoutDishInput = {
    url?: StringFieldUpdateOperationsInput | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneWithoutImageUrlsNestedInput
  }

  export type ImageUncheckedUpdateWithoutDishInput = {
    url?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ImageUncheckedUpdateManyWithoutDishInput = {
    url?: StringFieldUpdateOperationsInput | string
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishCreateManyUnitInput = {
    shopId?: string | null
    name?: string | null
    code?: string | null
    price?: number | null
    taxIncludedPrice?: number | null
    isTaxIncludedPrice?: boolean | null
    categoryId?: string | null
    type?: string | null
    taxRate?: number | null
    status?: $Enums.Switchabletatus
    isNewlyCreated?: boolean
    isBestSeller?: boolean | null
    stockQuantity?: number | null
    hideForCustomers?: boolean | null
    hideForEmployees?: boolean | null
    outOfStockNotification?: boolean | null
    description?: string | null
    soldCount?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type DishUpdateWithoutUnitInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    category?: DishCategoryUpdateOneWithoutDishNestedInput
    shop?: ShopUpdateOneWithoutDishNestedInput
    imageUrls?: ImageUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateWithoutUnitInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    imageUrls?: ImageUncheckedUpdateManyWithoutDishNestedInput
  }

  export type DishUncheckedUpdateManyWithoutUnitInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    taxIncludedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    isTaxIncludedPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumSwitchabletatusFieldUpdateOperationsInput | $Enums.Switchabletatus
    isNewlyCreated?: BoolFieldUpdateOperationsInput | boolean
    isBestSeller?: NullableBoolFieldUpdateOperationsInput | boolean | null
    stockQuantity?: NullableFloatFieldUpdateOperationsInput | number | null
    hideForCustomers?: NullableBoolFieldUpdateOperationsInput | boolean | null
    hideForEmployees?: NullableBoolFieldUpdateOperationsInput | boolean | null
    outOfStockNotification?: NullableBoolFieldUpdateOperationsInput | boolean | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    soldCount?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type DishCategoryUpdateWithoutTablePositionInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUpdateManyWithoutCategoryNestedInput
    shop?: ShopUpdateOneWithoutDishCategoryNestedInput
    kitchen?: KitchenUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateWithoutTablePositionInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dish?: DishUncheckedUpdateManyWithoutCategoryNestedInput
    kitchen?: KitchenUncheckedUpdateManyWithoutDishCategoriesNestedInput
  }

  export type DishCategoryUncheckedUpdateManyWithoutTablePositionInput = {
    shopId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type TableUpdateWithoutPositionInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTableNestedInput
    Kitchen?: KitchenUpdateOneWithoutTablesNestedInput
    Order?: OrderUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateWithoutPositionInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
    Order?: OrderUncheckedUpdateManyWithoutTableNestedInput
  }

  export type TableUncheckedUpdateManyWithoutPositionInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    allowMultipleOrderSession?: NullableBoolFieldUpdateOperationsInput | boolean | null
    needApprovalWhenCustomerOrder?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    kitchenId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderCreateManyTableInput = {
    id?: string
    shopId: string
    orderSessionId: string
    orderNo: number
    customerId?: string | null
    totalQuantity: number
    totalBeforeTaxAmount: number
    totalAfterTaxAmount: number
    approvedById?: string | null
    cancelledById?: string | null
    status?: $Enums.Status
    orderSessionStatus?: $Enums.OrderSessionStatus
    numberOfCustomer?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TablePositionUpdateWithoutTablesInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    shop?: ShopUpdateOneRequiredWithoutTablePositionNestedInput
    dishCategories?: DishCategoryUpdateManyWithoutTablePositionNestedInput
  }

  export type TablePositionUncheckedUpdateWithoutTablesInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    dishCategories?: DishCategoryUncheckedUpdateManyWithoutTablePositionNestedInput
  }

  export type TablePositionUncheckedUpdateManyWithoutTablesInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    dishCategoryIds?: TablePositionUpdatedishCategoryIdsInput | string[]
    tableIds?: TablePositionUpdatetableIdsInput | string[]
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type OrderUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUpdateManyWithoutReturnedOrderNestedInput
    shop?: ShopUpdateOneRequiredWithoutOrderNestedInput
    orderSession?: OrderSessionUpdateOneRequiredWithoutOrdersNestedInput
    customer?: CustomerUpdateOneWithoutOrderNestedInput
    approvedBy?: UserUpdateOneWithoutApproveOrderNestedInput
    cancelledBy?: UserUpdateOneWithoutCancelledOrderNestedInput
    KitchenLog?: KitchenLogUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dishOrders?: DishOrderUncheckedUpdateManyWithoutOrderNestedInput
    returnedDishOrders?: DishOrderUncheckedUpdateManyWithoutReturnedOrderNestedInput
    KitchenLog?: KitchenLogUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type OrderUncheckedUpdateManyWithoutTableInput = {
    id?: StringFieldUpdateOperationsInput | string
    shopId?: StringFieldUpdateOperationsInput | string
    orderSessionId?: StringFieldUpdateOperationsInput | string
    orderNo?: IntFieldUpdateOperationsInput | number
    customerId?: NullableStringFieldUpdateOperationsInput | string | null
    totalQuantity?: IntFieldUpdateOperationsInput | number
    totalBeforeTaxAmount?: FloatFieldUpdateOperationsInput | number
    totalAfterTaxAmount?: FloatFieldUpdateOperationsInput | number
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    cancelledById?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    orderSessionStatus?: EnumOrderSessionStatusFieldUpdateOperationsInput | $Enums.OrderSessionStatus
    numberOfCustomer?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    shopId: string
    userId: string
    name?: string | null
    positionId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    position?: EmployeePositionUpdateOneWithoutEmployeesNestedInput
    shop?: ShopUpdateOneRequiredWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    positionId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeCreateManyPositionInput = {
    shopId: string
    userId: string
    name?: string | null
    departmentId?: string | null
    status?: $Enums.Status
    permissions?: EmployeeCreatepermissionsInput | string[]
    createdAt?: Date | string
    updatedAt?: Date | string
    id?: string
  }

  export type EmployeeUpdateWithoutPositionInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
    department?: EmployeeDepartmentUpdateOneWithoutEmployeesNestedInput
    shop?: ShopUpdateOneRequiredWithoutEmployeesNestedInput
    user?: UserUpdateOneRequiredWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPositionInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }

  export type EmployeeUncheckedUpdateManyWithoutPositionInput = {
    shopId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    permissions?: EmployeeUpdatepermissionsInput | string[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    id?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}